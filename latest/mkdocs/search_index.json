{
    "docs": [
        {
            "location": "/", 
            "text": "Devices.jl\n\n\nA \nJulia\n package for CAD of electronic devices, in particular superconducting devices operating at microwave frequencies.\n\n\n\n\nInstallation\n\n\n\n\nPkg.add(\"Clipper\")\n\n\n\n\nWhen Clipper.jl is added, it will be built to compile shared library / DLL files. A compiler will be downloaded for you on Windows.\n\n\n\n\nPkg.clone(\"https://github.com/PainterQubits/Devices.jl.git\")\n\n\n\n\n\n\nQuick start\n\n\nLet's mock up a transmission line with two launchers and some bridges across the transmission line. We begin by making a cell with a rectangle in it:\n\n\nusing\n \nDevices\n,\n \nDevices\n.\nPreferMicrons\n,\n \nFileIO\n\n\n\ncr\n \n=\n \nCell\n(\nrect\n,\n \nnm\n)\n\n\nr\n \n=\n \ncentered\n(\nRectangle\n(\n20\n\u03bcm\n,\n40\n\u03bcm\n))\n\n\nrender!\n(\ncr\n,\n \nr\n;\n \nlayer\n \n=\n \n1\n)\n\n\n\n\n\n\n\n\nNote that when you use \nDevices.PreferMicrons\n, this will also enable the unqualified use of the following units: \npm\n, \nnm\n, \n\u03bcm\n, \nmm\n, \ncm\n, \ndm\n, \nm\n, \n\u00b0\n, \nrad\n. (By unqualified we mean that the symbols are imported into the calling namespace and do not need to be prefixed with a module name.) When adding length units together, if the units don't agree, the result will be in microns. You can \ninstead\n do \nusing\n \nDevices.PreferNanometers\n if you want the result to default to nanometers. (These are your two choices at the moment, though there's nothing fundamentally limiting other possibilities: see \nsrc/units.jl\n for how to do this for other units.)\n\n\nWhen you specify the units for a \nCell\n, you are specifying a database unit. Anything rendered into this cell will be discretized into integer multiples of the database unit. This means that nothing smaller than 1 nm can be represented accurately. Nonetheless, this is typically a satisfactory choice for superconducting devices.\n\n\nIn another cell, we make the transmission line with some launchers on both ends:\n\n\np\n \n=\n \nPath\n(\n\u03bcm\n)\n\n\nsty\n \n=\n \nlaunch!\n(\np\n)\n\n\nstraight!\n(\np\n,\n \n500\n\u03bcm\n,\n \nsty\n)\n\n\nturn!\n(\np\n,\n \n\u03c0\n/\n2\n,\n \n150\n\u03bcm\n)\n\n\nstraight!\n(\np\n,\n \n500\n\u03bcm\n)\n\n\nlaunch!\n(\np\n)\n\n\ncp\n \n=\n \nCell\n(\npathonly\n,\n \nnm\n)\n\n\nrender!\n(\ncp\n,\n \np\n;\n \nlayer\n \n=\n \n0\n)\n\n\n\n\n\n\n\n\nFinally, let's put bridges across the feedline:\n\n\nturnidx\n \n=\n \nInt\n((\nlength\n(\np\n)\n+\n1\n)\n/\n2\n)\n \n-\n \n1\n \n# the first straight segment of the path\n\n\nsimplify!\n(\np\n,\n \nturnidx\n+\n(\n0\n:\n2\n))\n\n\nattach!\n(\np\n,\n \nCellReference\n(\ncr\n,\n \nPoint\n(\n0.0\n\u03bcm\n,\n \n0.0\n\u03bcm\n)),\n \n(\n40\n\u03bcm\n)\n:\n(\n40\n\u03bcm\n)\n:\n((\npathlength\n(\np\n[\nturnidx\n]))\n-\n40\n\u03bcm\n),\n \ni\n=\nturnidx\n)\n\n\nc\n \n=\n \nCell\n(\ndecoratedpath\n,\n \nnm\n)\n\n\nrender!\n(\nc\n,\n \np\n;\n \nlayer\n \n=\n \n0\n)\n\n\n\n\n\n\n\n\nHow easy was that?\n\n\nYou can save a GDS file for e-beam lithography, or an SVG for vector graphics by using \nsave\n with an appropriate extension:\n\n\nsave\n(\n/path/to/myoutput.gds\n,\n \nc\n)\n\n\nsave\n(\n/path/to/myoutput.svg\n,\n \nc\n)\n\n\n\n\n\n\nNote that SVG support is experimental at the moment, and is not at all optimized. It is however used in generating the graphics you see in this documentation. If you use Juno for Atom, rendered cells are automatically previewed in the plot pane provided you enter \nDevices.@junographics\n at the start of your session.\n\n\n\n\nExample without using units\n\n\nFor compatibility and laziness reasons it is possible to use Devices.jl without units at all. \nIf you do not provide units, all values are presumed to be in microns.\n The syntax is otherwise the same:\n\n\nusing\n \nDevices\n,\n \nFileIO\n\n\n\ncr\n \n=\n \nCell\n(\nrect\n)\n\n\nr\n \n=\n \ncentered\n(\nRectangle\n(\n20\n,\n40\n))\n\n\nrender!\n(\ncr\n,\n \nr\n;\n \nlayer\n \n=\n \n1\n)\n\n\n\np\n \n=\n \nPath\n()\n\n\nsty\n \n=\n \nlaunch!\n(\np\n)\n\n\nstraight!\n(\np\n,\n500\n,\nsty\n)\n\n\nturn!\n(\np\n,\n\u03c0\n/\n2\n,\n150\n)\n\n\nstraight!\n(\np\n,\n500\n)\n\n\nlaunch!\n(\np\n)\n\n\ncp\n \n=\n \nCell\n(\npathonly\n)\n\n\nrender!\n(\ncp\n,\n \np\n;\n \nlayer\n \n=\n \n0\n)\n\n\n\nturnidx\n \n=\n \nInt\n((\nlength\n(\np\n)\n+\n1\n)\n/\n2\n)\n \n-\n \n1\n \n# the first straight segment of the path\n\n\nsimplify!\n(\np\n,\n \nturnidx\n+\n(\n0\n:\n2\n))\n\n\nattach!\n(\np\n,\n \nCellReference\n(\ncr\n,\n \nPoint\n(\n0.0\n,\n0.0\n)),\n \n40\n:\n40\n:\n((\npathlength\n(\np\n[\nturnidx\n]))\n-\n40\n),\n \ni\n=\nturnidx\n)\n\n\nc\n \n=\n \nCell\n(\ndecoratedpath\n)\n\n\nrender!\n(\nc\n,\n \np\n;\n \nlayer\n \n=\n \n0\n)\n\n\n\n\n\n\n\n\nTroubleshooting\n\n\n\n\nIf you cannot save the GDS file, try deleting any file that happens to be at the target path. A corrupted file at the target path may prevent saving.\n\n\nDecorated styles should not become part of compound styles, for now. Avoid this by decorating / attaching cell references at the end.", 
            "title": "Home"
        }, 
        {
            "location": "/#devicesjl", 
            "text": "A  Julia  package for CAD of electronic devices, in particular superconducting devices operating at microwave frequencies.", 
            "title": "Devices.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Pkg.add(\"Clipper\")   When Clipper.jl is added, it will be built to compile shared library / DLL files. A compiler will be downloaded for you on Windows.   Pkg.clone(\"https://github.com/PainterQubits/Devices.jl.git\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Let's mock up a transmission line with two launchers and some bridges across the transmission line. We begin by making a cell with a rectangle in it:  using   Devices ,   Devices . PreferMicrons ,   FileIO  cr   =   Cell ( rect ,   nm )  r   =   centered ( Rectangle ( 20 \u03bcm , 40 \u03bcm ))  render! ( cr ,   r ;   layer   =   1 )    Note that when you use  Devices.PreferMicrons , this will also enable the unqualified use of the following units:  pm ,  nm ,  \u03bcm ,  mm ,  cm ,  dm ,  m ,  \u00b0 ,  rad . (By unqualified we mean that the symbols are imported into the calling namespace and do not need to be prefixed with a module name.) When adding length units together, if the units don't agree, the result will be in microns. You can  instead  do  using   Devices.PreferNanometers  if you want the result to default to nanometers. (These are your two choices at the moment, though there's nothing fundamentally limiting other possibilities: see  src/units.jl  for how to do this for other units.)  When you specify the units for a  Cell , you are specifying a database unit. Anything rendered into this cell will be discretized into integer multiples of the database unit. This means that nothing smaller than 1 nm can be represented accurately. Nonetheless, this is typically a satisfactory choice for superconducting devices.  In another cell, we make the transmission line with some launchers on both ends:  p   =   Path ( \u03bcm )  sty   =   launch! ( p )  straight! ( p ,   500 \u03bcm ,   sty )  turn! ( p ,   \u03c0 / 2 ,   150 \u03bcm )  straight! ( p ,   500 \u03bcm )  launch! ( p )  cp   =   Cell ( pathonly ,   nm )  render! ( cp ,   p ;   layer   =   0 )    Finally, let's put bridges across the feedline:  turnidx   =   Int (( length ( p ) + 1 ) / 2 )   -   1   # the first straight segment of the path  simplify! ( p ,   turnidx + ( 0 : 2 ))  attach! ( p ,   CellReference ( cr ,   Point ( 0.0 \u03bcm ,   0.0 \u03bcm )),   ( 40 \u03bcm ) : ( 40 \u03bcm ) : (( pathlength ( p [ turnidx ])) - 40 \u03bcm ),   i = turnidx )  c   =   Cell ( decoratedpath ,   nm )  render! ( c ,   p ;   layer   =   0 )    How easy was that?  You can save a GDS file for e-beam lithography, or an SVG for vector graphics by using  save  with an appropriate extension:  save ( /path/to/myoutput.gds ,   c )  save ( /path/to/myoutput.svg ,   c )   Note that SVG support is experimental at the moment, and is not at all optimized. It is however used in generating the graphics you see in this documentation. If you use Juno for Atom, rendered cells are automatically previewed in the plot pane provided you enter  Devices.@junographics  at the start of your session.", 
            "title": "Quick start"
        }, 
        {
            "location": "/#example-without-using-units", 
            "text": "For compatibility and laziness reasons it is possible to use Devices.jl without units at all.  If you do not provide units, all values are presumed to be in microns.  The syntax is otherwise the same:  using   Devices ,   FileIO  cr   =   Cell ( rect )  r   =   centered ( Rectangle ( 20 , 40 ))  render! ( cr ,   r ;   layer   =   1 )  p   =   Path ()  sty   =   launch! ( p )  straight! ( p , 500 , sty )  turn! ( p , \u03c0 / 2 , 150 )  straight! ( p , 500 )  launch! ( p )  cp   =   Cell ( pathonly )  render! ( cp ,   p ;   layer   =   0 )  turnidx   =   Int (( length ( p ) + 1 ) / 2 )   -   1   # the first straight segment of the path  simplify! ( p ,   turnidx + ( 0 : 2 ))  attach! ( p ,   CellReference ( cr ,   Point ( 0.0 , 0.0 )),   40 : 40 : (( pathlength ( p [ turnidx ])) - 40 ),   i = turnidx )  c   =   Cell ( decoratedpath )  render! ( c ,   p ;   layer   =   0 )", 
            "title": "Example without using units"
        }, 
        {
            "location": "/#troubleshooting", 
            "text": "If you cannot save the GDS file, try deleting any file that happens to be at the target path. A corrupted file at the target path may prevent saving.  Decorated styles should not become part of compound styles, for now. Avoid this by decorating / attaching cell references at the end.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/points/", 
            "text": "Points live in a Cartesian coordinate system with \nReal\n or \nUnitful.Length\n coordinates:\n\n\njulia\n \nPoint\n(\n1\n,\n1\n)\n\n\n2-element Devices.Points.Point{Int64}:\n\n\n 1\n\n\n 1\n\n\n\njulia\n \nPoint\n(\n1.0\n,\n1.0\n)\n\n\n2-element Devices.Points.Point{Float64}:\n\n\n 1.0\n\n\n 1.0\n\n\n\njulia\n \nPoint\n(\n1.0\nu\n\u03bcm\n,\n \n1.0\nu\n\u03bcm\n)\n\n\n2-element Devices.Points.Point{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{\u03bcm}}}:\n\n\n 1.0 \u03bcm\n\n\n 1.0 \u03bcm\n\n\n\n\n\n\nIf a point has \nReal\n coordinates, the absence of a unit is interpreted to mean \n\u03bcm\n whenever the geometry is saved to a GDS format, but until then it is just considered to be a pure number. Therefore you cannot mix and match \nReal\n and \nLength\n coordinates:\n\n\njulia\n \nPoint\n(\n1.0\nu\n\u03bcm\n,\n \n1.0\n)\n\n\nERROR: Cannot use `Point` with this combination of types.\n\n\n\n\n\n\nYou can add Points together or scale them:\n\n\njulia\n \n3\n*\nPoint\n(\n1\n,\n1\n)\n+\nPoint\n(\n1\n,\n2\n)\n\n\n2-element Devices.Points.Point{Int64}:\n\n\n 4\n\n\n 5\n\n\n\n\n\n\nYou can also do affine transformations by composing any number of \nTranslation\n and \nRotation\ns, which will return a callable object representing the transformation. You can type the following Unicode symbols with \n\\degree\n and \n\\circ\n tab-completions in the Julia REPL or using the Atom package \nlatex-completions\n.\n\n\njulia\n \naff\n \n=\n \nRotation\n(\n90\n\u00b0\n)\n \n\u2218\n \nTranslation\n(\nPoint\n(\n1\n,\n2\n))\n\n\nAffineMap([0.0 -1.0; 1.0 0.0], (-2.0,1.0))\n\n\n\njulia\n \naff\n(\nPoint\n(\n0\n,\n0\n))\n\n\n2-element Devices.Points.Point{Float64}:\n\n\n -2.0\n\n\n  1.0\n\n\n\n\n\n\n\n\nAPI\n\n\n#\n\n\nDevices.PointTypes\n \n \nConstant\n.\n\n\ntypealias PointTypes Union{Real,Length,InverseLength}\n\n\n\n\n\nAllowed type variables for \nPoint{T}\n types.\n\n\nsource\n\n\n#\n\n\nDevices.Coordinate\n \n \nConstant\n.\n\n\ntypealias Coordinate Union{Real,Length}\n\n\n\n\n\nType alias for numeric types suitable for coordinate systems.\n\n\nsource\n\n\n#\n\n\nDevices.Points.Point\n \n \nType\n.\n\n\nimmutable Point{T} \n: StaticArrays.FieldVector{T}\n    x::T\n    y::T\nend\n\n\n\n\n\n2D Cartesian coordinate in the plane.\n\n\nsource\n\n\n#\n\n\nDevices.Points.getx\n \n \nFunction\n.\n\n\ngetx(p::Point)\n\n\n\n\n\nGet the x-coordinate of a point. You can also use \np.x\n or \np[1]\n.\n\n\nsource\n\n\n#\n\n\nDevices.Points.gety\n \n \nFunction\n.\n\n\ngety(p::Point)\n\n\n\n\n\nGet the y-coordinate of a point. You can also use \np.y\n or \np[2]\n.\n\n\nsource\n\n\n#\n\n\nDevices.lowerleft\n \n \nFunction\n.\n\n\nlowerleft{T}(A::AbstractArray{Point{T}})\n\n\n\n\n\nReturns the lower-left \nPoint\n of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in \nA\n.\n\n\nExample:\n\n\njulia\n \nlowerleft\n([\nPoint\n(\n2\n,\n0\n),\nPoint\n(\n1\n,\n1\n),\nPoint\n(\n0\n,\n2\n),\nPoint\n(\n-\n1\n,\n3\n)])\n\n\n2-element Devices.Points.Point{Int64}:\n\n\n -1\n\n\n  0\n\n\n\n\n\n\nsource\n\n\nlowerleft(r::Rectangle)\n\n\n\n\n\nReturns the lower-left corner of a rectangle (Point object).\n\n\nsource\n\n\nlowerleft(x::Polygon)\n\n\n\n\n\nReturn the lower-left-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nsource\n\n\n#\n\n\nDevices.upperright\n \n \nFunction\n.\n\n\nupperright{T}(A::AbstractArray{Point{T}})\n\n\n\n\n\nReturns the upper-right \nPoint\n of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in \nA\n.\n\n\nExample:\n\n\njulia\n \nupperright\n([\nPoint\n(\n2\n,\n0\n),\nPoint\n(\n1\n,\n1\n),\nPoint\n(\n0\n,\n2\n),\nPoint\n(\n-\n1\n,\n3\n)])\n\n\n2-element Devices.Points.Point{Int64}:\n\n\n 2\n\n\n 3\n\n\n\n\n\n\nsource\n\n\nupperright(r::Rectangle)\n\n\n\n\n\nReturns the upper-right corner of a rectangle (Point object).\n\n\nsource\n\n\nupperright(x::Polygon)\n\n\n\n\n\nReturn the upper-right-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nsource\n\n\n\n\nImplementation details\n\n\nPoints are implemented using the abstract type \nFieldVector\n from \nStaticArrays.jl\n. This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike \nTuple\n objects, we can add points together, simplifying many function definitions.", 
            "title": "Points"
        }, 
        {
            "location": "/points/#api", 
            "text": "#  Devices.PointTypes     Constant .  typealias PointTypes Union{Real,Length,InverseLength}  Allowed type variables for  Point{T}  types.  source  #  Devices.Coordinate     Constant .  typealias Coordinate Union{Real,Length}  Type alias for numeric types suitable for coordinate systems.  source  #  Devices.Points.Point     Type .  immutable Point{T}  : StaticArrays.FieldVector{T}\n    x::T\n    y::T\nend  2D Cartesian coordinate in the plane.  source  #  Devices.Points.getx     Function .  getx(p::Point)  Get the x-coordinate of a point. You can also use  p.x  or  p[1] .  source  #  Devices.Points.gety     Function .  gety(p::Point)  Get the y-coordinate of a point. You can also use  p.y  or  p[2] .  source  #  Devices.lowerleft     Function .  lowerleft{T}(A::AbstractArray{Point{T}})  Returns the lower-left  Point  of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in  A .  Example:  julia   lowerleft ([ Point ( 2 , 0 ), Point ( 1 , 1 ), Point ( 0 , 2 ), Point ( - 1 , 3 )])  2-element Devices.Points.Point{Int64}:   -1    0   source  lowerleft(r::Rectangle)  Returns the lower-left corner of a rectangle (Point object).  source  lowerleft(x::Polygon)  Return the lower-left-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  source  #  Devices.upperright     Function .  upperright{T}(A::AbstractArray{Point{T}})  Returns the upper-right  Point  of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in  A .  Example:  julia   upperright ([ Point ( 2 , 0 ), Point ( 1 , 1 ), Point ( 0 , 2 ), Point ( - 1 , 3 )])  2-element Devices.Points.Point{Int64}:   2   3   source  upperright(r::Rectangle)  Returns the upper-right corner of a rectangle (Point object).  source  upperright(x::Polygon)  Return the upper-right-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  source", 
            "title": "API"
        }, 
        {
            "location": "/points/#implementation-details", 
            "text": "Points are implemented using the abstract type  FieldVector  from  StaticArrays.jl . This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike  Tuple  objects, we can add points together, simplifying many function definitions.", 
            "title": "Implementation details"
        }, 
        {
            "location": "/polygons/", 
            "text": "Abstract polygons\n\n\nIn this package, any polygon regardless of its concrete representation in memory should be a subtype of \nDevices.AbstractPolygon\n.\n\n\n#\n\n\nDevices.AbstractPolygon\n \n \nType\n.\n\n\nabstract type AbstractPolygon{T\n:Coordinate} end\n\n\n\n\n\nAnything you could call a polygon regardless of the underlying representation. Currently only \nRectangle\n or \nPolygon\n are concrete subtypes, but one could imagine further subtypes to represent specific shapes that appear in highly optimized pattern formats. Examples include the OASIS format (which has 25 implementations of trapezoids) or e-beam lithography pattern files like the Raith GPF format.\n\n\nsource\n\n\n\n\nAffine transformations\n\n\nThe mechanism for affine transformations is largely provided by the \nCoordinateTransformations.jl\n package. For convenience, the documentation for \nTranslation\n and \ncompose\n is reproduced below from that package. We implement our own 2D rotations.\n\n\nAn example of how to use affine transformations with polygons:\n\n\njulia\n \nr\n \n=\n \nRectangle\n(\n1\n,\n1\n)\n\n\nDevices.Rectangles.Rectangle{Int64}((0,0),(1,1),Dict{Symbol,Any}())\n\n\n\njulia\n \ntrans\n \n=\n \nTranslation\n(\n10\n,\n10\n)\n\n\nTranslation(10,10)\n\n\n\njulia\n \ntrans\n \n=\n \nRotation\n(\n90\n\u00b0\n)\n \n\u2218\n \ntrans\n\n\nAffineMap([0.0 -1.0; 1.0 0.0], [-10.0,10.0])\n\n\n\njulia\n \ntrans\n(\nr\n)\n\n\nDevices.Polygons.Polygon{Float64}(Devices.Points.Point{Float64}[(-10.0,10.0),(-10.0,11.0),(-11.0,11.0),(-11.0,10.0)],Dict{Symbol,Any}())\n\n\n\n\n\n\n#\n\n\nCoordinateTransformations.compose\n \n \nFunction\n.\n\n\ncompose(trans1, trans2)\ntrans1 \u2218 trans2\n\n\n\n\n\nTake two transformations and create a new transformation that is equivalent to successively applying \ntrans2\n to the coordinate, and then \ntrans1\n. By default will create a \nComposedTransformation\n, however this method can be overloaded for efficiency (e.g. two affine transformations naturally compose to a single affine transformation).\n\n\nsource\n\n\n#\n\n\nDevices.Points.Rotation\n \n \nFunction\n.\n\n\nRotation(\u0398)\n\n\n\n\n\nConstruct a rotation about the origin. Units accepted (no units \u21d2 radians).\n\n\nsource\n\n\n#\n\n\nCoordinateTransformations.Translation\n \n \nType\n.\n\n\nTranslation(v) \n: AbstractAffineMap\nTranslation(dx, dy)       (2D)\nTranslation(dx, dy, dz)   (3D)\n\n\n\n\n\nConstruct the \nTranslation\n transformation for translating Cartesian points by an offset \nv = (dx, dy, ...)\n\n\nsource\n\n\n#\n\n\nDevices.Points.XReflection\n \n \nFunction\n.\n\n\nXReflection()\n\n\n\n\n\nConstruct a reflection about the x-axis (y-coordinate changes sign).\n\n\nExample:\n\n\njulia\n \ntrans\n \n=\n \nXReflection\n()\n\n\nLinearMap([1 0; 0 -1])\n\n\n\njulia\n \ntrans\n(\nPoint\n(\n1\n,\n1\n))\n\n\n2-element Devices.Points.Point{Int64}:\n\n\n  1\n\n\n -1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Points.YReflection\n \n \nFunction\n.\n\n\nYReflection()\n\n\n\n\n\nConstruct a reflection about the y-axis (x-coordinate changes sign).\n\n\nExample:\n\n\njulia\n \ntrans\n \n=\n \nYReflection\n()\n\n\nLinearMap([-1 0; 0 1])\n\n\n\njulia\n \ntrans\n(\nPoint\n(\n1\n,\n1\n))\n\n\n2-element Devices.Points.Point{Int64}:\n\n\n -1\n\n\n  1\n\n\n\n\n\n\nsource\n\n\n\n\nClipping\n\n\n#\n\n\nDevices.Polygons.clip\n \n \nFunction\n.\n\n\nclip\n{\nS\n:Coordinate,\n \nT\n:Coordinate\n}\n(\nop\n::\nClipper\n.\nClipType\n,\n\n    \ns\n::\nAbstractPolygon\n{\nS\n}\n,\n \nc\n::\nAbstractPolygon\n{\nT\n}\n;\n\n    \npfs\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n,\n\n    \npfc\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n)\n\n\n\n\n\n\nUsing the \nClipper\n library and the \nClipper.jl\n wrapper, perform polygon clipping. The first argument must be one of the following types :\n\n\n\n\nClipper.ClipTypeDifference\n\n\nClipper.ClipTypeIntersection\n\n\nClipper.ClipTypeUnion\n\n\nClipper.ClipTypeXor\n\n\n\n\nNote that these are types; you should not follow them with \n()\n. The second and third arguments are \nAbstractPolygon\n objects. Keyword arguments \npfs\n and \npfc\n specify polygon fill rules (see the \nClipper\n docs\n for further information). These arguments may include:\n\n\n\n\nClipper.PolyFillTypeNegative\n\n\nClipper.PolyFillTypePositive\n\n\nClipper.PolyFillTypeEvenOdd\n\n\nClipper.PolyFillTypeNonZero\n\n\n\n\nsource\n\n\nclip\n{\nS\n:AbstractPolygon,\n \nT\n:AbstractPolygon\n}\n(\nop\n::\nClipper\n.\nClipType\n,\n\n    \ns\n::\nAbstractVector\n{\nS\n}\n,\n \nc\n::\nAbstractVector\n{\nT\n}\n;\n\n    \npfs\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n,\n\n    \npfc\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n)\n\n\n\n\n\n\nPerform polygon clipping. The first argument must be as listed above. The second and third arguments are arrays (vectors) of \nAbstractPolygon\ns. Keyword arguments are explained above.\n\n\nsource\n\n\nclip\n{\nT\n:Polygon\n}\n(\nop\n::\nClipper\n.\nClipType\n,\n\n    \ns\n::\nAbstractVector\n{\nT\n}\n,\n \nc\n::\nAbstractVector\n{\nT\n}\n;\n\n    \npfs\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n,\n\n    \npfc\n::\nClipper\n.\nPolyFillType\n=\nClipper\n.\nPolyFillTypeEvenOdd\n)\n\n\n\n\n\n\nPerform polygon clipping. The first argument must be as listed above. The second and third arguments are identically-typed arrays (vectors) of \nPolygon{T}\n objects. Keyword arguments are explained above.\n\n\nsource\n\n\n\n\nOffsetting\n\n\n#\n\n\nDevices.Polygons.offset\n \n \nFunction\n.\n\n\noffset\n{\nS\n:Coordinate\n}\n(\ns\n::\nAbstractPolygon\n{\nS\n}\n,\n \ndelta\n::\nCoordinate\n;\n\n    \nj\n::\nClipper\n.\nJoinType\n=\nClipper\n.\nJoinTypeMiter\n,\n\n    \ne\n::\nClipper\n.\nEndType\n=\nClipper\n.\nEndTypeClosedPolygon\n)\n\n\n\n\n\n\nUsing the \nClipper\n library and the \nClipper.jl\n wrapper, perform polygon offsetting.\n\n\nThe first argument should be an \nAbstractPolygon\n. The second argument is how much to offset the polygon. Keyword arguments include a \njoin type\n:\n\n\n\n\nClipper.JoinTypeMiter\n\n\nClipper.JoinTypeRound\n\n\nClipper.JoinTypeSquare\n\n\n\n\nand also an \nend type\n:\n\n\n\n\nClipper.EndTypeClosedPolygon\n\n\nClipper.EndTypeClosedLine\n\n\nClipper.EndTypeOpenSquare\n\n\nClipper.EndTypeOpenRound\n\n\nClipper.EndTypeOpenButt\n\n\n\n\nsource\n\n\noffset\n{\nS\n:AbstractPolygon\n}\n(\nsubject\n::\nAbstractVector\n{\nS\n}\n,\n \ndelta\n::\nCoordinate\n;\n\n    \nj\n::\nClipper\n.\nJoinType\n=\nClipper\n.\nJoinTypeMiter\n,\n\n    \ne\n::\nClipper\n.\nEndType\n=\nClipper\n.\nEndTypeClosedPolygon\n)\n\n\n\n\n\n\nPerform polygon offsetting. The first argument is an array (vector) of \nAbstractPolygon\ns. The second argument is how much to offset the polygon. Keyword arguments explained above.\n\n\nsource\n\n\noffset\n{\nS\n:Polygon\n}\n(\ns\n::\nAbstractVector\n{\nS\n}\n,\n \ndelta\n::\nCoordinate\n;\n\n    \nj\n::\nClipper\n.\nJoinType\n=\nClipper\n.\nJoinTypeMiter\n,\n\n    \ne\n::\nClipper\n.\nEndType\n=\nClipper\n.\nEndTypeClosedPolygon\n)\n\n\n\n\n\n\nPerform polygon offsetting. The first argument is an array (vector) of \nPolygon\ns. The second argument is how much to offset the polygon. Keyword arguments explained above.\n\n\nsource\n\n\n\n\nRectangle API\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nType\n.\n\n\ntype Rectangle{T} \n: AbstractPolygon{T}\n    ll::Point{T}\n    ur::Point{T}\n    properties::Dict{Symbol, Any}\n    Rectangle(ll,ur) = Rectangle(ll,ur,Dict{Symbol,Any}())\n    function Rectangle(a,b,props)\n        # Ensure ll is lower-left, ur is upper-right.\n        ll = Point(a.\n=b) .* a + Point(b.\n=a) .* b\n        ur = Point(a.\n=b) .* b + Point(b.\n=a) .* a\n        new(ll,ur,props)\n    end\nend\n\n\n\n\n\nA rectangle, defined by opposing lower-left and upper-right corner coordinates. Lower-left and upper-right are guaranteed to be such by the inner constructor.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\nRectangle\n(\nll\n::\nPoint\n,\n \nur\n::\nPoint\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for \nRectangle\n objects.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\nRectangle(width, height, kwargs...)\n\n\n\n\n\nConstructs \nRectangle\n objects by specifying the width and height rather than the lower-left and upper-right corners.\n\n\nThe rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of \nRectangle{Int}\n type, this would not be possible if either \nwidth\n or \nheight\n were odd numbers. This definition ensures type stability in the constructor.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(r::Rectangle)\n\n\n\n\n\nNo-op (just returns \nr\n).\n\n\nsource\n\n\n#\n\n\nDevices.center\n \n \nMethod\n.\n\n\ncenter(r::Rectangle)\n\n\n\n\n\nReturns a \nPoint\n corresponding to the center of the rectangle.\n\n\nsource\n\n\n#\n\n\nDevices.centered\n \n \nMethod\n.\n\n\ncentered(r::Rectangle)\n\n\n\n\n\nCenters a copy of \nr\n, with promoted coordinates if necessary. This function will not throw an \nInexactError()\n, even if \nr\n had integer coordinates.\n\n\nsource\n\n\n#\n\n\nDevices.centered!\n \n \nMethod\n.\n\n\ncentered!(r::Rectangle)\n\n\n\n\n\nCenters a rectangle. Will throw an \nInexactError()\n if the rectangle cannot be centered with integer coordinates.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.height\n \n \nMethod\n.\n\n\nheight(r::Rectangle)\n\n\n\n\n\nReturn the height of a rectangle.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.isproper\n \n \nMethod\n.\n\n\nisproper(r::Rectangle)\n\n\n\n\n\nReturns \ntrue\n if the rectangle has a non-zero size. Otherwise, returns \nfalse\n. Note that the upper-right and lower-left corners are enforced to be the \nur\n and \nll\n fields of a \nRectangle\n by the inner constructor.\n\n\nsource\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\nminimum(itr)\n\n\n\n\n\nReturns the smallest element in a collection.\n\n\njulia\n \nminimum\n(\n-\n20.5\n:\n10\n)\n\n\n-20.5\n\n\n\njulia\n \nminimum\n([\n1\n,\n2\n,\n3\n])\n\n\n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\nmaximum(itr)\n\n\n\n\n\nReturns the largest element in a collection.\n\n\njulia\n \nmaximum\n(\n-\n20.5\n:\n10\n)\n\n\n9.5\n\n\n\njulia\n \nmaximum\n([\n1\n,\n2\n,\n3\n])\n\n\n3\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.points\n \n \nMethod\n.\n\n\npoints{T}(x::Rectangle{T})\n\n\n\n\n\nReturns the array of \nPoint\n objects defining the rectangle.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.width\n \n \nMethod\n.\n\n\nwidth(r::Rectangle)\n\n\n\n\n\nReturn the width of a rectangle.\n\n\nsource\n\n\n#\n\n\nBase.:+\n \n \nMethod\n.\n\n\n+(r::Rectangle, p::Point)\n\n\n\n\n\nTranslate a rectangle by \np\n.\n\n\nsource\n\n\n\n\nRectangle styles\n\n\n#\n\n\nDevices.Rectangles.Plain\n \n \nType\n.\n\n\nimmutable Plain \n: Style end\n\n\n\n\n\nPlain rectangle style. Use this if you are fond for the simpler times when rectangles were just rectangles.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Rounded\n \n \nType\n.\n\n\nimmutable Rounded{T\n:Coordinate} \n: Style\n    r::T\nend\n\n\n\n\n\nRounded rectangle style. All corners are rounded off with a given radius \nr\n. The bounding box of the unstyled rectangle should remain unaffected.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Undercut\n \n \nType\n.\n\n\nimmutable Undercut{T\n:Coordinate} \n: Style\n    ucl::T\n    uct::T\n    ucr::T\n    ucb::T\nend\n\n\n\n\n\nUndercut rectangles. In each direction around a rectangle (left, top, right, bottom) an undercut is rendered on a different layer.\n\n\nsource\n\n\n\n\nPolygon API\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nType\n.\n\n\ntype Polygon{T} \n: AbstractPolygon{T}\n    p::Array{Point{T},1}\n    properties::Dict{Symbol, Any}\n    Polygon(x,y) = new(x,y)\n    Polygon(x) = new(x, Dict{Symbol, Any}())\nend\n\n\n\n\n\nPolygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\nPolygon\n{\nT\n}\n(\nparr\n::\nAbstractArray\n{\nPoint{T\n}\n,\n1\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\nPolygon\n(\np0\n::\nPoint\n,\n \np1\n::\nPoint\n,\n \np2\n::\nPoint\n,\n \np3\n::\nPoint\n...;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(p::Polygon)\n\n\n\n\n\nReturn a bounding Rectangle with no properties for polygon \np\n.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds{T\n:AbstractPolygon}(parr::AbstractArray{T})\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for an array \nparr\n of \nAbstractPolygon\n objects.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\n objects.\n\n\nsource\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\nminimum(itr)\n\n\n\n\n\nReturns the smallest element in a collection.\n\n\njulia\n \nminimum\n(\n-\n20.5\n:\n10\n)\n\n\n-20.5\n\n\n\njulia\n \nminimum\n([\n1\n,\n2\n,\n3\n])\n\n\n1\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\nmaximum(itr)\n\n\n\n\n\nReturns the largest element in a collection.\n\n\njulia\n \nmaximum\n(\n-\n20.5\n:\n10\n)\n\n\n9.5\n\n\n\njulia\n \nmaximum\n([\n1\n,\n2\n,\n3\n])\n\n\n3\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.points\n \n \nMethod\n.\n\n\npoints(x::Polygon)\n\n\n\n\n\nReturns the array of \nPoint\n objects defining the polygon.\n\n\nsource\n\n\n\n\nPolygon styles\n\n\n#\n\n\nDevices.Polygons.Plain\n \n \nType\n.\n\n\nPlain polygon style.\n\n\nsource", 
            "title": "Polygons"
        }, 
        {
            "location": "/polygons/#abstract-polygons", 
            "text": "In this package, any polygon regardless of its concrete representation in memory should be a subtype of  Devices.AbstractPolygon .  #  Devices.AbstractPolygon     Type .  abstract type AbstractPolygon{T :Coordinate} end  Anything you could call a polygon regardless of the underlying representation. Currently only  Rectangle  or  Polygon  are concrete subtypes, but one could imagine further subtypes to represent specific shapes that appear in highly optimized pattern formats. Examples include the OASIS format (which has 25 implementations of trapezoids) or e-beam lithography pattern files like the Raith GPF format.  source", 
            "title": "Abstract polygons"
        }, 
        {
            "location": "/polygons/#affine-transformations", 
            "text": "The mechanism for affine transformations is largely provided by the  CoordinateTransformations.jl  package. For convenience, the documentation for  Translation  and  compose  is reproduced below from that package. We implement our own 2D rotations.  An example of how to use affine transformations with polygons:  julia   r   =   Rectangle ( 1 , 1 )  Devices.Rectangles.Rectangle{Int64}((0,0),(1,1),Dict{Symbol,Any}())  julia   trans   =   Translation ( 10 , 10 )  Translation(10,10)  julia   trans   =   Rotation ( 90 \u00b0 )   \u2218   trans  AffineMap([0.0 -1.0; 1.0 0.0], [-10.0,10.0])  julia   trans ( r )  Devices.Polygons.Polygon{Float64}(Devices.Points.Point{Float64}[(-10.0,10.0),(-10.0,11.0),(-11.0,11.0),(-11.0,10.0)],Dict{Symbol,Any}())   #  CoordinateTransformations.compose     Function .  compose(trans1, trans2)\ntrans1 \u2218 trans2  Take two transformations and create a new transformation that is equivalent to successively applying  trans2  to the coordinate, and then  trans1 . By default will create a  ComposedTransformation , however this method can be overloaded for efficiency (e.g. two affine transformations naturally compose to a single affine transformation).  source  #  Devices.Points.Rotation     Function .  Rotation(\u0398)  Construct a rotation about the origin. Units accepted (no units \u21d2 radians).  source  #  CoordinateTransformations.Translation     Type .  Translation(v)  : AbstractAffineMap\nTranslation(dx, dy)       (2D)\nTranslation(dx, dy, dz)   (3D)  Construct the  Translation  transformation for translating Cartesian points by an offset  v = (dx, dy, ...)  source  #  Devices.Points.XReflection     Function .  XReflection()  Construct a reflection about the x-axis (y-coordinate changes sign).  Example:  julia   trans   =   XReflection ()  LinearMap([1 0; 0 -1])  julia   trans ( Point ( 1 , 1 ))  2-element Devices.Points.Point{Int64}:    1   -1   source  #  Devices.Points.YReflection     Function .  YReflection()  Construct a reflection about the y-axis (x-coordinate changes sign).  Example:  julia   trans   =   YReflection ()  LinearMap([-1 0; 0 1])  julia   trans ( Point ( 1 , 1 ))  2-element Devices.Points.Point{Int64}:   -1    1   source", 
            "title": "Affine transformations"
        }, 
        {
            "location": "/polygons/#clipping", 
            "text": "#  Devices.Polygons.clip     Function .  clip { S :Coordinate,   T :Coordinate } ( op :: Clipper . ClipType , \n     s :: AbstractPolygon { S } ,   c :: AbstractPolygon { T } ; \n     pfs :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd , \n     pfc :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd )   Using the  Clipper  library and the  Clipper.jl  wrapper, perform polygon clipping. The first argument must be one of the following types :   Clipper.ClipTypeDifference  Clipper.ClipTypeIntersection  Clipper.ClipTypeUnion  Clipper.ClipTypeXor   Note that these are types; you should not follow them with  () . The second and third arguments are  AbstractPolygon  objects. Keyword arguments  pfs  and  pfc  specify polygon fill rules (see the  Clipper  docs  for further information). These arguments may include:   Clipper.PolyFillTypeNegative  Clipper.PolyFillTypePositive  Clipper.PolyFillTypeEvenOdd  Clipper.PolyFillTypeNonZero   source  clip { S :AbstractPolygon,   T :AbstractPolygon } ( op :: Clipper . ClipType , \n     s :: AbstractVector { S } ,   c :: AbstractVector { T } ; \n     pfs :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd , \n     pfc :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd )   Perform polygon clipping. The first argument must be as listed above. The second and third arguments are arrays (vectors) of  AbstractPolygon s. Keyword arguments are explained above.  source  clip { T :Polygon } ( op :: Clipper . ClipType , \n     s :: AbstractVector { T } ,   c :: AbstractVector { T } ; \n     pfs :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd , \n     pfc :: Clipper . PolyFillType = Clipper . PolyFillTypeEvenOdd )   Perform polygon clipping. The first argument must be as listed above. The second and third arguments are identically-typed arrays (vectors) of  Polygon{T}  objects. Keyword arguments are explained above.  source", 
            "title": "Clipping"
        }, 
        {
            "location": "/polygons/#offsetting", 
            "text": "#  Devices.Polygons.offset     Function .  offset { S :Coordinate } ( s :: AbstractPolygon { S } ,   delta :: Coordinate ; \n     j :: Clipper . JoinType = Clipper . JoinTypeMiter , \n     e :: Clipper . EndType = Clipper . EndTypeClosedPolygon )   Using the  Clipper  library and the  Clipper.jl  wrapper, perform polygon offsetting.  The first argument should be an  AbstractPolygon . The second argument is how much to offset the polygon. Keyword arguments include a  join type :   Clipper.JoinTypeMiter  Clipper.JoinTypeRound  Clipper.JoinTypeSquare   and also an  end type :   Clipper.EndTypeClosedPolygon  Clipper.EndTypeClosedLine  Clipper.EndTypeOpenSquare  Clipper.EndTypeOpenRound  Clipper.EndTypeOpenButt   source  offset { S :AbstractPolygon } ( subject :: AbstractVector { S } ,   delta :: Coordinate ; \n     j :: Clipper . JoinType = Clipper . JoinTypeMiter , \n     e :: Clipper . EndType = Clipper . EndTypeClosedPolygon )   Perform polygon offsetting. The first argument is an array (vector) of  AbstractPolygon s. The second argument is how much to offset the polygon. Keyword arguments explained above.  source  offset { S :Polygon } ( s :: AbstractVector { S } ,   delta :: Coordinate ; \n     j :: Clipper . JoinType = Clipper . JoinTypeMiter , \n     e :: Clipper . EndType = Clipper . EndTypeClosedPolygon )   Perform polygon offsetting. The first argument is an array (vector) of  Polygon s. The second argument is how much to offset the polygon. Keyword arguments explained above.  source", 
            "title": "Offsetting"
        }, 
        {
            "location": "/polygons/#rectangle-api", 
            "text": "#  Devices.Rectangles.Rectangle     Type .  type Rectangle{T}  : AbstractPolygon{T}\n    ll::Point{T}\n    ur::Point{T}\n    properties::Dict{Symbol, Any}\n    Rectangle(ll,ur) = Rectangle(ll,ur,Dict{Symbol,Any}())\n    function Rectangle(a,b,props)\n        # Ensure ll is lower-left, ur is upper-right.\n        ll = Point(a. =b) .* a + Point(b. =a) .* b\n        ur = Point(a. =b) .* b + Point(b. =a) .* a\n        new(ll,ur,props)\n    end\nend  A rectangle, defined by opposing lower-left and upper-right corner coordinates. Lower-left and upper-right are guaranteed to be such by the inner constructor.  source  #  Devices.Rectangles.Rectangle     Method .  Rectangle ( ll :: Point ,   ur :: Point ;   kwargs ...)   Convenience constructor for  Rectangle  objects.  source  #  Devices.Rectangles.Rectangle     Method .  Rectangle(width, height, kwargs...)  Constructs  Rectangle  objects by specifying the width and height rather than the lower-left and upper-right corners.  The rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of  Rectangle{Int}  type, this would not be possible if either  width  or  height  were odd numbers. This definition ensures type stability in the constructor.  source  #  Devices.bounds     Method .  bounds(r::Rectangle)  No-op (just returns  r ).  source  #  Devices.center     Method .  center(r::Rectangle)  Returns a  Point  corresponding to the center of the rectangle.  source  #  Devices.centered     Method .  centered(r::Rectangle)  Centers a copy of  r , with promoted coordinates if necessary. This function will not throw an  InexactError() , even if  r  had integer coordinates.  source  #  Devices.centered!     Method .  centered!(r::Rectangle)  Centers a rectangle. Will throw an  InexactError()  if the rectangle cannot be centered with integer coordinates.  source  #  Devices.Rectangles.height     Method .  height(r::Rectangle)  Return the height of a rectangle.  source  #  Devices.Rectangles.isproper     Method .  isproper(r::Rectangle)  Returns  true  if the rectangle has a non-zero size. Otherwise, returns  false . Note that the upper-right and lower-left corners are enforced to be the  ur  and  ll  fields of a  Rectangle  by the inner constructor.  source  #  Base.minimum     Method .  minimum(itr)  Returns the smallest element in a collection.  julia   minimum ( - 20.5 : 10 )  -20.5  julia   minimum ([ 1 , 2 , 3 ])  1   source  #  Base.maximum     Method .  maximum(itr)  Returns the largest element in a collection.  julia   maximum ( - 20.5 : 10 )  9.5  julia   maximum ([ 1 , 2 , 3 ])  3   source  #  Devices.Polygons.points     Method .  points{T}(x::Rectangle{T})  Returns the array of  Point  objects defining the rectangle.  source  #  Devices.Rectangles.width     Method .  width(r::Rectangle)  Return the width of a rectangle.  source  #  Base.:+     Method .  +(r::Rectangle, p::Point)  Translate a rectangle by  p .  source", 
            "title": "Rectangle API"
        }, 
        {
            "location": "/polygons/#rectangle-styles", 
            "text": "#  Devices.Rectangles.Plain     Type .  immutable Plain  : Style end  Plain rectangle style. Use this if you are fond for the simpler times when rectangles were just rectangles.  source  #  Devices.Rectangles.Rounded     Type .  immutable Rounded{T :Coordinate}  : Style\n    r::T\nend  Rounded rectangle style. All corners are rounded off with a given radius  r . The bounding box of the unstyled rectangle should remain unaffected.  source  #  Devices.Rectangles.Undercut     Type .  immutable Undercut{T :Coordinate}  : Style\n    ucl::T\n    uct::T\n    ucr::T\n    ucb::T\nend  Undercut rectangles. In each direction around a rectangle (left, top, right, bottom) an undercut is rendered on a different layer.  source", 
            "title": "Rectangle styles"
        }, 
        {
            "location": "/polygons/#polygon-api", 
            "text": "#  Devices.Polygons.Polygon     Type .  type Polygon{T}  : AbstractPolygon{T}\n    p::Array{Point{T},1}\n    properties::Dict{Symbol, Any}\n    Polygon(x,y) = new(x,y)\n    Polygon(x) = new(x, Dict{Symbol, Any}())\nend  Polygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).  source  #  Devices.Polygons.Polygon     Method .  Polygon { T } ( parr :: AbstractArray { Point{T } , 1 } ;   kwargs ...)   Convenience constructor for a  Polygon{T}  object.  source  #  Devices.Polygons.Polygon     Method .  Polygon ( p0 :: Point ,   p1 :: Point ,   p2 :: Point ,   p3 :: Point ...;   kwargs ...)   Convenience constructor for a  Polygon{T}  object.  source  #  Devices.bounds     Method .  bounds(p::Polygon)  Return a bounding Rectangle with no properties for polygon  p .  source  #  Devices.bounds     Method .  bounds{T :AbstractPolygon}(parr::AbstractArray{T})  Return a bounding  Rectangle  with no properties for an array  parr  of  AbstractPolygon  objects.  source  #  Devices.bounds     Method .  bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon  objects.  source  #  Base.minimum     Method .  minimum(itr)  Returns the smallest element in a collection.  julia   minimum ( - 20.5 : 10 )  -20.5  julia   minimum ([ 1 , 2 , 3 ])  1   source  #  Base.maximum     Method .  maximum(itr)  Returns the largest element in a collection.  julia   maximum ( - 20.5 : 10 )  9.5  julia   maximum ([ 1 , 2 , 3 ])  3   source  #  Devices.Polygons.points     Method .  points(x::Polygon)  Returns the array of  Point  objects defining the polygon.  source", 
            "title": "Polygon API"
        }, 
        {
            "location": "/polygons/#polygon-styles", 
            "text": "#  Devices.Polygons.Plain     Type .  Plain polygon style.  source", 
            "title": "Polygon styles"
        }, 
        {
            "location": "/cells/", 
            "text": "Cells are used to logically group polygons or references to other cells into a single entity. They can contain references to other cells or arrays of other cells. They also store polygons. Here is the definition of a \nCell\n:\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nType\n.\n\n\ntype Cell{T\n:Coordinate}\n    name::String\n    elements::Vector{Polygon{T}}\n    refs::Vector{CellRef}\n    create::DateTime\n    Cell(x,y,z,t) = new(x, y, z, t)\n    Cell(x,y,z) = new(x, y, z, now())\n    Cell(x,y) = new(x, y, CellRef[], now())\n    Cell(x) = new(x, Polygon{T}[], CellRef[], now())\n    Cell() = begin\n        c = new()\n        c.elements = Polygon{T}[]\n        c.refs = CellRef[]\n        c.create = now()\n        c\n    end\nend\n\n\n\n\n\nA cell has a name and contains polygons and references to \nCellArray\n or \nCellReference\n objects. It also records the time of its own creation. As currently implemented it mirrors the notion of cells in GDS-II files.\n\n\nTo add elements, push them to \nelements\n field (or use \nrender!\n); to add references, push them to \nrefs\n field.\n\n\nsource\n\n\nThe type parameter of a \nCell{T}\n object is used in two ways:\n\n\n\n\nDetermine the units of the coordinates of all polygons in a cell, as well as origins and offset vectors of \nCellArray\ns and \nCellReference\ns.\n\n\nDetermine whether the cell will contain integer coordinates or floating-point coordinates. Currently, you cannot do a whole lot (particularly with regard to paths) if the cell has integer coordinates. However, they do have an inherent advantage because the coordinates are exact, and ultimately the GDS-II file represents shapes with integer coordinates. In the future, we intend to improve support for cells with integer coordinates.\n\n\n\n\nFor instance, \nCell{typeof(1.0u\"nm\")}\n specifies a cell where the database unit is \nnm\n and polygons may have \nFloat64\n-based coordinates (the type of \n1.0\n is \nFloat64\n). Note that \nCell{typeof(2.0u\"nm\")}\n does not mean the database unit is 2.0nm, because the returned type is the same. If that is intended, instead make a new unit such that one of that new unit is equal to 2nm. You can do this using the \n@unit\n macro in Unitful.\n\n\nFor most cases, if you want to use units, \nCell{typeof(1.0u\"nm\")}(\"my_cell_name\")\n is a good way to construct a cell which will ultimately have all coordinates rounded to the nearest \nnm\n when exported into GDS-II. You can add polygons with whatever length units you want to such a cell, and the coordinates will be converted automatically to \nnm\n. You can change \nnm\n to \npm\n or \nfm\n or whatever, but this will limit the pattern extent and probably doesn't make sense anyway.\n\n\nIf you don't want units, just construct the cell with a name only: \nCell(\"my_cell_name\")\n will return a \nCell{Float64}\n object. In this case too, the ultimate database resolution is \n1nm\n; until exporting the cell into a GDS-II file, the coordinates are interpreted to be in units of \n1\u03bcm\n. This behavior cannot be changed for cells without units.\n\n\n\n\nCell API\n\n\n    Cell(::AbstractString)\n    Cell{T\n:Real}(::AbstractString, ::AbstractArray{Devices.AbstractPolygon{T},1})\n    bounds{T\n:Devices.Coordinate}(::Cell{T})\n    center(::Cell)\n    name(::Cell)\n    Cells.dbscale{T}(::Cell{T})\n    Cells.dbscale(::Cell, ::Cell, ::Cell...)\n\n\n\n\n\n\n\nReferenced and arrayed cells\n\n\nCells can be arrayed or referenced within other cells for efficiency or to reduce display complexity.\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nType\n.\n\n\ntype CellArray{S,T} \n: CellRef{S,T}\n    cell::T\n    origin::Point{S}\n    deltacol::Point{S}\n    deltarow::Point{S}\n    col::Int\n    row::Int\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend\n\n\n\n\n\nArray of \ncell\n starting at \norigin\n with \nrow\n rows and \ncol\n columns, spanned by vectors \ndeltacol\n and \ndeltarow\n. Optional x-reflection \nxrefl\n, magnification factor \nmag\n, and rotation angle \nrot\n for the array as a whole. If an angle is given without units it is assumed to be in radians.\n\n\nThe type variable \nT\n is to avoid circular definitions with \nCell\n.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nMethod\n.\n\n\nCellArray\n{\nT\n:Coordinate\n}\n(\nx\n,\n \norigin\n::\nPoint\n{\nT\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConstruct a \nCellArray{T,typeof(x)}\n object.\n\n\nKeyword arguments specify the column vector, row vector, number of columns, number of rows, x-reflection, magnification factor, and rotation.\n\n\nSynonyms are accepted for these keywords:\n\n\n\n\nColumn vector \ndc::Point{T}\n: \n:deltacol\n, \n:dcol\n, \n:dc\n, \n:vcol\n, \n:colv\n, \n:colvec\n, \n:colvector\n, \n:columnv\n, \n:columnvec\n, \n:columnvector\n\n\nRow vector: \n:deltarow\n, \n:drow\n, \n:dr\n, \n:vrow\n, \n:rv\n, \n:rowvec\n, \n:rowvector\n\n\nNumber of columns: \n:nc\n, \n:numcols\n, \n:numcol\n, \n:ncols\n, \n:ncol\n\n\nNumber of rows: \n:nr\n, \n:numrows\n, \n:numrow\n, \n:nrows\n, \n:nrow\n\n\nX-reflection: \n:xrefl\n, \n:xreflection\n, \n:refl\n, \n:reflect\n, \n:xreflect\n, \n:xmirror\n, \n:mirror\n\n\nMagnification: \n:mag\n, \n:magnification\n, \n:magnify\n, \n:zoom\n, \n:scale\n\n\nRotation: \n:rot\n, \n:rotation\n, \n:rotate\n, \n:angle\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nMethod\n.\n\n\nCellArray\n{\nT\n:Coordinate\n}\n(\nx\n,\n \nc\n::\nRange\n{\nT\n}\n,\n \nr\n::\nRange\n{\nT\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConstruct a \nCellArray{T,typeof(x)}\n based on ranges (probably \nLinSpace\n or \nFloatRange\n). \nc\n specifies column coordinates and \nr\n for the rows. Pairs from \nc\n and \nr\n specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting \nCellArray\n's bounding box; some care is required.\n\n\nKeyword arguments specify x-reflection, magnification factor, and rotation, with synonyms allowed:\n\n\n\n\nX-reflection: \n:xrefl\n, \n:xreflection\n, \n:refl\n, \n:reflect\n, \n:xreflect\n, \n:xmirror\n, \n:mirror\n\n\nMagnification: \n:mag\n, \n:magnification\n, \n:magnify\n, \n:zoom\n, \n:scale\n\n\nRotation: \n:rot\n, \n:rotation\n, \n:rotate\n, \n:angle\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Cells.CellReference\n \n \nType\n.\n\n\ntype CellReference{S,T} \n: CellRef{S,T}\n    cell::T\n    origin::Point{S}\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend\n\n\n\n\n\nReference to a \ncell\n positioned at \norigin\n, with optional x-reflection \nxrefl\n, magnification factor \nmag\n, and rotation angle \nrot\n. If an angle is given without units it is assumed to be in radians.\n\n\nThe type variable \nT\n is to avoid circular definitions with \nCell\n.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.CellReference\n \n \nType\n.\n\n\nCellReference\n{\nT\n:Coordinate\n}\n(\nx\n,\n \ny\n::\nPoint\n{\nT\n}\n=\nPoint\n(\n0\n.,\n0\n.);\n \nkwargs\n...\n\n\n\n\n\n\nConvenience constructor for \nCellReference{typeof(x), T}\n.\n\n\nKeyword arguments can specify x-reflection, magnification, or rotation. Synonyms are accepted, in case you forget the \"correct keyword\"...\n\n\n\n\nX-reflection: \n:xrefl\n, \n:xreflection\n, \n:refl\n, \n:reflect\n, \n:xreflect\n, \n:xmirror\n, \n:mirror\n\n\nMagnification: \n:mag\n, \n:magnification\n, \n:magnify\n, \n:zoom\n, \n:scale\n\n\nRotation: \n:rot\n, \n:rotation\n, \n:rotate\n, \n:angle\n\n\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds\n(\nref\n::\nCellArray\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with properties specified by \nkwargs...\n around all objects in \nref\n. The bounding box respects reflection, rotation, and magnification specified by \nref\n.\n\n\nPlease do rewrite this method when feeling motivated... it is very inefficient.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds\n(\nref\n::\nCellReference\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with properties specified by \nkwargs...\n around all objects in \nref\n. The bounding box respects reflection, rotation, and magnification specified by \nref\n.\n\n\nsource\n\n\n#\n\n\nBase.copy\n \n \nMethod\n.\n\n\ncopy(x::CellReference)\n\n\n\n\n\nCreates a shallow copy of \nx\n (does not copy the referenced cell).\n\n\nsource\n\n\n#\n\n\nBase.copy\n \n \nMethod\n.\n\n\ncopy(x::CellArray)\n\n\n\n\n\nCreates a shallow copy of \nx\n (does not copy the arrayed cell).\n\n\nsource\n\n\n#\n\n\nDevices.Cells.name\n \n \nMethod\n.\n\n\nname(x::CellReference)\n\n\n\n\n\nReturns the name of the referenced cell.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.name\n \n \nMethod\n.\n\n\nname(x::CellArray)\n\n\n\n\n\nReturns the name of the arrayed cell.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.uniquename\n \n \nFunction\n.\n\n\nuniquename(str)\n\n\n\n\n\nGiven string input \nstr\n, generate a unique name that bears some resemblance to \nstr\n. Useful if programmatically making Cells and all of them will eventually be saved into a GDS-II file. The uniqueness is expected on a per-Julia session basis, so if you load an existing GDS-II file and try to save unique cells on top of that you may get an unlucky clash.\n\n\nsource\n\n\n\n\nResolving references\n\n\nSometimes it can be helpful to go between coordinate systems of cells and the cells they reference. This package provides methods to generate affine transforms to do this as easily as possible.\n\n\n#\n\n\nCoordinateTransformations.transform\n \n \nMethod\n.\n\n\ntransform(c::Cell, d::CellRef)\n\n\n\n\n\nGiven a Cell \nc\n containing \nCellReference\n or \nCellArray\n \nd\n in its tree of references, this function returns a \nCoordinateTransformations.AffineMap\n object that lets you translate from the coordinate system of \nd\n to the coordinate system of \nc\n.\n\n\nIf the \nsame exact\n \nCellReference\n or \nCellArray\n (as in \n===\n, same address in memory) is included multiple times in the tree of references, then the resulting transform will be based on the first time it is encountered. The tree is traversed one level at a time to find the reference (optimized for shallow references).\n\n\nExample: You want to translate (2.0,3.0) in the coordinate system of the referenced cell \nd\n to the coordinate system of \nc\n:\n\n\njulia\n trans = transform(c,d)\n\njulia\n trans(Point(2.0,3.0))\n\n\n\n\n\nsource\n\n\nIn some cases it may be desirable to resolve cell references or arrays into their corresponding polygons. This operation is called \"flattening.\"\n\n\n#\n\n\nDevices.Cells.flatten!\n \n \nFunction\n.\n\n\nflatten!(c::Cell)\n\n\n\n\n\nAll cell references and arrays are turned into polygons and added to cell \nc\n. The references and arrays are then removed. This \"flattening\" of the cell is recursive: references in referenced cells are flattened too. The modified cell is returned.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.flatten\n \n \nFunction\n.\n\n\nflatten{T\n:Coordinate}(c::Cell{T}, name=uniquename(\nflatten\n))\n\n\n\n\n\nAll cell references and arrays are resolved into polygons, recursively. Together with the polygons already in cell \nc\n, an array of polygons (type \nAbstractPolygon{T}\n) is returned. The cell \nc\n remains unmodified.\n\n\nsource\n\n\nflatten(c::CellReference, name=uniquename(\nflatten\n))\n\n\n\n\n\nCell reference \nc\n is resolved into polygons, recursively. An array of polygons (type \nAbstractPolygon\n) is returned. The cell reference \nc\n remains unmodified.\n\n\nsource\n\n\nflatten(c::CellArray, name=uniquename(\nflatten\n))\n\n\n\n\n\nCell array \nc\n is resolved into polygons, recursively. An array of polygons (type \nAbstractPolygon\n) is returned. The cell array \nc\n remains unmodified.\n\n\nsource\n\n\n\n\nMiscellaneous\n\n\nWhen saving cells to disk, keep in mind that cells should have unique names. We don't have an automatic renaming scheme implemented to avoid clashes. To help with this, we provide a function \nuniquename\n to generate unique names based on human-readable prefixes.\n\n\nWhen saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.\n\n\n#\n\n\nDevices.Cells.traverse!\n \n \nFunction\n.\n\n\ntraverse!(a::AbstractArray, c::Cell, level=1)\n\n\n\n\n\nGiven a cell, recursively traverse its references for other cells and add to array \na\n some tuples: \n(level, c)\n. \nlevel\n corresponds to how deep the cell was found, and \nc\n is the found cell.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.order!\n \n \nFunction\n.\n\n\norder!(a::AbstractArray)\n\n\n\n\n\nGiven an array of tuples like that coming out of \ntraverse!\n, we sort by the \nlevel\n, strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).\n\n\nFor performance reasons, this function modifies \na\n but what you want is the returned result array.\n\n\nsource", 
            "title": "Cells"
        }, 
        {
            "location": "/cells/#cell-api", 
            "text": "Cell(::AbstractString)\n    Cell{T :Real}(::AbstractString, ::AbstractArray{Devices.AbstractPolygon{T},1})\n    bounds{T :Devices.Coordinate}(::Cell{T})\n    center(::Cell)\n    name(::Cell)\n    Cells.dbscale{T}(::Cell{T})\n    Cells.dbscale(::Cell, ::Cell, ::Cell...)", 
            "title": "Cell API"
        }, 
        {
            "location": "/cells/#referenced-and-arrayed-cells", 
            "text": "Cells can be arrayed or referenced within other cells for efficiency or to reduce display complexity.  #  Devices.Cells.CellArray     Type .  type CellArray{S,T}  : CellRef{S,T}\n    cell::T\n    origin::Point{S}\n    deltacol::Point{S}\n    deltarow::Point{S}\n    col::Int\n    row::Int\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend  Array of  cell  starting at  origin  with  row  rows and  col  columns, spanned by vectors  deltacol  and  deltarow . Optional x-reflection  xrefl , magnification factor  mag , and rotation angle  rot  for the array as a whole. If an angle is given without units it is assumed to be in radians.  The type variable  T  is to avoid circular definitions with  Cell .  source  #  Devices.Cells.CellArray     Method .  CellArray { T :Coordinate } ( x ,   origin :: Point { T } ;   kwargs ...)   Construct a  CellArray{T,typeof(x)}  object.  Keyword arguments specify the column vector, row vector, number of columns, number of rows, x-reflection, magnification factor, and rotation.  Synonyms are accepted for these keywords:   Column vector  dc::Point{T} :  :deltacol ,  :dcol ,  :dc ,  :vcol ,  :colv ,  :colvec ,  :colvector ,  :columnv ,  :columnvec ,  :columnvector  Row vector:  :deltarow ,  :drow ,  :dr ,  :vrow ,  :rv ,  :rowvec ,  :rowvector  Number of columns:  :nc ,  :numcols ,  :numcol ,  :ncols ,  :ncol  Number of rows:  :nr ,  :numrows ,  :numrow ,  :nrows ,  :nrow  X-reflection:  :xrefl ,  :xreflection ,  :refl ,  :reflect ,  :xreflect ,  :xmirror ,  :mirror  Magnification:  :mag ,  :magnification ,  :magnify ,  :zoom ,  :scale  Rotation:  :rot ,  :rotation ,  :rotate ,  :angle   source  #  Devices.Cells.CellArray     Method .  CellArray { T :Coordinate } ( x ,   c :: Range { T } ,   r :: Range { T } ;   kwargs ...)   Construct a  CellArray{T,typeof(x)}  based on ranges (probably  LinSpace  or  FloatRange ).  c  specifies column coordinates and  r  for the rows. Pairs from  c  and  r  specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting  CellArray 's bounding box; some care is required.  Keyword arguments specify x-reflection, magnification factor, and rotation, with synonyms allowed:   X-reflection:  :xrefl ,  :xreflection ,  :refl ,  :reflect ,  :xreflect ,  :xmirror ,  :mirror  Magnification:  :mag ,  :magnification ,  :magnify ,  :zoom ,  :scale  Rotation:  :rot ,  :rotation ,  :rotate ,  :angle   source  #  Devices.Cells.CellReference     Type .  type CellReference{S,T}  : CellRef{S,T}\n    cell::T\n    origin::Point{S}\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend  Reference to a  cell  positioned at  origin , with optional x-reflection  xrefl , magnification factor  mag , and rotation angle  rot . If an angle is given without units it is assumed to be in radians.  The type variable  T  is to avoid circular definitions with  Cell .  source  #  Devices.Cells.CellReference     Type .  CellReference { T :Coordinate } ( x ,   y :: Point { T } = Point ( 0 ., 0 .);   kwargs ...   Convenience constructor for  CellReference{typeof(x), T} .  Keyword arguments can specify x-reflection, magnification, or rotation. Synonyms are accepted, in case you forget the \"correct keyword\"...   X-reflection:  :xrefl ,  :xreflection ,  :refl ,  :reflect ,  :xreflect ,  :xmirror ,  :mirror  Magnification:  :mag ,  :magnification ,  :magnify ,  :zoom ,  :scale  Rotation:  :rot ,  :rotation ,  :rotate ,  :angle   source  #  Devices.bounds     Method .  bounds ( ref :: CellArray ;   kwargs ...)   Returns a  Rectangle  bounding box with properties specified by  kwargs...  around all objects in  ref . The bounding box respects reflection, rotation, and magnification specified by  ref .  Please do rewrite this method when feeling motivated... it is very inefficient.  source  #  Devices.bounds     Method .  bounds ( ref :: CellReference ;   kwargs ...)   Returns a  Rectangle  bounding box with properties specified by  kwargs...  around all objects in  ref . The bounding box respects reflection, rotation, and magnification specified by  ref .  source  #  Base.copy     Method .  copy(x::CellReference)  Creates a shallow copy of  x  (does not copy the referenced cell).  source  #  Base.copy     Method .  copy(x::CellArray)  Creates a shallow copy of  x  (does not copy the arrayed cell).  source  #  Devices.Cells.name     Method .  name(x::CellReference)  Returns the name of the referenced cell.  source  #  Devices.Cells.name     Method .  name(x::CellArray)  Returns the name of the arrayed cell.  source  #  Devices.Cells.uniquename     Function .  uniquename(str)  Given string input  str , generate a unique name that bears some resemblance to  str . Useful if programmatically making Cells and all of them will eventually be saved into a GDS-II file. The uniqueness is expected on a per-Julia session basis, so if you load an existing GDS-II file and try to save unique cells on top of that you may get an unlucky clash.  source", 
            "title": "Referenced and arrayed cells"
        }, 
        {
            "location": "/cells/#resolving-references", 
            "text": "Sometimes it can be helpful to go between coordinate systems of cells and the cells they reference. This package provides methods to generate affine transforms to do this as easily as possible.  #  CoordinateTransformations.transform     Method .  transform(c::Cell, d::CellRef)  Given a Cell  c  containing  CellReference  or  CellArray   d  in its tree of references, this function returns a  CoordinateTransformations.AffineMap  object that lets you translate from the coordinate system of  d  to the coordinate system of  c .  If the  same exact   CellReference  or  CellArray  (as in  === , same address in memory) is included multiple times in the tree of references, then the resulting transform will be based on the first time it is encountered. The tree is traversed one level at a time to find the reference (optimized for shallow references).  Example: You want to translate (2.0,3.0) in the coordinate system of the referenced cell  d  to the coordinate system of  c :  julia  trans = transform(c,d)\n\njulia  trans(Point(2.0,3.0))  source  In some cases it may be desirable to resolve cell references or arrays into their corresponding polygons. This operation is called \"flattening.\"  #  Devices.Cells.flatten!     Function .  flatten!(c::Cell)  All cell references and arrays are turned into polygons and added to cell  c . The references and arrays are then removed. This \"flattening\" of the cell is recursive: references in referenced cells are flattened too. The modified cell is returned.  source  #  Devices.Cells.flatten     Function .  flatten{T :Coordinate}(c::Cell{T}, name=uniquename( flatten ))  All cell references and arrays are resolved into polygons, recursively. Together with the polygons already in cell  c , an array of polygons (type  AbstractPolygon{T} ) is returned. The cell  c  remains unmodified.  source  flatten(c::CellReference, name=uniquename( flatten ))  Cell reference  c  is resolved into polygons, recursively. An array of polygons (type  AbstractPolygon ) is returned. The cell reference  c  remains unmodified.  source  flatten(c::CellArray, name=uniquename( flatten ))  Cell array  c  is resolved into polygons, recursively. An array of polygons (type  AbstractPolygon ) is returned. The cell array  c  remains unmodified.  source", 
            "title": "Resolving references"
        }, 
        {
            "location": "/cells/#miscellaneous", 
            "text": "When saving cells to disk, keep in mind that cells should have unique names. We don't have an automatic renaming scheme implemented to avoid clashes. To help with this, we provide a function  uniquename  to generate unique names based on human-readable prefixes.  When saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.  #  Devices.Cells.traverse!     Function .  traverse!(a::AbstractArray, c::Cell, level=1)  Given a cell, recursively traverse its references for other cells and add to array  a  some tuples:  (level, c) .  level  corresponds to how deep the cell was found, and  c  is the found cell.  source  #  Devices.Cells.order!     Function .  order!(a::AbstractArray)  Given an array of tuples like that coming out of  traverse! , we sort by the  level , strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).  For performance reasons, this function modifies  a  but what you want is the returned result array.  source", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/paths/", 
            "text": "A \nPaths.Path\n is an ordered collection of \nPaths.Node\ns, each of which has a \nPaths.Segment\n and a \nPaths.Style\n. The nodes are linked to each other, so each node knows what the previous and next nodes are.\n\n\n\n\nSegments\n\n\nEach subtype of \nSegment\n can represent a class of parametric functions \nt-\nPoint(x(t),y(t))\n. By \"class\" we mean e.g. \nPaths.Straight\n or \nPaths.Turn\n, which are used frequently. Instances of these subtypes of \nSegment\n have some captured variables to specify a particular path in the plane. Instances of \nTurn\n, for example, will capture an initial and final angle, a radius, and an origin. All circular turns may be parameterized with these variables.\n\n\n\n\nNote\n\n\nThis package assumes that the parametric functions are implemented such that $\\sqrt{((dx/dt)^2 + (dy/dt)^2)} = 1$. In other words, \nt\n ranges from zero to the path length of the segment.\n\n\n\n\n\n\nStyles\n\n\nEach subtype of \nStyle\n describes how to render a segment. You can create the most common styles using the constructors \nPaths.Trace\n (a trace with some width) and \nPaths.CPW\n (a coplanar waveguide style).\n\n\nOne can implement new styles by writing methods for \nrender!\n that dispatch on different style types. In this way, the rendering code can be specialized for the task at hand, improving performance and shrinking generated file sizes (ideally).\n\n\n\n\nCorners\n\n\nSharp turns in a path can be accomplished with \nPaths.corner!\n. Sharp turns pose a challenge to the path abstraction in that they have zero length, and when rendered effectively take up some length of the neighboring segments. These details are automatically accounted for by tweaking segment lengths and other captured segment variables just before rendering a path.\n\n\n\n\nAttachments\n\n\nattach!\n is one of the most useful functions defined in this package.\n\n\nWhen you call \nattach!\n, you are defining a coordinate system local to somewhere along the target \nPath\n, saying that a \nCellReference\n should be placed at the origin of that coordinate system (or slightly away from it if you want the cell to be one one side of the path or the other). The local coordinate system will rotate as the path changes orientations. The origin of the \nCellReference\n corresponds how the referenced cell should be displaced with respect to the origin of the local coordinate system. This differs from the usual meaning of the origin of a \nCellReference\n, which is how the referenced cell should be displaced with respect to the origin of a containing \nCell\n.\n\n\nThe same \nCellReference\n can be attached to multiple points along multiple paths. If the cell reference is modified (e.g. rotation, origin, magnification) before rendering, the changes should be reflected at all attachment points. The attachment of the cell reference is not a perfect abstraction: a \nCellReference\n must ultimately live inside a \nCell\n, but an unrendered \nPath\n does not live inside any cell. If the path is modified further before rendering, the attachment points will follow the path modifications, moving the origins of the local coordinate systems. The origin fields of the cell references do not change as the path is modified.\n\n\nAttachments are implemented by introducing a \nPaths.DecoratedStyle\n, which is kind of a meta-\nStyle\n: it remembers where to attach \nCellReferences\n, but how the path itself is actually drawn is deferred to a different \nStyle\n object that it retains a reference to. One can repeat a \nDecoratedStyle\n with one attachment to achieve a periodic placement of \nCellReferences\n (like a \nCellArray\n, but along the path). Or, one long segment with a \nDecoratedStyle\n could have several attachments to achieve a similar effect.\n\n\nWhen a \nPath\n is rendered, it is turned into \nPolygons\n living in some \nCell\n. The attachments remain \nCellReferences\n, now living inside of a \nCell\n and not tied to an abstract path. The notion of local coordinate systems along the path no longer makes sense because the abstract path has been made concrete, and the polygons are living in the coordinate system of the containing cell. Each attachment to the former path now must have its origin referenced to the origin of the containing cell, not to local path coordinate systems. Additionally, the references may need to rotate according to how the path was locally oriented. As a result, even if the same \nCellReference\n was attached multiple times to a path, now we need distinct \nCellReference\n objects for each attachment, as well as for each time a corresponding \nDecoratedStyle\n is rendered.\n\n\nSuppose we want the ability to transform between coordinate systems, especially between the coordinate system of a referenced cell and the coordinate system of a parent cell. At first glance it would seem like we could simply define a transform function, taking the parent cell and the cell reference we are interested in. But how would we actually identify the particular cell reference we want? Looking in the tree of references for an attached \nCellReference\n will not work: distinct \nCellReferences\n needed to be made after the path was rendered, and so the particular \nCellReference\n object initially attached is not actually in the \nCell\n containing the rendered path.\n\n\nTo overcome this problem, we make searching for the appropriate \nCellReference\n easier. Suppose a path with attachments has been rendered to a \nCell\n, which is bound to symbol \naaa\n. A \nCellReference\n referring to a cell named \"bbb\" was attached twice. To recall the second attachment: \naaa[\"bbb\",2]\n (the index defaults to 1 if unspecified). We can go deeper if we want to refer to references inside that attachment: \naaa[\"bbb\",2][\"ccc\"]\n. In this manner, it is easy to find the right \nCellReference\n to use with \nCells.transform(::Cell, ::Cells.CellRef)\n.\n\n\n\n\nPath API\n\n\n\n\nPath construction\n\n\n#\n\n\nDevices.Paths.Path\n \n \nType\n.\n\n\ntype Path{T\n:Coordinate} \n: AbstractVector{Node{T}}\n    p0::Point{T}\n    \u03b10::typeof(0.0\u00b0)\n    style0::ContinuousStyle\n    nodes::Array{Node{T},1}\nend\n\n\n\n\n\nType for abstracting an arbitrary styled path in the plane. Iterating returns \nPaths.Node\n objects, essentially\n\n\nsource\n\n\n#\n\n\nDevices.Paths.Path\n \n \nMethod\n.\n\n\nPath\n(\np0\n::\nPoint\n=\nPoint\n(\n0\n.\n0\n,\n0\n.\n0\n);\n \n\u03b1\n0\n=\n0\n.\n0\n,\n \nstyle0\n::\nStyle\n=\nTrace\n(\n1\n.\n0\n))\n\n\nPath\n(\np0x\n::\nReal\n,\n \np0y\n::\nReal\n;\n \nkwargs\n...)\n\n\n\nPath\n{\nT\n:Length\n}\n(\np0\n::\nPoint\n{\nT\n}\n;\n \n\u03b1\n0\n=\n0\n.\n0\n,\n \nstyle0\n::\nStyle\n=\nTrace\n(\n1\n.\n0\n*\nunit\n(\nT\n)))\n\n\nPath\n{\nT\n:Length\n}\n(\np0x\n::\nT\n,\n \np0y\n::\nT\n;\n \nkwargs\n...)\n\n\nPath\n(\np0x\n::\nLength\n,\n \np0y\n::\nLength\n;\n \nkwargs\n...)\n\n\n\nPath\n(\nu\n::\nLengthUnits\n;\n \n\u03b1\n0\n=\n0\n.\n0\n,\n \nstyle0\n::\nStyle\n=\nTrace\n(\n1\n.\n0u\n))\n\n\n\n\n\n\nConvenience constructors for \nPath{T}\n object.\n\n\nsource\n\n\n\n\nPath interrogation\n\n\n#\n\n\nDevices.Paths.direction\n \n \nFunction\n.\n\n\ndirection(s, t)\n\n\n\n\n\nReturns the angle at which some function \nt-\nPoint(x(t),y(t))\n is pointing.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.pathlength\n \n \nFunction\n.\n\n\npathlength(p::Path)\npathlength{T}(array::AbstractArray{Node{T}})\npathlength{T\n:Segment}(array::AbstractArray{T})\npathlength(node::Node)\n\n\n\n\n\nPhysical length of a path. Note that \nlength\n will return the number of segments in a path, not the physical length of the path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.p0\n \n \nFunction\n.\n\n\np0{T}(s::Segment{T})\n\n\n\n\n\nReturn the first point in a segment (calculated).\n\n\nsource\n\n\np0(p::Path)\n\n\n\n\n\nFirst point of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.\u03b10\n \n \nFunction\n.\n\n\n\u03b10(s::Segment)\n\n\n\n\n\nReturn the first angle in a segment (calculated).\n\n\nsource\n\n\n\u03b10(p::Path)\n\n\n\n\n\nFirst angle of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.p1\n \n \nFunction\n.\n\n\np1{T}(s::Segment{T})\n\n\n\n\n\nReturn the last point in a segment (calculated).\n\n\nsource\n\n\np1(p::Path)\n\n\n\n\n\nLast point of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.\u03b11\n \n \nFunction\n.\n\n\n\u03b11(s::Segment)\n\n\n\n\n\nReturn the last angle in a segment (calculated).\n\n\nsource\n\n\n\u03b11(p::Path)\n\n\n\n\n\nLast angle of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.style0\n \n \nFunction\n.\n\n\nstyle0(p::Path)\n\n\n\n\n\nStyle of the first segment of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.style1\n \n \nFunction\n.\n\n\nstyle1(p::Path)\n\n\n\n\n\nStyle of the last segment of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.discretestyle1\n \n \nFunction\n.\n\n\ndiscretestyle1{T}(p::Path{T})\n\n\n\n\n\nReturns the last-used discrete style in the path. If one was not used, returns \nSimpleTraceCorner()\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.contstyle1\n \n \nFunction\n.\n\n\ncontstyle1(p::Path)\n\n\n\n\n\nReturns the last-used discrete style in the path. If one was not used, returns \np.style0\n.\n\n\nsource\n\n\n\n\nPath manipulation\n\n\n#\n\n\nDevices.Paths.setp0!\n \n \nFunction\n.\n\n\nsetp0!(s::Straight, p::Point)\n\n\n\n\n\nSet the p0 of a straight segment.\n\n\nsource\n\n\nsetp0!(s::Turn, p::Point)\n\n\n\n\n\nSet the p0 of a turn.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.set\u03b10!\n \n \nFunction\n.\n\n\nset\u03b10!(s::Straight, \u03b10\u2032)\n\n\n\n\n\nSet the angle of a straight segment.\n\n\nsource\n\n\nset\u03b10!(s::Turn, \u03b10\u2032)\n\n\n\n\n\nSet the starting angle of a turn.\n\n\nsource\n\n\n#\n\n\nBase.append!\n \n \nMethod\n.\n\n\nappend!(p::Path, p\u2032::Path)\n\n\n\n\n\nGiven paths \np\n and \np\u2032\n, path \np\u2032\n is appended to path \np\n. The p0 and initial angle of the first segment from path \np\u2032\n is modified to match the last point and last angle of path \np\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.adjust!\n \n \nFunction\n.\n\n\nadjust!(p::Path, n::Integer=1)\n\n\n\n\n\nAdjust a path's parametric functions starting from index \nn\n. Used internally whenever segments are inserted into the path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.attach!\n \n \nFunction\n.\n\n\nattach\n!(\np\n::\nPath\n,\n \nc\n::\nCellReference\n,\n \nt\n::\nCoordinate\n;\n\n    \ni\n::\nInteger\n=\nlength\n(\np\n),\n \nlocation\n::\nInteger\n=\n0\n)\n\n\nattach\n!(\np\n::\nPath\n,\n \nc\n::\nCellReference\n,\n \nt\n;\n\n    \ni\n::\nInteger\n=\nlength\n(\np\n),\n \nlocation\n=\nzeros\n(\nInt\n,\n \nlength\n(\nt\n)))\n\n\n\n\n\n\nAttach \nc\n along a path. The second method permits ranges or arrays of \nt\n and \nlocation\n to be specified (if the lengths do not match, \nlocation\n is cycled).\n\n\nBy default, the attachment(s) occur at \nt \u2208 [zero(pathlength(s)),pathlength(s)]\n along the most recent path segment \ns\n, but a different path segment index can be specified using \ni\n. The reference is oriented with zero rotation if the path is pointing at 0\u00b0, otherwise it is rotated with the path.\n\n\nThe origin of the cell reference tells the method where to place the cell \nwith respect to a coordinate system that rotates with the path\n. Suppose the path is a straight line with angle 0\u00b0. Then an origin of \nPoint(0.,10.)\n will put the cell at 10 above the path, or 10 to the left of the path if it turns left by 90\u00b0.\n\n\nThe \nlocation\n option is for convenience. If \nlocation == 0\n, nothing special happens. If \nlocation == -1\n, then the point of attachment for the reference is on the leftmost edge of the waveguide (the rendered polygons; the path itself has no width). Likewise if \nlocation == 1\n, the point of attachment is on the rightmost edge. This option does not automatically rotate the cell reference, apart from what is already done as described in the first paragraph. You can think of this option as setting a special origin for the coordinate system that rotates with the path. For instance, an origin for the cell reference of \nPoint(0.,10.)\n together with \nlocation == -1\n will put the cell at 10 above the edge of a rendered (finite width) path with angle 0\u00b0.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.corner!\n \n \nFunction\n.\n\n\ncorner!{T\n:Coordinate}(p::Path{T}, \u03b1, sty::DiscreteStyle=discretestyle1(p))\n\n\n\n\n\nAppend a sharp turn or \"corner\" to path \np\n with angle \n\u03b1\n.\n\n\nThe style chosen for this corner, if not specified, is the last \nDiscreteStyle\n used in the path, or \nSimpleTraceCorner\n if one has not been used yet.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.meander!\n \n \nFunction\n.\n\n\nmeander!{T\n:Real}(p::Path{T}, len, r, straightlen, \u03b1::Real)\n\n\n\n\n\nAlternate between going straight with length \nstraightlen\n and turning with radius \nr\n and angle \n\u03b1\n. Each turn goes the opposite direction of the previous. The total length is \nlen\n. Useful for making resonators.\n\n\nThe straight and turn segments are combined into a \nCompoundSegment\n and appended to the path \np\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.simplify\n \n \nFunction\n.\n\n\nsimplify(p::Path, inds::UnitRange=1:length(p))\n\n\n\n\n\nAt \ninds\n, segments of a path are turned into a \nCompoundSegment\n and styles of a path are turned into a \nCompoundStyle\n. The method returns a tuple, \n(segment, style)\n.\n\n\n\n\nIndexing the path becomes more sane when you can combine several path\n\n\n\n\nsegments into one logical element. A launcher would have several indices in a path unless you could simplify it.\n\n\n\n\nYou don't need to think hard about boundaries between straights and turns\n\n\n\n\nwhen you want a continuous styling of a very long path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.simplify!\n \n \nFunction\n.\n\n\nsimplify!(p::Path, inds::UnitRange=1:length(p))\n\n\n\n\n\nIn-place version of \nsimplify\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.straight!\n \n \nFunction\n.\n\n\nstraight!{T\n:Coordinate}(p::Path{T}, l::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))\n\n\n\n\n\nExtend a path \np\n straight by length \nl\n in the current direction. By default, we take the last continuous style in the path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.turn!\n \n \nFunction\n.\n\n\nturn!{T\n:Coordinate}(p::Path{T}, \u03b1, r::Coordinate, sty::Style=style1(p))\n\n\n\n\n\nTurn a path \np\n by angle \n\u03b1\n with a turning radius \nr\n in the current direction. Positive angle turns left.\n\n\nsource\n\n\nturn!{T\n:Coordinate}(p::Path{T}, s::String, r::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))\n\n\n\n\n\nTurn a path \np\n with direction coded by string \ns\n:\n\n\n\n\n\"l\": turn by \u03c0/2 radians (left)\n\n\n\"r\": turn by -\u03c0/2 radians (right)\n\n\n\"lrlrllrrll\": do those turns in that order\n\n\n\n\nBy default, we take the last continuous style in the path.\n\n\nsource\n\n\n\n\nNode API\n\n\n\n\nNode construction\n\n\n#\n\n\nDevices.Paths.Node\n \n \nType\n.\n\n\nNode{T}(a::Segment{T}, b::Style)\n\n\n\n\n\nCreate a node with segment \na\n and style \nb\n.\n\n\nsource\n\n\n\n\nNode methods\n\n\n#\n\n\nDevices.Paths.previous\n \n \nFunction\n.\n\n\nprevious(x::Node)\n\n\n\n\n\nReturn the node before \nx\n in a doubly linked list.\n\n\nsource\n\n\n#\n\n\nBase.next\n \n \nFunction\n.\n\n\nnext(iter, state) -\n item, state\n\n\n\n\n\nFor a given iterable object and iteration state, return the current item and the next iteration state.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.segment\n \n \nFunction\n.\n\n\nsegment(x::Node)\n\n\n\n\n\nReturn the segment associated with node \nx\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.style\n \n \nFunction\n.\n\n\nstyle(x::Node)\n\n\n\n\n\nReturn the style associated with node \nx\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.setsegment!\n \n \nFunction\n.\n\n\nsetsegment!(x::Node, s::Segment)\n\n\n\n\n\nSet the segment associated with node \nx\n to \ns\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.setstyle!\n \n \nFunction\n.\n\n\nsetstyle!(x::Node, s::Style)\n\n\n\n\n\nSet the style associated with node \nx\n to \ns\n.\n\n\nsource\n\n\n\n\nSegment API\n\n\n\n\nAbstract types\n\n\n#\n\n\nDevices.Paths.Segment\n \n \nType\n.\n\n\nabstract type Segment{T\n:Coordinate} end\n\n\n\n\n\nPath segment in the plane. All Segment objects should have the implement the following methods:\n\n\n\n\npathlength\n\n\np0\n\n\n\u03b10\n\n\nsetp0!\n\n\nset\u03b10!\n\n\n\u03b11\n\n\n\n\nsource\n\n\n\n\nConcrete types\n\n\n#\n\n\nDevices.Paths.Straight\n \n \nType\n.\n\n\ntype Straight{T} \n: ContinuousSegment{T}\n    l::T\n    p0::Point{T}\n    \u03b10::typeof(0.0\u00b0)\nend\n\n\n\n\n\nA straight line segment is parameterized by its length. It begins at a point \np0\n with initial angle \n\u03b10\n.\n\n\nThe parametric function describing the line segment is given by \nt -\n p0 + Point(t*cos(\u03b1),t*sin(\u03b1))\n where \nt\n is a length from 0 to \nl\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.Turn\n \n \nType\n.\n\n\ntype Turn{T} \n: ContinuousSegment{T}\n    \u03b1::typeof(1.0\u00b0)\n    r::T\n    p0::Point{T}\n    \u03b10::typeof(1.0\u00b0)\nend\n\n\n\n\n\nA circular turn is parameterized by the turn angle \n\u03b1\n and turning radius \nr\n. It begins at a point \np0\n with initial angle \n\u03b10\n.\n\n\nThe center of the circle is given by:\n\n\ncen = p0 + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the turn is given by:\n\n\nt -\n cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))\n\n\nsource\n\n\n#\n\n\nDevices.Paths.Corner\n \n \nType\n.\n\n\ntype Corner{T} \n: DiscreteSegment{T}\n    \u03b1::typeof(1.0\u00b0)\n    p0::Point{T}\n    \u03b10::typeof(1.0\u00b0)\n    extent::T\n    Corner(a) = new(a, Point(zero(T),zero(T)), 0.0\u00b0, zero(T))\n    Corner(a,b,c,d) = new(a,b,c,d)\nend\n\n\n\n\n\nA corner, or sudden kink in a path. The only parameter is the angle \n\u03b1\n of the kink. The kink begins at a point \np0\n with initial angle \n\u03b10\n. It will also end at \np0\n, since the corner has zero path length. However, during rendering, neighboring segments will be tweaked slightly so that the rendered path is properly centered about the path function (the rendered corner has a finite width).\n\n\nsource\n\n\n#\n\n\nDevices.Paths.CompoundSegment\n \n \nType\n.\n\n\ntype CompoundSegment{T} \n: ContinuousSegment{T}\n    segments::Vector{Segment{T}}\n    f::Function\n\n    CompoundSegment(segments) = begin\n        if any(x-\nisa(x,Corner), segments)\n            error(\ncannot have corners in a `CompoundSegment`. You may have \n,\n                \ntried to simplify a path containing `Corner` objects.\n)\n        else\n            s = new(deepcopy(Array(segments)))\n            s.f = param(s.segments)\n            s\n        end\n    end\nend\n\n\n\n\n\nConsider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes. The array of segments given to the constructor is copied and retained by the compound segment.\n\n\nNote that \nCorner\ns introduce a discontinuity in the derivative of the path function, and are not allowed in a \nCompoundSegment\n.\n\n\nsource\n\n\n\n\nStyle API\n\n\n\n\nConstructors and methods\n\n\n#\n\n\nDevices.Paths.Trace\n \n \nType\n.\n\n\nTrace(width::Coordinate)\nTrace(width)\n\n\n\n\n\nConstructor for Trace styles. Automatically chooses \nSimpleTrace\n or \nGeneralTrace\n as appropriate.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.CPW\n \n \nType\n.\n\n\nCPW(trace::Coordinate, gap::Coordinate)\nCPW(trace, gap::Coordinate)\nCPW(trace::Coordinate, gap)\nCPW(trace, gap)\n\n\n\n\n\nConstructor for CPW styles. Automatically chooses \nSimpleCPW\n or \nGeneralCPW\n as appropriate.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.undecorated\n \n \nFunction\n.\n\n\nundecorated(s::DecoratedStyle)\nundecorated(s::Style)\n\n\n\n\n\nReturns the underlying, undecorated style if decorated; otherwise just return the style.\n\n\nsource\n\n\n\n\nAbstract types\n\n\n#\n\n\nDevices.Paths.Style\n \n \nType\n.\n\n\nabstract Style{T\n:FloatCoordinate}\n\n\n\n\n\nHow to render a given path segment. All styles should implement the following methods:\n\n\n\n\nextent\n\n\nwidth\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Paths.ContinuousStyle\n \n \nType\n.\n\n\nabstract type ContinuousStyle \n: Style end\n\n\n\n\n\nAny style that applies to segments which have non-zero path length.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.DiscreteStyle\n \n \nType\n.\n\n\nabstract type DiscreteStyle \n: Style end\n\n\n\n\n\nAny style that applies to segments which have zero path length.\n\n\nsource\n\n\n\n\nConcrete types\n\n\n#\n\n\nDevices.Paths.SimpleTrace\n \n \nType\n.\n\n\nimmutable SimpleTrace{T\n:Coordinate} \n: Trace\n    width::T\nend\n\n\n\n\n\nA single trace with fixed width as a function of path length.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.GeneralTrace\n \n \nType\n.\n\n\nimmutable GeneralTrace{T} \n: Trace\n    width::T\nend\n\n\n\n\n\nA single trace with variable width as a function of path length. \nwidth\n is callable.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.SimpleCPW\n \n \nType\n.\n\n\nimmutable SimpleCPW{T\n:Coordinate} \n: CPW\n    trace::T\n    gap::T\nend\n\n\n\n\n\nA CPW with fixed trace and gap as a function of path length.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.GeneralCPW\n \n \nType\n.\n\n\nimmutable GeneralCPW{S,T} \n: CPW\n    trace::S\n    gap::T\nend\n\n\n\n\n\nA CPW with variable trace and gap as a function of path length. \ntrace\n and \ngap\n are callable.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.CompoundStyle\n \n \nType\n.\n\n\ntype CompoundStyle \n: ContinuousStyle\n    styles::Vector{Style}\n    grid::Vector{Float64}\n    f::Function\nend\n\n\n\n\n\nCombines styles together, typically for use with a \nCompoundSegment\n.\n\n\n\n\nstyles\n: Array of styles making up the object. This is shallow-copied\n\n\n\n\nby the outer constructor.\n\n\n\n\ngrid\n: An array of \nt\n values needed for rendering the parameteric path.\n\n\nf\n: returns tuple of style index and the \nt\n to use for that\n\n\n\n\nstyle's parametric function.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.DecoratedStyle\n \n \nType\n.\n\n\ntype DecoratedStyle{T\n:FloatCoordinate} \n: ContinuousStyle\n    s::Style\n    ts::Array{Float64,1}\n    dirs::Array{Int,1}\n    refs::Array{CellReference,1}\nend\n\n\n\n\n\nStyle with decorations, like structures periodically repeated along the path, etc.\n\n\nsource", 
            "title": "Paths"
        }, 
        {
            "location": "/paths/#segments", 
            "text": "Each subtype of  Segment  can represent a class of parametric functions  t- Point(x(t),y(t)) . By \"class\" we mean e.g.  Paths.Straight  or  Paths.Turn , which are used frequently. Instances of these subtypes of  Segment  have some captured variables to specify a particular path in the plane. Instances of  Turn , for example, will capture an initial and final angle, a radius, and an origin. All circular turns may be parameterized with these variables.   Note  This package assumes that the parametric functions are implemented such that $\\sqrt{((dx/dt)^2 + (dy/dt)^2)} = 1$. In other words,  t  ranges from zero to the path length of the segment.", 
            "title": "Segments"
        }, 
        {
            "location": "/paths/#styles", 
            "text": "Each subtype of  Style  describes how to render a segment. You can create the most common styles using the constructors  Paths.Trace  (a trace with some width) and  Paths.CPW  (a coplanar waveguide style).  One can implement new styles by writing methods for  render!  that dispatch on different style types. In this way, the rendering code can be specialized for the task at hand, improving performance and shrinking generated file sizes (ideally).", 
            "title": "Styles"
        }, 
        {
            "location": "/paths/#corners", 
            "text": "Sharp turns in a path can be accomplished with  Paths.corner! . Sharp turns pose a challenge to the path abstraction in that they have zero length, and when rendered effectively take up some length of the neighboring segments. These details are automatically accounted for by tweaking segment lengths and other captured segment variables just before rendering a path.", 
            "title": "Corners"
        }, 
        {
            "location": "/paths/#attachments", 
            "text": "attach!  is one of the most useful functions defined in this package.  When you call  attach! , you are defining a coordinate system local to somewhere along the target  Path , saying that a  CellReference  should be placed at the origin of that coordinate system (or slightly away from it if you want the cell to be one one side of the path or the other). The local coordinate system will rotate as the path changes orientations. The origin of the  CellReference  corresponds how the referenced cell should be displaced with respect to the origin of the local coordinate system. This differs from the usual meaning of the origin of a  CellReference , which is how the referenced cell should be displaced with respect to the origin of a containing  Cell .  The same  CellReference  can be attached to multiple points along multiple paths. If the cell reference is modified (e.g. rotation, origin, magnification) before rendering, the changes should be reflected at all attachment points. The attachment of the cell reference is not a perfect abstraction: a  CellReference  must ultimately live inside a  Cell , but an unrendered  Path  does not live inside any cell. If the path is modified further before rendering, the attachment points will follow the path modifications, moving the origins of the local coordinate systems. The origin fields of the cell references do not change as the path is modified.  Attachments are implemented by introducing a  Paths.DecoratedStyle , which is kind of a meta- Style : it remembers where to attach  CellReferences , but how the path itself is actually drawn is deferred to a different  Style  object that it retains a reference to. One can repeat a  DecoratedStyle  with one attachment to achieve a periodic placement of  CellReferences  (like a  CellArray , but along the path). Or, one long segment with a  DecoratedStyle  could have several attachments to achieve a similar effect.  When a  Path  is rendered, it is turned into  Polygons  living in some  Cell . The attachments remain  CellReferences , now living inside of a  Cell  and not tied to an abstract path. The notion of local coordinate systems along the path no longer makes sense because the abstract path has been made concrete, and the polygons are living in the coordinate system of the containing cell. Each attachment to the former path now must have its origin referenced to the origin of the containing cell, not to local path coordinate systems. Additionally, the references may need to rotate according to how the path was locally oriented. As a result, even if the same  CellReference  was attached multiple times to a path, now we need distinct  CellReference  objects for each attachment, as well as for each time a corresponding  DecoratedStyle  is rendered.  Suppose we want the ability to transform between coordinate systems, especially between the coordinate system of a referenced cell and the coordinate system of a parent cell. At first glance it would seem like we could simply define a transform function, taking the parent cell and the cell reference we are interested in. But how would we actually identify the particular cell reference we want? Looking in the tree of references for an attached  CellReference  will not work: distinct  CellReferences  needed to be made after the path was rendered, and so the particular  CellReference  object initially attached is not actually in the  Cell  containing the rendered path.  To overcome this problem, we make searching for the appropriate  CellReference  easier. Suppose a path with attachments has been rendered to a  Cell , which is bound to symbol  aaa . A  CellReference  referring to a cell named \"bbb\" was attached twice. To recall the second attachment:  aaa[\"bbb\",2]  (the index defaults to 1 if unspecified). We can go deeper if we want to refer to references inside that attachment:  aaa[\"bbb\",2][\"ccc\"] . In this manner, it is easy to find the right  CellReference  to use with  Cells.transform(::Cell, ::Cells.CellRef) .", 
            "title": "Attachments"
        }, 
        {
            "location": "/paths/#path-api", 
            "text": "", 
            "title": "Path API"
        }, 
        {
            "location": "/paths/#path-construction", 
            "text": "#  Devices.Paths.Path     Type .  type Path{T :Coordinate}  : AbstractVector{Node{T}}\n    p0::Point{T}\n    \u03b10::typeof(0.0\u00b0)\n    style0::ContinuousStyle\n    nodes::Array{Node{T},1}\nend  Type for abstracting an arbitrary styled path in the plane. Iterating returns  Paths.Node  objects, essentially  source  #  Devices.Paths.Path     Method .  Path ( p0 :: Point = Point ( 0 . 0 , 0 . 0 );   \u03b1 0 = 0 . 0 ,   style0 :: Style = Trace ( 1 . 0 ))  Path ( p0x :: Real ,   p0y :: Real ;   kwargs ...)  Path { T :Length } ( p0 :: Point { T } ;   \u03b1 0 = 0 . 0 ,   style0 :: Style = Trace ( 1 . 0 * unit ( T )))  Path { T :Length } ( p0x :: T ,   p0y :: T ;   kwargs ...)  Path ( p0x :: Length ,   p0y :: Length ;   kwargs ...)  Path ( u :: LengthUnits ;   \u03b1 0 = 0 . 0 ,   style0 :: Style = Trace ( 1 . 0u ))   Convenience constructors for  Path{T}  object.  source", 
            "title": "Path construction"
        }, 
        {
            "location": "/paths/#path-interrogation", 
            "text": "#  Devices.Paths.direction     Function .  direction(s, t)  Returns the angle at which some function  t- Point(x(t),y(t))  is pointing.  source  #  Devices.Paths.pathlength     Function .  pathlength(p::Path)\npathlength{T}(array::AbstractArray{Node{T}})\npathlength{T :Segment}(array::AbstractArray{T})\npathlength(node::Node)  Physical length of a path. Note that  length  will return the number of segments in a path, not the physical length of the path.  source  #  Devices.Paths.p0     Function .  p0{T}(s::Segment{T})  Return the first point in a segment (calculated).  source  p0(p::Path)  First point of a path.  source  #  Devices.Paths.\u03b10     Function .  \u03b10(s::Segment)  Return the first angle in a segment (calculated).  source  \u03b10(p::Path)  First angle of a path.  source  #  Devices.Paths.p1     Function .  p1{T}(s::Segment{T})  Return the last point in a segment (calculated).  source  p1(p::Path)  Last point of a path.  source  #  Devices.Paths.\u03b11     Function .  \u03b11(s::Segment)  Return the last angle in a segment (calculated).  source  \u03b11(p::Path)  Last angle of a path.  source  #  Devices.Paths.style0     Function .  style0(p::Path)  Style of the first segment of a path.  source  #  Devices.Paths.style1     Function .  style1(p::Path)  Style of the last segment of a path.  source  #  Devices.Paths.discretestyle1     Function .  discretestyle1{T}(p::Path{T})  Returns the last-used discrete style in the path. If one was not used, returns  SimpleTraceCorner() .  source  #  Devices.Paths.contstyle1     Function .  contstyle1(p::Path)  Returns the last-used discrete style in the path. If one was not used, returns  p.style0 .  source", 
            "title": "Path interrogation"
        }, 
        {
            "location": "/paths/#path-manipulation", 
            "text": "#  Devices.Paths.setp0!     Function .  setp0!(s::Straight, p::Point)  Set the p0 of a straight segment.  source  setp0!(s::Turn, p::Point)  Set the p0 of a turn.  source  #  Devices.Paths.set\u03b10!     Function .  set\u03b10!(s::Straight, \u03b10\u2032)  Set the angle of a straight segment.  source  set\u03b10!(s::Turn, \u03b10\u2032)  Set the starting angle of a turn.  source  #  Base.append!     Method .  append!(p::Path, p\u2032::Path)  Given paths  p  and  p\u2032 , path  p\u2032  is appended to path  p . The p0 and initial angle of the first segment from path  p\u2032  is modified to match the last point and last angle of path  p .  source  #  Devices.Paths.adjust!     Function .  adjust!(p::Path, n::Integer=1)  Adjust a path's parametric functions starting from index  n . Used internally whenever segments are inserted into the path.  source  #  Devices.Paths.attach!     Function .  attach !( p :: Path ,   c :: CellReference ,   t :: Coordinate ; \n     i :: Integer = length ( p ),   location :: Integer = 0 )  attach !( p :: Path ,   c :: CellReference ,   t ; \n     i :: Integer = length ( p ),   location = zeros ( Int ,   length ( t )))   Attach  c  along a path. The second method permits ranges or arrays of  t  and  location  to be specified (if the lengths do not match,  location  is cycled).  By default, the attachment(s) occur at  t \u2208 [zero(pathlength(s)),pathlength(s)]  along the most recent path segment  s , but a different path segment index can be specified using  i . The reference is oriented with zero rotation if the path is pointing at 0\u00b0, otherwise it is rotated with the path.  The origin of the cell reference tells the method where to place the cell  with respect to a coordinate system that rotates with the path . Suppose the path is a straight line with angle 0\u00b0. Then an origin of  Point(0.,10.)  will put the cell at 10 above the path, or 10 to the left of the path if it turns left by 90\u00b0.  The  location  option is for convenience. If  location == 0 , nothing special happens. If  location == -1 , then the point of attachment for the reference is on the leftmost edge of the waveguide (the rendered polygons; the path itself has no width). Likewise if  location == 1 , the point of attachment is on the rightmost edge. This option does not automatically rotate the cell reference, apart from what is already done as described in the first paragraph. You can think of this option as setting a special origin for the coordinate system that rotates with the path. For instance, an origin for the cell reference of  Point(0.,10.)  together with  location == -1  will put the cell at 10 above the edge of a rendered (finite width) path with angle 0\u00b0.  source  #  Devices.Paths.corner!     Function .  corner!{T :Coordinate}(p::Path{T}, \u03b1, sty::DiscreteStyle=discretestyle1(p))  Append a sharp turn or \"corner\" to path  p  with angle  \u03b1 .  The style chosen for this corner, if not specified, is the last  DiscreteStyle  used in the path, or  SimpleTraceCorner  if one has not been used yet.  source  #  Devices.Paths.meander!     Function .  meander!{T :Real}(p::Path{T}, len, r, straightlen, \u03b1::Real)  Alternate between going straight with length  straightlen  and turning with radius  r  and angle  \u03b1 . Each turn goes the opposite direction of the previous. The total length is  len . Useful for making resonators.  The straight and turn segments are combined into a  CompoundSegment  and appended to the path  p .  source  #  Devices.Paths.simplify     Function .  simplify(p::Path, inds::UnitRange=1:length(p))  At  inds , segments of a path are turned into a  CompoundSegment  and styles of a path are turned into a  CompoundStyle . The method returns a tuple,  (segment, style) .   Indexing the path becomes more sane when you can combine several path   segments into one logical element. A launcher would have several indices in a path unless you could simplify it.   You don't need to think hard about boundaries between straights and turns   when you want a continuous styling of a very long path.  source  #  Devices.Paths.simplify!     Function .  simplify!(p::Path, inds::UnitRange=1:length(p))  In-place version of  simplify .  source  #  Devices.Paths.straight!     Function .  straight!{T :Coordinate}(p::Path{T}, l::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))  Extend a path  p  straight by length  l  in the current direction. By default, we take the last continuous style in the path.  source  #  Devices.Paths.turn!     Function .  turn!{T :Coordinate}(p::Path{T}, \u03b1, r::Coordinate, sty::Style=style1(p))  Turn a path  p  by angle  \u03b1  with a turning radius  r  in the current direction. Positive angle turns left.  source  turn!{T :Coordinate}(p::Path{T}, s::String, r::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))  Turn a path  p  with direction coded by string  s :   \"l\": turn by \u03c0/2 radians (left)  \"r\": turn by -\u03c0/2 radians (right)  \"lrlrllrrll\": do those turns in that order   By default, we take the last continuous style in the path.  source", 
            "title": "Path manipulation"
        }, 
        {
            "location": "/paths/#node-api", 
            "text": "", 
            "title": "Node API"
        }, 
        {
            "location": "/paths/#node-construction", 
            "text": "#  Devices.Paths.Node     Type .  Node{T}(a::Segment{T}, b::Style)  Create a node with segment  a  and style  b .  source", 
            "title": "Node construction"
        }, 
        {
            "location": "/paths/#node-methods", 
            "text": "#  Devices.Paths.previous     Function .  previous(x::Node)  Return the node before  x  in a doubly linked list.  source  #  Base.next     Function .  next(iter, state) -  item, state  For a given iterable object and iteration state, return the current item and the next iteration state.  source  #  Devices.Paths.segment     Function .  segment(x::Node)  Return the segment associated with node  x .  source  #  Devices.Paths.style     Function .  style(x::Node)  Return the style associated with node  x .  source  #  Devices.Paths.setsegment!     Function .  setsegment!(x::Node, s::Segment)  Set the segment associated with node  x  to  s .  source  #  Devices.Paths.setstyle!     Function .  setstyle!(x::Node, s::Style)  Set the style associated with node  x  to  s .  source", 
            "title": "Node methods"
        }, 
        {
            "location": "/paths/#segment-api", 
            "text": "", 
            "title": "Segment API"
        }, 
        {
            "location": "/paths/#abstract-types", 
            "text": "#  Devices.Paths.Segment     Type .  abstract type Segment{T :Coordinate} end  Path segment in the plane. All Segment objects should have the implement the following methods:   pathlength  p0  \u03b10  setp0!  set\u03b10!  \u03b11   source", 
            "title": "Abstract types"
        }, 
        {
            "location": "/paths/#concrete-types", 
            "text": "#  Devices.Paths.Straight     Type .  type Straight{T}  : ContinuousSegment{T}\n    l::T\n    p0::Point{T}\n    \u03b10::typeof(0.0\u00b0)\nend  A straight line segment is parameterized by its length. It begins at a point  p0  with initial angle  \u03b10 .  The parametric function describing the line segment is given by  t -  p0 + Point(t*cos(\u03b1),t*sin(\u03b1))  where  t  is a length from 0 to  l .  source  #  Devices.Paths.Turn     Type .  type Turn{T}  : ContinuousSegment{T}\n    \u03b1::typeof(1.0\u00b0)\n    r::T\n    p0::Point{T}\n    \u03b10::typeof(1.0\u00b0)\nend  A circular turn is parameterized by the turn angle  \u03b1  and turning radius  r . It begins at a point  p0  with initial angle  \u03b10 .  The center of the circle is given by:  cen = p0 + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))  The parametric function over  t \u2208 [0,1]  describing the turn is given by:  t -  cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))  source  #  Devices.Paths.Corner     Type .  type Corner{T}  : DiscreteSegment{T}\n    \u03b1::typeof(1.0\u00b0)\n    p0::Point{T}\n    \u03b10::typeof(1.0\u00b0)\n    extent::T\n    Corner(a) = new(a, Point(zero(T),zero(T)), 0.0\u00b0, zero(T))\n    Corner(a,b,c,d) = new(a,b,c,d)\nend  A corner, or sudden kink in a path. The only parameter is the angle  \u03b1  of the kink. The kink begins at a point  p0  with initial angle  \u03b10 . It will also end at  p0 , since the corner has zero path length. However, during rendering, neighboring segments will be tweaked slightly so that the rendered path is properly centered about the path function (the rendered corner has a finite width).  source  #  Devices.Paths.CompoundSegment     Type .  type CompoundSegment{T}  : ContinuousSegment{T}\n    segments::Vector{Segment{T}}\n    f::Function\n\n    CompoundSegment(segments) = begin\n        if any(x- isa(x,Corner), segments)\n            error( cannot have corners in a `CompoundSegment`. You may have  ,\n                 tried to simplify a path containing `Corner` objects. )\n        else\n            s = new(deepcopy(Array(segments)))\n            s.f = param(s.segments)\n            s\n        end\n    end\nend  Consider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes. The array of segments given to the constructor is copied and retained by the compound segment.  Note that  Corner s introduce a discontinuity in the derivative of the path function, and are not allowed in a  CompoundSegment .  source", 
            "title": "Concrete types"
        }, 
        {
            "location": "/paths/#style-api", 
            "text": "", 
            "title": "Style API"
        }, 
        {
            "location": "/paths/#constructors-and-methods", 
            "text": "#  Devices.Paths.Trace     Type .  Trace(width::Coordinate)\nTrace(width)  Constructor for Trace styles. Automatically chooses  SimpleTrace  or  GeneralTrace  as appropriate.  source  #  Devices.Paths.CPW     Type .  CPW(trace::Coordinate, gap::Coordinate)\nCPW(trace, gap::Coordinate)\nCPW(trace::Coordinate, gap)\nCPW(trace, gap)  Constructor for CPW styles. Automatically chooses  SimpleCPW  or  GeneralCPW  as appropriate.  source  #  Devices.Paths.undecorated     Function .  undecorated(s::DecoratedStyle)\nundecorated(s::Style)  Returns the underlying, undecorated style if decorated; otherwise just return the style.  source", 
            "title": "Constructors and methods"
        }, 
        {
            "location": "/paths/#abstract-types_1", 
            "text": "#  Devices.Paths.Style     Type .  abstract Style{T :FloatCoordinate}  How to render a given path segment. All styles should implement the following methods:   extent  width   source  #  Devices.Paths.ContinuousStyle     Type .  abstract type ContinuousStyle  : Style end  Any style that applies to segments which have non-zero path length.  source  #  Devices.Paths.DiscreteStyle     Type .  abstract type DiscreteStyle  : Style end  Any style that applies to segments which have zero path length.  source", 
            "title": "Abstract types"
        }, 
        {
            "location": "/paths/#concrete-types_1", 
            "text": "#  Devices.Paths.SimpleTrace     Type .  immutable SimpleTrace{T :Coordinate}  : Trace\n    width::T\nend  A single trace with fixed width as a function of path length.  source  #  Devices.Paths.GeneralTrace     Type .  immutable GeneralTrace{T}  : Trace\n    width::T\nend  A single trace with variable width as a function of path length.  width  is callable.  source  #  Devices.Paths.SimpleCPW     Type .  immutable SimpleCPW{T :Coordinate}  : CPW\n    trace::T\n    gap::T\nend  A CPW with fixed trace and gap as a function of path length.  source  #  Devices.Paths.GeneralCPW     Type .  immutable GeneralCPW{S,T}  : CPW\n    trace::S\n    gap::T\nend  A CPW with variable trace and gap as a function of path length.  trace  and  gap  are callable.  source  #  Devices.Paths.CompoundStyle     Type .  type CompoundStyle  : ContinuousStyle\n    styles::Vector{Style}\n    grid::Vector{Float64}\n    f::Function\nend  Combines styles together, typically for use with a  CompoundSegment .   styles : Array of styles making up the object. This is shallow-copied   by the outer constructor.   grid : An array of  t  values needed for rendering the parameteric path.  f : returns tuple of style index and the  t  to use for that   style's parametric function.  source  #  Devices.Paths.DecoratedStyle     Type .  type DecoratedStyle{T :FloatCoordinate}  : ContinuousStyle\n    s::Style\n    ts::Array{Float64,1}\n    dirs::Array{Int,1}\n    refs::Array{CellReference,1}\nend  Style with decorations, like structures periodically repeated along the path, etc.  source", 
            "title": "Concrete types"
        }, 
        {
            "location": "/tags/", 
            "text": "#\n\n\nDevices.Tags.checkerboard!\n \n \nFunction\n.\n\n\ncheckerboard\n!\n{\nT\n}\n(\nc\n::\nCell\n{\nT\n}\n,\n \npixsize\n,\n \nrows\n::\nInteger\n,\n \nalt\n;\n \nkwargs\n...)\n\n\n\n\n\n\nIn cell \nc\n, generate a checkerboard pattern suitable for contrast curve measurement, or getting the base dose for PEC.\n\n\n\n\npixsize\n: length of one side of a square\n\n\nrows\n: number of rows == number of columns\n\n\nalt\n: the square nearest \nPoint(zero(T), zero(T))\n is filled (unfilled) if \nfalse\n (\ntrue\n). Use this to create a full tiling of the checkerboard, if you wish.\n\n\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\ncheckerboard!\n(\nc\n,\n \n20\n\u03bcm\n,\n \n10\n,\n \nfalse\n,\n \nlayer\n=\n2\n)\n\n\ncheckerboard!\n(\nc\n,\n \n20\n\u03bcm\n,\n \n10\n,\n \ntrue\n,\n \nlayer\n=\n3\n)\n\n\n\n\n\n\n\n\n#\n\n\nDevices.Tags.grating!\n \n \nFunction\n.\n\n\ngrating\n!\n{\nT\n}\n(\nc\n::\nCell\n{\nT\n}\n,\n \nline\n,\n \nspace\n,\n \nsize\n;\n \nkwargs\n...)\n\n\n\n\n\n\nGenerate a square grating suitable e.g. for obtaining the base dose for PEC.\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\ngrating!\n(\nc\n,\n \n100\nnm\n,\n \n100\nnm\n,\n \n5\n\u03bcm\n,\n \nlayer\n=\n3\n)\n\n\n\n\n\n\n\n\n#\n\n\nDevices.Tags.interdigit!\n \n \nFunction\n.\n\n\ninterdigit!{T}(c::Cell{T}, width, length, xgap, ygap, npairs::Integer,\n    skiplast=true; kwargs...)\n\n\n\n\n\nCreates interdigitated fingers, e.g. for a lumped element capacitor.\n\n\n\n\nwidth\n: finger width\n\n\nlength\n: finger length\n\n\nxgap\n: x-offset at ends of fingers\n\n\nfingergap\n: gap between fingers\n\n\nnpairs\n: number of fingers\n\n\nskiplast\n: should we skip the last finger, leaving an odd number?\n\n\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\ninterdigit!\n(\nc\n,\n \n1\n\u03bcm\n,\n \n20\n\u03bcm\n,\n \n1\n\u03bcm\n,\n \n3\n\u03bcm\n,\n \n5\n,\n \ntrue\n;\n \nlayer\n \n=\n \n5\n)\n\n\n\n\n\n\n\n\n#\n\n\nDevices.Tags.radialcut!\n \n \nFunction\n.\n\n\nradialcut\n!\n{\nT\n}\n(\nc\n::\nCell\n{\nT\n}\n,\n \nr\n,\n \n\u0398\n,\n \nh\n,\n \nnarc\n=\n197\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a polygon for a radial cut (like a radial stub with no metal). The polygon has to be subtracted from a ground plane.\n\n\nThe parameter \nh\n is made available in the method signature rather than \na\n because the focus of the arc (top of polygon) can easily centered in a waveguide. If it is desirable to control \na\n instead, use trig: \na/2 = h*tan(\u0398/2)\n.\n\n\nParameters as follows, where X marks the origin and (\nnothing above the origin is part of the resulting polygon\n):\n\n\n                       \u039b\n                      /\u2502\\\n                     / \u2502 \\\n                    /  |  \\\n              .    /   \u2502\u0398/2\\\n             .    /    \u2502----\\\n            /    /   h \u2502     \\\n           /    /      \u2502      \\\n          /    /       \u2502       \\\n         r    /        \u2502        \\\n        /    /         \u2502         \\\n       /    /----------X----------\\\n      /    /{--------- a ---------}\\\n     .    /                         \\\n    .    /                           \\\n        /                             \\\n       /                               \\\n      /                                 \\\n      --\u2510                             \u250c--\n        \u2514--\u2510                       \u250c--\u2518\n           \u2514--\u2510                 \u250c--\u2518\n              \u2514--\u2510           \u250c--\u2518\n                 \u2514-----------\u2518\n                 (circular arc)\n\n\n\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\nradialcut!\n(\nc\n,\n \n20\n\u03bcm\n,\n \n90\n\u00b0\n,\n \n5\n\u03bcm\n,\n \nlayer\n=\n1\n)\n\n\n\n\n\n\n\n\n#\n\n\nDevices.Tags.radialstub!\n \n \nFunction\n.\n\n\nradialstub\n!\n{\nT\n}\n(\nc\n::\nCell\n{\nT\n}\n,\n \nr\n,\n \n\u0398\n,\n \nh\n,\n \nt\n,\n \nnarc\n=\n197\n;\n \nkwargs\n...)\n\n\n\n\n\n\nSee also the documentation for \nradialcut!\n.\n\n\nReturns a polygon for a radial stub. The polygon has to be subtracted from a ground plane, and will leave a defect in the ground plane of uniform width \nt\n that outlines the (metallic) radial stub. \nr\n refers to the radius of the actual stub, not the radius of the circular arc bounding the ground plane defect. Likewise \nh\n has an analogous meaning to that in \nradialcut!\n except it refers here to the radial stub, not the ground plane defect.\n\n\nsource\n\n\nExample:\n\n\nc\n \n=\n \nCell\n(\nmain\n,\n \nnm\n)\n\n\nradialstub!\n(\nc\n,\n \n20\n\u03bcm\n,\n \n90\n\u00b0\n,\n \n5\n\u03bcm\n,\n \n1\n\u03bcm\n,\n \nlayer\n=\n1\n)", 
            "title": "Compound shapes"
        }, 
        {
            "location": "/render/", 
            "text": "A \nSegment\n and \nStyle\n together define one or more closed curves in the plane. The job of rendering is to approximate these curves by closed polygons. To enable rendering of styles along generic paths in the plane, an adaptive algorithm is used:\n\n\n#\n\n\nDevices.adapted_grid\n \n \nFunction\n.\n\n\nadapted_grid(f, anchors;\n    max_recursions::Real = 7, max_change = 5\u00b0, rand_factor::Real = 0.05,\n    grid_step = 1.0\u03bcm)\n\n\n\n\n\nComputes a resampled \ngrid\n given anchor points so that \nf.(grid)\n is sufficiently smooth. The method used is to create an initial grid around the anchor points and refine intervals. When an interval becomes \"straight enough\" it is no longer divided. Adapted from a contribution to PlotUtils.jl from Kristoffer Carlsson.\n\n\n\n\nmax_recursions\n: how many times each interval is allowed to be refined.\n\n\nmax_change\n: specifies acceptable change between evaluations of \nf\n on subsequent grid points, as estimated by the derivative times the distance between grid points. Typically, \nf\n is the angle of a path in the plane, so this is often an angle threshold. This condition is approximately valid in the end result, but may be weakly violated. This condition may be grossly violated if \nmax_recursions\n is too low.\n\n\nrand_factor\n: between anchor points, \nadapted_grid\n will wiggle initial grid points a bit to prevent aliasing. The wiggling is sampled uniformly from the interval: \n[-rand_factor, rand_factor]\n, times the distance between three grid points (e.g. \ni+1\n and \ni-1\n). A random number generator is given a fixed seed every time \nadapted_grid\n is called, so the rendered results are deterministic.\n\n\ngrid_step\n: Step size for initial grid points. If you set this to be larger than the maximum anchor point, then the lowest resolution consistent with \nmax_change\n is used (unless \nf\n has some fast variations that the algorithm might miss).\n\n\n\n\nsource\n\n\nIn some cases, custom rendering methods are implemented when it would improve performance for simple structures or when special attention is required. The rendering methods can specialize on either the \nSegment\n or \nStyle\n types, or both.\n\n\n\n\nRender methods\n\n\n#\n\n\nDevices.render!\n \n \nFunction\n.\n\n\nrender\n!(\nc\n::\nCell\n,\n \nr\n::\nRectangle\n,\n \ns\n::\nRectangles\n.\nStyle\n=\nRectangles\n.\nPlain\n();\n \nkwargs\n...)\n\n\nrender\n!(\nc\n::\nCell\n,\n \nr\n::\nRectangle\n,\n \n::\nRectangles\n.\nPlain\n;\n \nkwargs\n...)\n\n\nrender\n!(\nc\n::\nCell\n,\n \nr\n::\nRectangle\n,\n \ns\n::\nRectangles\n.\nRounded\n;\n \nkwargs\n...)\n\n\nrender\n!(\nc\n::\nCell\n,\n \nr\n::\nRectangle\n,\n \ns\n::\nRectangles\n.\nUndercut\n;\n\n    \nlayer\n=\n0\n,\n \nuclayer\n=\n0\n,\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rectangle \nr\n to cell \nc\n, defaulting to plain styling.\n\n\nsource\n\n\nrender\n!(\nc\n::\nCell\n,\n \nr\n::\nPolygon\n,\n \ns\n::\nPolygons\n.\nStyle\n=\nPolygons\n.\nPlain\n();\n \nkwargs\n...)\n\n\nrender\n!(\nc\n::\nCell\n,\n \nr\n::\nPolygon\n,\n \ns\n::\nPolygons\n.\nPlain\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a polygon \nr\n to cell \nc\n, defaulting to plain styling. Currently there is no other Polygon rendering style implemented.\n\n\nsource\n\n\nrender\n!(\nc\n::\nCell\n,\n \np\n::\nPath\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a path \np\n to a cell \nc\n.\n\n\nsource\n\n\nrender\n!(\nc\n::\nCell\n,\n \nsegment\n::\nPaths\n.\nSegment\n,\n \ns\n::\nPaths\n.\nDecoratedStyle\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a \nsegment\n with decorated style \ns\n to cell \nc\n. Cell references held by the decorated style will have their fields modified by this method, which is why they are shallow copied in the \nPaths.attach!\n function.\n\n\nThis method draws the decorations before the path itself is drawn.\n\n\nsource", 
            "title": "Rendering"
        }, 
        {
            "location": "/render/#render-methods", 
            "text": "#  Devices.render!     Function .  render !( c :: Cell ,   r :: Rectangle ,   s :: Rectangles . Style = Rectangles . Plain ();   kwargs ...)  render !( c :: Cell ,   r :: Rectangle ,   :: Rectangles . Plain ;   kwargs ...)  render !( c :: Cell ,   r :: Rectangle ,   s :: Rectangles . Rounded ;   kwargs ...)  render !( c :: Cell ,   r :: Rectangle ,   s :: Rectangles . Undercut ; \n     layer = 0 ,   uclayer = 0 ,   kwargs ...)   Render a rectangle  r  to cell  c , defaulting to plain styling.  source  render !( c :: Cell ,   r :: Polygon ,   s :: Polygons . Style = Polygons . Plain ();   kwargs ...)  render !( c :: Cell ,   r :: Polygon ,   s :: Polygons . Plain ;   kwargs ...)   Render a polygon  r  to cell  c , defaulting to plain styling. Currently there is no other Polygon rendering style implemented.  source  render !( c :: Cell ,   p :: Path ;   kwargs ...)   Render a path  p  to a cell  c .  source  render !( c :: Cell ,   segment :: Paths . Segment ,   s :: Paths . DecoratedStyle ;   kwargs ...)   Render a  segment  with decorated style  s  to cell  c . Cell references held by the decorated style will have their fields modified by this method, which is why they are shallow copied in the  Paths.attach!  function.  This method draws the decorations before the path itself is drawn.  source", 
            "title": "Render methods"
        }, 
        {
            "location": "/fileio/", 
            "text": "This package can load/save patterns in the GDS-II format for use with e-beam lithography systems. In the future it may be useful to implement machine-specific pattern formats to force fracturing or dosing in an explicit manner.\n\n\nWe also provide an experimental option to export to the SVG vector graphics format. This enables patterns to be inspected in web browsers or used in presentations, for example.\n\n\n\n\nSaving patterns\n\n\nTo save a pattern in any format, make sure you are \nusing\n \nFileIO\n.\n\n\n#\n\n\nFileIO.save\n \n \nMethod\n.\n\n\nsave\n(\n::\nUnion\n{\nAbstractString,IO\n}\n,\n \ncell0\n::\nCell\n{\nT\n}\n,\n \ncell\n::\nCell\n...)\n\n\nsave\n(\nf\n::\nFile\n{\nformat\nGDS\n}\n,\n \ncell0\n::\nCell\n,\n \ncell\n::\nCell\n...;\n\n    \nname\n=\nGDSIILIB\n,\n \nuserunit\n=\n1\n\u03bc\nm\n,\n \nmodify\n=\nnow\n(),\n \nacc\n=\nnow\n(),\n\n    \nverbose\n=\nfalse\n)\n\n\n\n\n\n\nThis bottom method is implicitly called when you use the convenient syntax of the top method: \nsave(\"/path/to/my.gds\", cells_i_want_to_save...)\n\n\nKeyword arguments include:\n\n\n\n\nname\n: used for the internal library name of the GDS-II file and probably inconsequential for modern workflows.\n\n\nuserunit\n: sets what 1.0 corresponds to when viewing this file in graphical GDS editors with inferior unit support.\n\n\nmodify\n: date of last modification.\n\n\nacc\n: date of last accession. It would be unusual to have this differ from \nnow()\n.\n\n\nverbose\n: monitor the output of \ntraverse!\n and \norder!\n to see if something funny is happening while saving.\n\n\n\n\nsource\n\n\n#\n\n\nFileIO.save\n \n \nMethod\n.\n\n\nsave\n(\n::\nUnion\n{\nAbstractString,IO\n}\n,\n \nc0\n::\nCell\n;\n \noptions\n...)\n\n\nsave\n(\nf\n::\nFile\n{\nformat\nSVG\n}\n,\n \nc0\n::\nCell\n;\n \noptions\n...)\n\n\n\n\n\n\nThis bottom method is implicitly called when you use the convenient syntax of the top method: \nsave(\"/path/to/my.gds\", cell_i_want_to_save)\n\n\nPossible keyword arguments include:\n\n\n\n\nwidth\n: Specifies the width parameter of the SVG tag. Defaults to the width of the cell bounding box (stripped of units).\n\n\nheight\n: Specifies the height parameter of the SVG tag. Defaults to the height of the cell bounding box (stripped of units).\n\n\nlayercolors\n: Should be a dictionary with \nInt\n keys for layers and color strings as values. By color strings we mean \"#ff0000\", \"red\", \"rgb(255,0,0)\", etc.\n\n\n\n\nsource\n\n\n\n\nLoading patterns\n\n\nTo load a pattern in any format, make sure you are \nusing\n \nFileIO\n.\n\n\n#\n\n\nFileIO.load\n \n \nMethod\n.\n\n\nload\n(\nf\n::\nFile\n{\nformat\nGDS\n}\n;\n \nverbose\n::\nBool\n=\nfalse\n,\n \nnounits\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nA dictionary of top-level cells (\nCell\n objects) found in the GDS-II file is returned. The dictionary keys are the cell names. The other cells in the GDS-II file are retained by \nCellReference\n or \nCellArray\n objects held by the top-level cells. Currently, cell references and arrays are not implemented.\n\n\nThe FileIO package recognizes files based on \"magic bytes\" at the start of the file. To permit any version of GDS-II file to be read, we consider the magic bytes to be the GDS HEADER tag (\n0x0002\n), preceded by the number of bytes in total (\n0x0006\n) for the entire HEADER record. The last well-documented version of GDS-II is v6.0.0, encoded as \n0x0258 == 600\n. LayoutEditor appears to save a version 7 as \n0x0007\n, which as far as I can tell is unofficial, and probably just permits more layers than 64, or extra characters in cell names, etc.\n\n\nIf the database scale is \n1\u03bcm\n, \n1nm\n, or \n1pm\n, then the corresponding unit is used for the resulting imported cells. Otherwise, an \"anonymous unit\" is used that will display as \nu\"2.4\u03bcm\"\n if the database scale is 2.4\u03bcm, say.\n\n\nWarnings are thrown if the GDS-II file does not begin with a BGNLIB record following the HEADER record, but loading will proceed.\n\n\nEncountering an ENDLIB record will discard the remainder of the GDS-II file without warning. If no ENDLIB record is present, a warning will be thrown.\n\n\nThe content of some records are currently discarded (mainly the more obscure GDS-II record types, but also BGNLIB and LIBNAME).\n\n\nIf \nnounits\n is true, \nCell{Float64}\n objects will be returned, where 1.0 corresponds to one micron.\n\n\nsource\n\n\n#\n\n\nFileIO.load\n \n \nMethod\n.\n\n\nload(f::File{format\nSVG\n})\n\n\n\n\n\nNot yet implemented.\n\n\nsource", 
            "title": "File formats"
        }, 
        {
            "location": "/fileio/#saving-patterns", 
            "text": "To save a pattern in any format, make sure you are  using   FileIO .  #  FileIO.save     Method .  save ( :: Union { AbstractString,IO } ,   cell0 :: Cell { T } ,   cell :: Cell ...)  save ( f :: File { format GDS } ,   cell0 :: Cell ,   cell :: Cell ...; \n     name = GDSIILIB ,   userunit = 1 \u03bc m ,   modify = now (),   acc = now (), \n     verbose = false )   This bottom method is implicitly called when you use the convenient syntax of the top method:  save(\"/path/to/my.gds\", cells_i_want_to_save...)  Keyword arguments include:   name : used for the internal library name of the GDS-II file and probably inconsequential for modern workflows.  userunit : sets what 1.0 corresponds to when viewing this file in graphical GDS editors with inferior unit support.  modify : date of last modification.  acc : date of last accession. It would be unusual to have this differ from  now() .  verbose : monitor the output of  traverse!  and  order!  to see if something funny is happening while saving.   source  #  FileIO.save     Method .  save ( :: Union { AbstractString,IO } ,   c0 :: Cell ;   options ...)  save ( f :: File { format SVG } ,   c0 :: Cell ;   options ...)   This bottom method is implicitly called when you use the convenient syntax of the top method:  save(\"/path/to/my.gds\", cell_i_want_to_save)  Possible keyword arguments include:   width : Specifies the width parameter of the SVG tag. Defaults to the width of the cell bounding box (stripped of units).  height : Specifies the height parameter of the SVG tag. Defaults to the height of the cell bounding box (stripped of units).  layercolors : Should be a dictionary with  Int  keys for layers and color strings as values. By color strings we mean \"#ff0000\", \"red\", \"rgb(255,0,0)\", etc.   source", 
            "title": "Saving patterns"
        }, 
        {
            "location": "/fileio/#loading-patterns", 
            "text": "To load a pattern in any format, make sure you are  using   FileIO .  #  FileIO.load     Method .  load ( f :: File { format GDS } ;   verbose :: Bool = false ,   nounits :: Bool = false )   A dictionary of top-level cells ( Cell  objects) found in the GDS-II file is returned. The dictionary keys are the cell names. The other cells in the GDS-II file are retained by  CellReference  or  CellArray  objects held by the top-level cells. Currently, cell references and arrays are not implemented.  The FileIO package recognizes files based on \"magic bytes\" at the start of the file. To permit any version of GDS-II file to be read, we consider the magic bytes to be the GDS HEADER tag ( 0x0002 ), preceded by the number of bytes in total ( 0x0006 ) for the entire HEADER record. The last well-documented version of GDS-II is v6.0.0, encoded as  0x0258 == 600 . LayoutEditor appears to save a version 7 as  0x0007 , which as far as I can tell is unofficial, and probably just permits more layers than 64, or extra characters in cell names, etc.  If the database scale is  1\u03bcm ,  1nm , or  1pm , then the corresponding unit is used for the resulting imported cells. Otherwise, an \"anonymous unit\" is used that will display as  u\"2.4\u03bcm\"  if the database scale is 2.4\u03bcm, say.  Warnings are thrown if the GDS-II file does not begin with a BGNLIB record following the HEADER record, but loading will proceed.  Encountering an ENDLIB record will discard the remainder of the GDS-II file without warning. If no ENDLIB record is present, a warning will be thrown.  The content of some records are currently discarded (mainly the more obscure GDS-II record types, but also BGNLIB and LIBNAME).  If  nounits  is true,  Cell{Float64}  objects will be returned, where 1.0 corresponds to one micron.  source  #  FileIO.load     Method .  load(f::File{format SVG })  Not yet implemented.  source", 
            "title": "Loading patterns"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The Devices.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nA modified version of \nadaptive_grid\n was originally from PlotUtils.jl, an MIT \"Expat\" licensed Julia package by Tom Breloff and contributors (notably Kristoffer Carlsson).\n\n\nCadence Design Systems, Inc. holds the rights to the GDS-II format. The specification has been described with permission in the SPIE Handbook of Microlithography, Micromachining and Microfabrication, vol. 1 (accessible \nhere\n as of April 17, 2017).", 
            "title": "License"
        }
    ]
}