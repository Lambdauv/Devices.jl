{
    "docs": [
        {
            "location": "/", 
            "text": "Devices.jl\n\n\nA \nJulia\n package for designing CAD files for superconducting devices.\n\n\n\n\nInstallation\n\n\n\n\n\n\nInstall \ngdspy\n, which is currently used only for rendering paths into polygons: \npip install gdspy\n. Ensure that it is accessible from the Python installation that PyCall.jl is using.\n\n\n\n\n\n\nInstall \npyclipper\n, which is used for polygon offsetting: \npip install pyclipper\n.\n\n\n\n\n\n\nInstall \npyqrcode\n, which is used for generating QR codes: \npip install pyqrcode\n.\n\n\n\n\n\n\nUsing features implemented with \nGPC\n require building shared libraries from the C code.\n\n\n\n\n\n\nPkg.clone(\"https://github.com/ajkeller34/Devices.jl.git\")\n\n\n\n\n\n\n\n\nQuick start\n\n\nusing Devices, FileIO\n\np = Path()\nstyle = launch!(p)\nstraight!(p,500,style)\nturn!(p,\u03c0/2,150)\nstraight!(p,500)\nlaunch!(p)\nc = Cell(\nmain\n)\nrender!(c, p)\nsave(\ntest.gds\n, c)", 
            "title": "Home"
        }, 
        {
            "location": "/#devicesjl", 
            "text": "A  Julia  package for designing CAD files for superconducting devices.", 
            "title": "Devices.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install  gdspy , which is currently used only for rendering paths into polygons:  pip install gdspy . Ensure that it is accessible from the Python installation that PyCall.jl is using.    Install  pyclipper , which is used for polygon offsetting:  pip install pyclipper .    Install  pyqrcode , which is used for generating QR codes:  pip install pyqrcode .    Using features implemented with  GPC  require building shared libraries from the C code.    Pkg.clone(\"https://github.com/ajkeller34/Devices.jl.git\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "using Devices, FileIO\n\np = Path()\nstyle = launch!(p)\nstraight!(p,500,style)\nturn!(p,\u03c0/2,150)\nstraight!(p,500)\nlaunch!(p)\nc = Cell( main )\nrender!(c, p)\nsave( test.gds , c)", 
            "title": "Quick start"
        }, 
        {
            "location": "/points/", 
            "text": "Points are implemented using the abstract type \nFixedVectorNoTuple\n from \nFixedSizeArrays.jl\n. This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike \nTuple\n objects, we can add points together, simplifying many function definitions.\n\n\nTo interface with gdspy, we simply convert the \nPoint\n object to a \nTuple\n and let \nPyCall.jl\n figure out what to do.\n\n\n#\n\n\nDevices.Points.getx\n \n \nFunction\n.\n\n\n\n\ngetx(p::Point)\n\n\n\n\n\nGet the x-coordinate of a point.\n\n\n#\n\n\nDevices.Points.gety\n \n \nFunction\n.\n\n\n\n\ngety(p::Point)\n\n\n\n\n\nGet the y-coordinate of a point.", 
            "title": "Points"
        }, 
        {
            "location": "/paths/", 
            "text": "Paths\n\n\n#\n\n\nDevices.Paths.Path\n \n \nType\n.\n\n\n\n\ntype Path{T\n:Real} \n: AbstractArray{Tuple{Segment{T},Style},1}\n    origin::Point{2,T}\n    \u03b10::Real\n    style0::Style\n    segments::Array{Segment{T},1}\n    styles::Array{Style,1}\n    Path(origin::Point{2,T}, \u03b10::Real, style0::Style, segments::Array{Segment{T},1},\n        styles::Array{Style,1}) = new(origin, \u03b10, style0, segments, styles)\n    Path(style::Style) =\n        new(Point(zero(T),zero(T)), 0.0, style, Segment{T}[], Style[])\nend\n\n\n\n\n\nType for abstracting an arbitrary styled path in the plane. Iterating returns tuples of (\nsegment\n, \nstyle\n).\n\n\n#\n\n\nDevices.Paths.Path\n \n \nMethod\n.\n\n\n\n\nPath{T\n:Real}(origin::Point{2,T}=Point(0.0,0.0), \u03b10::Real=0.0, style0::Style=Trace(1.0))\n\n\n\n\n\nConvenience constructor for \nPath{T}\n object.\n\n\n#\n\n\nDevices.Paths.Path\n \n \nMethod\n.\n\n\n\n\nPath{T\n:Real}(origin::Tuple{T,T})\n\n\n\n\n\nConvenience constructor for \nPath{T}\n object.\n\n\n#\n\n\nDevices.Paths.Path\n \n \nMethod\n.\n\n\n\n\nPath{T\n:Real}(origin::Tuple{T,T}, \u03b10::Real)\n\n\n\n\n\nConvenience constructor for \nPath{T}\n object.\n\n\n#\n\n\nDevices.Paths.pathlength\n \n \nMethod\n.\n\n\n\n\npathlength(p::Path)\n\n\n\n\n\nPhysical length of a path. Note that \nlength\n will return the number of segments in a path, not the physical length.\n\n\n\n\nSegments\n\n\n#\n\n\nDevices.Paths.Segment\n \n \nType\n.\n\n\n\n\nabstract Segment{T\n:Real}\n\n\n\n\n\nPath segment in the plane. All Segment objects should have the implement the following methods:\n\n\n\n\nlength\n\n\norigin\n\n\n\u03b10\n\n\nsetorigin!\n\n\nset\u03b10!\n\n\nlastangle\n\n\n\n\n#\n\n\nDevices.Paths.Straight\n \n \nType\n.\n\n\n\n\ntype Straight{T\n:Real} \n: Segment{T}\n    l::T\n    origin::Point{2,T}\n    \u03b10::Real\n    f::Function\n    Straight(l, origin, \u03b10) = begin\n        s = new(l, origin, \u03b10)\n        s.f = t-\n(s.origin+Point(t*s.l*cos(s.\u03b10),t*s.l*sin(s.\u03b10)))\n        s\n    end\nend\n\n\n\n\n\nA straight line segment is parameterized by its length. It begins at a point \norigin\n with initial angle \n\u03b10\n.\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the line segment is given by:\n\n\nt -\n origin + Point(t*l*cos(\u03b1),t*l*sin(\u03b1))\n\n\n#\n\n\nDevices.Paths.Turn\n \n \nType\n.\n\n\n\n\ntype Turn{T\n:Real} \n: Segment{T}\n    \u03b1::Real\n    r::T\n    origin::Point{2,T}\n    \u03b10::Real\n    f::Function\n    Turn(\u03b1, r, origin, \u03b10) = begin\n        s = new(\u03b1, r, origin, \u03b10)\n        s.f = t-\nbegin\n            cen = s.origin + Point(s.r*cos(s.\u03b10+sign(s.\u03b1)*\u03c0/2), s.r*sin(s.\u03b10+sign(s.\u03b1)*\u03c0/2))\n            cen + Point(s.r*cos(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t), s.r*sin(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t))\n        end\n        s\n    end\nend\n\n\n\n\n\nA circular turn is parameterized by the turn angle \n\u03b1\n and turning radius \nr\n. It begins at a point \norigin\n with initial angle \n\u03b10\n.\n\n\nThe center of the circle is given by:\n\n\ncen = origin + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the turn is given by:\n\n\nt -\n cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))\n\n\n#\n\n\nDevices.Paths.CompoundSegment\n \n \nType\n.\n\n\n\n\ntype CompoundSegment{T\n:Real} \n: Segment{T}\n    segments::Array{Segment{T},1}\n    f::Function\n\n    CompoundSegment(segments) = begin\n        s = new(segments)\n        s.f = param(s)\n        s\n    end\nend\n\n\n\n\n\nConsider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes.\n\n\n\n\nStyles\n\n\n#\n\n\nDevices.Paths.Style\n \n \nType\n.\n\n\n\n\nabstract Style\n\n\n\n\n\nHow to render a given path segment. All styles should implement the following methods:\n\n\n\n\ndistance\n\n\nextent\n\n\npaths\n\n\nwidth\n\n\ndivs\n\n\n\n\n#\n\n\nDevices.Paths.Trace\n \n \nType\n.\n\n\n\n\ntype Trace \n: Style\n    width::Function\n    divs::Int\nend\n\n\n\n\n\nSimple, single trace.\n\n\n\n\nwidth::Function\n: trace width.\n\n\ndivs::Int\n: number of segments to render. Increase if you see artifacts.\n\n\n\n\n#\n\n\nDevices.Paths.CPW\n \n \nType\n.\n\n\n\n\ntype CPW \n: Style\n    trace::Function\n    gap::Function\n    divs::Int\nend\n\n\n\n\n\nTwo adjacent traces can form a coplanar waveguide.\n\n\n\n\ntrace::Function\n: center conductor width.\n\n\ngap::Function\n: distance between center conductor edges and ground plane\n\n\ndivs::Int\n: number of segments to render. Increase if you see artifacts.\n\n\n\n\nMay need to be inverted with respect to a ground plane, depending on how the pattern is written.\n\n\n#\n\n\nDevices.Paths.CompoundStyle\n \n \nType\n.\n\n\n\n\ntype CompoundStyle{T\n:Real} \n: Style\n    segments::Array{Segment{T},1}\n    styles::Array{Style,1}\n    f::Function\n    CompoundStyle(segments, styles) = begin\n        s = new(segments, styles)\n        s.f = param(s)\n        s\n    end\nend\n\n\n\n\n\nCombines styles together for use with a \nCompoundSegment\n.\n\n\n\n\nsegments\n: Needed for divs function.\n\n\nstyles\n: Array of styles making up the object.\n\n\nf\n: returns tuple of style index and the \nt\n to use for that style's parametric function.\n\n\n\n\n#\n\n\nDevices.Paths.DecoratedStyle\n \n \nType\n.\n\n\n\n\ntype DecoratedStyle{S\n:Real} \n: Style\n    s::Style\n    ts::AbstractArray{Float64,1}\n    offsets::Array{S,1}\n    dirs::Array{Int,1}\n    cells::Array{ASCIIString,1}\n    DecoratedStyle(s) = begin\n        a = new(s)\n        a.ts = Float64[]\n        a.offsets = S[]\n        a.dirs = Int[]\n        a.cells = ASCIIString[]\n    end\n    DecoratedStyle(s,t,o,r,c) = new(s,t,o,r,c)\nend\n\n\n\n\n\nStyle with decorations, like periodic structures along the path, etc.\n\n\n\n\nPath interrogation\n\n\n#\n\n\nDevices.Paths.direction\n \n \nFunction\n.\n\n\n\n\ndirection(p::Function, t)\n\n\n\n\n\nFor some parameteric function \np(t)\u21a6Point(x(t),y(t))\n, returns the angle at which the path is pointing for a given \nt\n.\n\n\n#\n\n\nDevices.Paths.pathlength\n \n \nFunction\n.\n\n\n\n\npathlength(p::AbstractArray{Segment})\n\n\n\n\n\nTotal physical length of segments.\n\n\npathlength(p::Path)\n\n\n\n\n\nPhysical length of a path. Note that \nlength\n will return the number of segments in a path, not the physical length.\n\n\n#\n\n\nDevices.Paths.origin\n \n \nFunction\n.\n\n\n\n\norigin(p::Path)\n\n\n\n\n\nFirst point of a path.\n\n\norigin{T}(s::Segment{T})\n\n\n\n\n\nReturn the first point in a segment (calculated).\n\n\n#\n\n\nDevices.Paths.setorigin!\n \n \nFunction\n.\n\n\n\n\nsetorigin!(s::CompoundSegment, p::Point)\n\n\n\n\n\nSet the origin of a compound segment.\n\n\nsetorigin!(s::Turn, p::Point)\n\n\n\n\n\nSet the origin of a turn.\n\n\nsetorigin!(s::Straight, p::Point)\n\n\n\n\n\nSet the origin of a straight segment.\n\n\n#\n\n\nDevices.Paths.\u03b10\n \n \nFunction\n.\n\n\n\n\n\u03b10(p::Path)\n\n\n\n\n\nFirst angle of a path.\n\n\n\u03b10(s::Segment)\n\n\n\n\n\nReturn the first angle in a segment (calculated).\n\n\n#\n\n\nDevices.Paths.set\u03b10!\n \n \nFunction\n.\n\n\n\n\nset\u03b10!(s::CompoundSegment, \u03b10\u2032)\n\n\n\n\n\nSet the starting angle of a compound segment.\n\n\nset\u03b10!(s::Turn, \u03b10\u2032)\n\n\n\n\n\nSet the starting angle of a turn.\n\n\nset\u03b10!(s::Straight, \u03b10\u2032)\n\n\n\n\n\nSet the angle of a straight segment.\n\n\n#\n\n\nDevices.Paths.lastpoint\n \n \nFunction\n.\n\n\n\n\nlastpoint(p::Path)\n\n\n\n\n\nLast point of a path.\n\n\nlastpoint{T}(s::Segment{T})\n\n\n\n\n\nReturn the last point in a segment (calculated).\n\n\n#\n\n\nDevices.Paths.lastangle\n \n \nFunction\n.\n\n\n\n\nlastangle(p::Path)\n\n\n\n\n\nLast angle of a path.\n\n\nlastangle(s::Segment)\n\n\n\n\n\nReturn the last angle in a segment (calculated).\n\n\n#\n\n\nDevices.Paths.firststyle\n \n \nFunction\n.\n\n\n\n\nfirststyle(p::Path)\n\n\n\n\n\nStyle of the first segment of a path.\n\n\n#\n\n\nDevices.Paths.laststyle\n \n \nFunction\n.\n\n\n\n\nlaststyle(p::Path)\n\n\n\n\n\nStyle of the last segment of a path.\n\n\n\n\nPath building\n\n\n#\n\n\nBase.append!\n \n \nMethod\n.\n\n\n\n\nappend!(p::Path, p\u2032::Path)\n\n\n\n\n\nGiven paths \np\n and \np\u2032\n, path \np\u2032\n is appended to path \np\n. The origin and initial angle of the first segment from path \np\u2032\n is modified to match the last point and last angle of path \np\n.\n\n\n#\n\n\nDevices.Paths.adjust!\n \n \nFunction\n.\n\n\n\n\nadjust!(p::Path, n::Integer=1)\n\n\n\n\n\nAdjust a path's parametric functions starting from index \nn\n. Used internally whenever segments are inserted into the path.\n\n\n#\n\n\nDevices.Paths.launch!\n \n \nFunction\n.\n\n\n\n\nlaunch\n!(\np\n:\n:Path\n;\n \nextround\n=\n5\n,\n \ntrace0\n=\n300\n,\n \ntrace1\n=\n5\n,\n\n        \ngap0\n=\n150\n,\n \ngap1\n=\n2\n.5\n,\n \nflatlen\n=\n250\n,\n \ntaperlen\n=\n250\n)\n\n\n\n\n\n\nAdd a launcher to the path. Somewhat intelligent in that the launcher will reverse its orientation depending on if it is at the start or the end of a path.\n\n\nThere are numerous keyword arguments to control the behavior:\n\n\n\n\nextround\n: Rounding radius of the outermost corners; should be less than \ngap0\n.\n\n\ntrace0\n: Bond pad width.\n\n\ntrace1\n: Center trace width of next CPW segment.\n\n\ngap0\n: Gap width adjacent to bond pad.\n\n\ngap1\n: Gap width of next CPW segment.\n\n\nflatlen\n: Bond pad length.\n\n\ntaperlen\n: Length of taper region between bond pad and next CPW segment.\n\n\n\n\nReturns a \nStyle\n object suitable for continuity with the next segment. Ignore the returned style if you are terminating a path.\n\n\n#\n\n\nDevices.Paths.meander!\n \n \nFunction\n.\n\n\n\n\nmeander!{T\n:Real}(p::Path{T}, len, r, straightlen, \u03b1::Real)\n\n\n\n\n\nAlternate between going straight with length \nstraightlen\n and turning with radius \nr\n and angle \n\u03b1\n. Each turn goes the opposite direction of the previous. The total length is \nlen\n. Useful for making resonators.\n\n\nThe straight and turn segments are combined into a \nCompoundSegment\n and appended to the path \np\n.\n\n\n#\n\n\nDevices.Paths.param\n \n \nFunction\n.\n\n\n\n\nparam{T\n:Real}(c::CompoundSegment{T})\n\n\n\n\n\nReturn a parametric function over the domain [0,1] that represents the compound segment.\n\n\n#\n\n\nDevices.Paths.simplify!\n \n \nFunction\n.\n\n\n\n\nsimplify!(p::Path)\n\n\n\n\n\nAll segments of a path are turned into a \nCompoundSegment\n and all styles of a path are turned into a \nCompoundStyle\n. The idea here is:\n\n\n\n\nIndexing the path becomes more sane when you can combine several path segments into one logical element. A launcher would have several indices in a path unless you could simplify it.\n\n\nYou don't need to think hard about boundaries between straights and turns when you want a continuous styling of a very long path.\n\n\n\n\n#\n\n\nDevices.Paths.straight!\n \n \nFunction\n.\n\n\n\n\nstraight!(p::Path, l::Real)\n\n\n\n\n\nExtend a path \np\n straight by length \nl\n in the current direction.\n\n\n#\n\n\nDevices.Paths.turn!\n \n \nFunction\n.\n\n\n\n\nturn!(p::Path, s::ASCIIString, r::Real, sty::Style=laststyle(p))\n\n\n\n\n\nTurn a path \np\n with direction coded by string \ns\n:\n\n\n\n\n\"l\": turn by \u03c0/2 (left)\n\n\n\"r\": turn by -\u03c0/2 (right)\n\n\n\"lrlrllrrll\": do those turns in that order\n\n\n\n\nturn!(p::Path, \u03b1::Real, r::Real, sty::Style=laststyle(p))\n\n\n\n\n\nTurn a path \np\n by angle \n\u03b1\n with a turning radius \nr\n in the current direction. Positive angle turns left.\n\n\n\n\nInterfacing with gdspy\n\n\nThe Python package \ngdspy\n is used for rendering paths into polygons. Ultimately we intend to remove this dependency.\n\n\n#\n\n\nDevices.Paths.distance\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the distance between the centers of parallel paths rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.extent\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns a distance tangential to the path specifying the lateral extent of the polygons rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.paths\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the number of parallel paths rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.width\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the width of paths rendered by gdspy.", 
            "title": "Paths"
        }, 
        {
            "location": "/paths/#paths", 
            "text": "#  Devices.Paths.Path     Type .   type Path{T :Real}  : AbstractArray{Tuple{Segment{T},Style},1}\n    origin::Point{2,T}\n    \u03b10::Real\n    style0::Style\n    segments::Array{Segment{T},1}\n    styles::Array{Style,1}\n    Path(origin::Point{2,T}, \u03b10::Real, style0::Style, segments::Array{Segment{T},1},\n        styles::Array{Style,1}) = new(origin, \u03b10, style0, segments, styles)\n    Path(style::Style) =\n        new(Point(zero(T),zero(T)), 0.0, style, Segment{T}[], Style[])\nend  Type for abstracting an arbitrary styled path in the plane. Iterating returns tuples of ( segment ,  style ).  #  Devices.Paths.Path     Method .   Path{T :Real}(origin::Point{2,T}=Point(0.0,0.0), \u03b10::Real=0.0, style0::Style=Trace(1.0))  Convenience constructor for  Path{T}  object.  #  Devices.Paths.Path     Method .   Path{T :Real}(origin::Tuple{T,T})  Convenience constructor for  Path{T}  object.  #  Devices.Paths.Path     Method .   Path{T :Real}(origin::Tuple{T,T}, \u03b10::Real)  Convenience constructor for  Path{T}  object.  #  Devices.Paths.pathlength     Method .   pathlength(p::Path)  Physical length of a path. Note that  length  will return the number of segments in a path, not the physical length.", 
            "title": "Paths"
        }, 
        {
            "location": "/paths/#segments", 
            "text": "#  Devices.Paths.Segment     Type .   abstract Segment{T :Real}  Path segment in the plane. All Segment objects should have the implement the following methods:   length  origin  \u03b10  setorigin!  set\u03b10!  lastangle   #  Devices.Paths.Straight     Type .   type Straight{T :Real}  : Segment{T}\n    l::T\n    origin::Point{2,T}\n    \u03b10::Real\n    f::Function\n    Straight(l, origin, \u03b10) = begin\n        s = new(l, origin, \u03b10)\n        s.f = t- (s.origin+Point(t*s.l*cos(s.\u03b10),t*s.l*sin(s.\u03b10)))\n        s\n    end\nend  A straight line segment is parameterized by its length. It begins at a point  origin  with initial angle  \u03b10 .  The parametric function over  t \u2208 [0,1]  describing the line segment is given by:  t -  origin + Point(t*l*cos(\u03b1),t*l*sin(\u03b1))  #  Devices.Paths.Turn     Type .   type Turn{T :Real}  : Segment{T}\n    \u03b1::Real\n    r::T\n    origin::Point{2,T}\n    \u03b10::Real\n    f::Function\n    Turn(\u03b1, r, origin, \u03b10) = begin\n        s = new(\u03b1, r, origin, \u03b10)\n        s.f = t- begin\n            cen = s.origin + Point(s.r*cos(s.\u03b10+sign(s.\u03b1)*\u03c0/2), s.r*sin(s.\u03b10+sign(s.\u03b1)*\u03c0/2))\n            cen + Point(s.r*cos(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t), s.r*sin(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t))\n        end\n        s\n    end\nend  A circular turn is parameterized by the turn angle  \u03b1  and turning radius  r . It begins at a point  origin  with initial angle  \u03b10 .  The center of the circle is given by:  cen = origin + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))  The parametric function over  t \u2208 [0,1]  describing the turn is given by:  t -  cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))  #  Devices.Paths.CompoundSegment     Type .   type CompoundSegment{T :Real}  : Segment{T}\n    segments::Array{Segment{T},1}\n    f::Function\n\n    CompoundSegment(segments) = begin\n        s = new(segments)\n        s.f = param(s)\n        s\n    end\nend  Consider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes.", 
            "title": "Segments"
        }, 
        {
            "location": "/paths/#styles", 
            "text": "#  Devices.Paths.Style     Type .   abstract Style  How to render a given path segment. All styles should implement the following methods:   distance  extent  paths  width  divs   #  Devices.Paths.Trace     Type .   type Trace  : Style\n    width::Function\n    divs::Int\nend  Simple, single trace.   width::Function : trace width.  divs::Int : number of segments to render. Increase if you see artifacts.   #  Devices.Paths.CPW     Type .   type CPW  : Style\n    trace::Function\n    gap::Function\n    divs::Int\nend  Two adjacent traces can form a coplanar waveguide.   trace::Function : center conductor width.  gap::Function : distance between center conductor edges and ground plane  divs::Int : number of segments to render. Increase if you see artifacts.   May need to be inverted with respect to a ground plane, depending on how the pattern is written.  #  Devices.Paths.CompoundStyle     Type .   type CompoundStyle{T :Real}  : Style\n    segments::Array{Segment{T},1}\n    styles::Array{Style,1}\n    f::Function\n    CompoundStyle(segments, styles) = begin\n        s = new(segments, styles)\n        s.f = param(s)\n        s\n    end\nend  Combines styles together for use with a  CompoundSegment .   segments : Needed for divs function.  styles : Array of styles making up the object.  f : returns tuple of style index and the  t  to use for that style's parametric function.   #  Devices.Paths.DecoratedStyle     Type .   type DecoratedStyle{S :Real}  : Style\n    s::Style\n    ts::AbstractArray{Float64,1}\n    offsets::Array{S,1}\n    dirs::Array{Int,1}\n    cells::Array{ASCIIString,1}\n    DecoratedStyle(s) = begin\n        a = new(s)\n        a.ts = Float64[]\n        a.offsets = S[]\n        a.dirs = Int[]\n        a.cells = ASCIIString[]\n    end\n    DecoratedStyle(s,t,o,r,c) = new(s,t,o,r,c)\nend  Style with decorations, like periodic structures along the path, etc.", 
            "title": "Styles"
        }, 
        {
            "location": "/paths/#path-interrogation", 
            "text": "#  Devices.Paths.direction     Function .   direction(p::Function, t)  For some parameteric function  p(t)\u21a6Point(x(t),y(t)) , returns the angle at which the path is pointing for a given  t .  #  Devices.Paths.pathlength     Function .   pathlength(p::AbstractArray{Segment})  Total physical length of segments.  pathlength(p::Path)  Physical length of a path. Note that  length  will return the number of segments in a path, not the physical length.  #  Devices.Paths.origin     Function .   origin(p::Path)  First point of a path.  origin{T}(s::Segment{T})  Return the first point in a segment (calculated).  #  Devices.Paths.setorigin!     Function .   setorigin!(s::CompoundSegment, p::Point)  Set the origin of a compound segment.  setorigin!(s::Turn, p::Point)  Set the origin of a turn.  setorigin!(s::Straight, p::Point)  Set the origin of a straight segment.  #  Devices.Paths.\u03b10     Function .   \u03b10(p::Path)  First angle of a path.  \u03b10(s::Segment)  Return the first angle in a segment (calculated).  #  Devices.Paths.set\u03b10!     Function .   set\u03b10!(s::CompoundSegment, \u03b10\u2032)  Set the starting angle of a compound segment.  set\u03b10!(s::Turn, \u03b10\u2032)  Set the starting angle of a turn.  set\u03b10!(s::Straight, \u03b10\u2032)  Set the angle of a straight segment.  #  Devices.Paths.lastpoint     Function .   lastpoint(p::Path)  Last point of a path.  lastpoint{T}(s::Segment{T})  Return the last point in a segment (calculated).  #  Devices.Paths.lastangle     Function .   lastangle(p::Path)  Last angle of a path.  lastangle(s::Segment)  Return the last angle in a segment (calculated).  #  Devices.Paths.firststyle     Function .   firststyle(p::Path)  Style of the first segment of a path.  #  Devices.Paths.laststyle     Function .   laststyle(p::Path)  Style of the last segment of a path.", 
            "title": "Path interrogation"
        }, 
        {
            "location": "/paths/#path-building", 
            "text": "#  Base.append!     Method .   append!(p::Path, p\u2032::Path)  Given paths  p  and  p\u2032 , path  p\u2032  is appended to path  p . The origin and initial angle of the first segment from path  p\u2032  is modified to match the last point and last angle of path  p .  #  Devices.Paths.adjust!     Function .   adjust!(p::Path, n::Integer=1)  Adjust a path's parametric functions starting from index  n . Used internally whenever segments are inserted into the path.  #  Devices.Paths.launch!     Function .   launch !( p : :Path ;   extround = 5 ,   trace0 = 300 ,   trace1 = 5 , \n         gap0 = 150 ,   gap1 = 2 .5 ,   flatlen = 250 ,   taperlen = 250 )   Add a launcher to the path. Somewhat intelligent in that the launcher will reverse its orientation depending on if it is at the start or the end of a path.  There are numerous keyword arguments to control the behavior:   extround : Rounding radius of the outermost corners; should be less than  gap0 .  trace0 : Bond pad width.  trace1 : Center trace width of next CPW segment.  gap0 : Gap width adjacent to bond pad.  gap1 : Gap width of next CPW segment.  flatlen : Bond pad length.  taperlen : Length of taper region between bond pad and next CPW segment.   Returns a  Style  object suitable for continuity with the next segment. Ignore the returned style if you are terminating a path.  #  Devices.Paths.meander!     Function .   meander!{T :Real}(p::Path{T}, len, r, straightlen, \u03b1::Real)  Alternate between going straight with length  straightlen  and turning with radius  r  and angle  \u03b1 . Each turn goes the opposite direction of the previous. The total length is  len . Useful for making resonators.  The straight and turn segments are combined into a  CompoundSegment  and appended to the path  p .  #  Devices.Paths.param     Function .   param{T :Real}(c::CompoundSegment{T})  Return a parametric function over the domain [0,1] that represents the compound segment.  #  Devices.Paths.simplify!     Function .   simplify!(p::Path)  All segments of a path are turned into a  CompoundSegment  and all styles of a path are turned into a  CompoundStyle . The idea here is:   Indexing the path becomes more sane when you can combine several path segments into one logical element. A launcher would have several indices in a path unless you could simplify it.  You don't need to think hard about boundaries between straights and turns when you want a continuous styling of a very long path.   #  Devices.Paths.straight!     Function .   straight!(p::Path, l::Real)  Extend a path  p  straight by length  l  in the current direction.  #  Devices.Paths.turn!     Function .   turn!(p::Path, s::ASCIIString, r::Real, sty::Style=laststyle(p))  Turn a path  p  with direction coded by string  s :   \"l\": turn by \u03c0/2 (left)  \"r\": turn by -\u03c0/2 (right)  \"lrlrllrrll\": do those turns in that order   turn!(p::Path, \u03b1::Real, r::Real, sty::Style=laststyle(p))  Turn a path  p  by angle  \u03b1  with a turning radius  r  in the current direction. Positive angle turns left.", 
            "title": "Path building"
        }, 
        {
            "location": "/paths/#interfacing-with-gdspy", 
            "text": "The Python package  gdspy  is used for rendering paths into polygons. Ultimately we intend to remove this dependency.  #  Devices.Paths.distance     Function .   For a style  s  and parameteric argument  t , returns the distance between the centers of parallel paths rendered by gdspy.  #  Devices.Paths.extent     Function .   For a style  s  and parameteric argument  t , returns a distance tangential to the path specifying the lateral extent of the polygons rendered by gdspy.  #  Devices.Paths.paths     Function .   For a style  s  and parameteric argument  t , returns the number of parallel paths rendered by gdspy.  #  Devices.Paths.width     Function .   For a style  s  and parameteric argument  t , returns the width of paths rendered by gdspy.", 
            "title": "Interfacing with gdspy"
        }, 
        {
            "location": "/polygons/", 
            "text": "In this package, any polygon regardless of its concrete representation in memory should be a subtype of \nDevices.AbstractPolygon\n.\n\n\n#\n\n\nDevices.AbstractPolygon\n \n \nType\n.\n\n\n\n\nabstract AbstractPolygon{T}\n\n\n\n\n\nAnything you could call a polygon regardless of the underlying representation. Currently only \nRectangle\n or \nPolygon\n are concrete subtypes.\n\n\n\n\nRectangles\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nType\n.\n\n\n\n\ntype Rectangle{T\n:Real} \n: AbstractPolygon{T}\n    ll::Point{2,T}\n    ur::Point{2,T}\n    properties::Dict{Symbol, Any}\n    Rectangle(ll,ur) = new(ll,ur,Dict{Symbol,Any}())\n    Rectangle(ll,ur,props) = new(ll,ur,props)\nend\n\n\n\n\n\nA rectangle, defined by opposing lower-left and upper-right corner coordinates.\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\n\n\nRectangle\n{\nT\n:\nReal\n}\n(\nll\n:\n:Point\n{\n2\n,\nT\n}\n,\n \nur\n:\n:Point\n{\n2\n,\nT\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for \nRectangle{T}\n objects.\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\n\n\nRectangle{T\n:Real}(ll::Point{2,T}, ur::Point{2,T}, dict)\n\n\n\n\n\nConvenience constructor for \nRectangle{T}\n objects.\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\n\n\nRectangle\n{\nT\n:\nReal\n}\n(\nwidth\n:\n:T\n,\n \nheight\n:\n:T\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConstructs \nRectangle{T}\n objects by specifying the width and height rather than the lower-left and upper-right corners.\n\n\nThe rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of \nRectangle{Int}\n type, this would not be possible if either \nwidth\n or \nheight\n were odd numbers. This definition ensures type stability in the constructor.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds(r::Rectangle)\n\n\n\n\n\nNo-op (just returns \nr\n).\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\n objects.\n\n\n#\n\n\nDevices.center\n \n \nMethod\n.\n\n\n\n\ncenter(r::Rectangle)\n\n\n\n\n\nReturns a Point corresponding to the center of the rectangle.\n\n\n#\n\n\nDevices.Rectangles.height\n \n \nMethod\n.\n\n\n\n\nheight(r::Rectangle)\n\n\n\n\n\nReturn the height of a rectangle.\n\n\n#\n\n\nDevices.Rectangles.isproper\n \n \nMethod\n.\n\n\n\n\nisproper(r::Rectangle)\n\n\n\n\n\nReturns \ntrue\n if the rectangle has a non-zero size and if the upper-right and lower-left corner coordinates \nur\n and \nll\n really are at the upper-right and lower-left. Otherwise, returns \nfalse\n.\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\n\n\nminimum(r::Rectangle)\n\n\n\n\n\nReturns the lower-left corner of a rectangle (Point object).\n\n\nminimum(itr)\n\n\n\n\n\nReturns the smallest element in a collection.\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\n\n\nmaximum(r::Rectangle)\n\n\n\n\n\nReturns the upper-right corner of a rectangle (Point object).\n\n\nmaximum(itr)\n\n\n\n\n\nReturns the largest element in a collection.\n\n\n#\n\n\nDevices.Polygons.points\n \n \nMethod\n.\n\n\n\n\npoints{T\n:Real}(x::Rectangle{T})\n\n\n\n\n\nReturns the array of \nPoint\n objects defining the rectangle.\n\n\n#\n\n\nDevices.Rectangles.width\n \n \nMethod\n.\n\n\n\n\nwidth(r::Rectangle)\n\n\n\n\n\nReturn the width of a rectangle.\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n\n\n+(r::Rectangle, p::Point)\n\n\n\n\n\nTranslate a rectangle by \np\n.\n\n\n\n\nPolygons\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nType\n.\n\n\n\n\ntype Polygon{T\n:Real} \n: AbstractPolygon{T}\n    p::Array{Point{2,T},1}\n    properties::Dict{Symbol, Any}\n    Polygon(x,y) = new(x,y)\n    Polygon(x) = new(x, Dict{Symbol, Any}())\nend\n\n\n\n\n\nPolygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\n\n\nPolygon\n{\nT\n:\nReal\n}\n(\nparr\n:\n:AbstractArray\n{\nPoint\n{\n2\n,\nT\n}\n,\n1\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\n\n\nPolygon{T\n:Real}(parr::AbstractArray{Point{2,T},1}, dict)\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\n\n\nPolygon\n{\nT\n:\nReal\n}\n(\np0\n:\n:Point\n{\n2\n,\nT\n}\n,\n \np1\n:\n:Point\n{\n2\n,\nT\n}\n,\n \np2\n:\n:Point\n{\n2\n,\nT\n}\n,\n\n    \np3\n:\n:Point\n{\n2\n,\nT\n}\n...;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds(p::Polygon)\n\n\n\n\n\nReturn a bounding Rectangle with no properties for polygon \np\n.\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\n objects.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds{T\n:AbstractPolygon}(parr::AbstractArray{T})\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for an array \nparr\n of \nAbstractPolygon\n objects.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\n objects.\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\n\n\nminimum(x::Polygon)\n\n\n\n\n\nReturn the lower-left-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nminimum(itr)\n\n\n\n\n\nReturns the smallest element in a collection.\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\n\n\nmaximum(x::Polygon)\n\n\n\n\n\nReturn the upper-right-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nmaximum(itr)\n\n\n\n\n\nReturns the largest element in a collection.\n\n\n#\n\n\nDevices.Polygons.points\n \n \nMethod\n.\n\n\n\n\npoints(x::Polygon)\n\n\n\n\n\nReturns the array of \nPoint\n objects defining the polygon.\n\n\n\n\nClipping and offsetting\n\n\nAs of now this package's notion of polygons is that there are no \"inner holes.\" Probably it would be helpful if we expanded our definition.\n\n\nFor clipping polygons we use \nGPC\n to get triangle strips which never have holes in them. These are then rendered as polygons individually. An obvious downside is that subsequent offsetting will not work as desired.\n\n\nFor offsetting polygons we use \nClipper\n. Clipper does not seem to support triangle strips so although the clipping is probably superior we cannot use it easily for now.\n\n\n#\n\n\nDevices.Polygons.clip\n \n \nFunction\n.\n\n\n\n\nclip{S\n:Real, T\n:Real}(op::ClipperOp, subject::Polygon{S}, clip::Polygon{T})\n\n\n\n\n\nClip polygon \nsubject\n by polygon \nclip\n using operation \nop\n from the \nClipper library\n. The \nPython wrapper\n over the C++ library is used.\n\n\nValid \nClipperOp\n include \nCT_INTERSECTION\n, \nCT_UNION\n, \nCT_DIFFERENCE\n, \nCT_XOR\n.\n\n\nclip(op::GPCOp, subject::Polygon{Cdouble}, clip::Polygon{Cdouble})\n\n\nUse the GPC clipping library to do polygon manipulations. Valid GPCOp include \nGPC_DIFF\n, \nGPC_INT\n, \nGPC_XOR\n, \nGPC_UNION\n.\n\n\n#\n\n\nDevices.Polygons.offset\n \n \nFunction\n.\n\n\n\n\noffset{S\n:Real}(subject::Polygon{S}, delta::Real,\n        j::ClipperJoin=JT_MITER, e::ClipperEnd=ET_CLOSEDPOLYGON)\n\n\n\n\n\nOffset a polygon \nsubject\n by some amount \ndelta\n using the \nClipper library\n. The \nPython wrapper\n over the C++ library is used.\n\n\nClipperJoin\n parameters are discussed \nhere\n. Valid syntax in this package is: \nJT_SQUARE\n, \nJT_ROUND\n, \nJT_MITER\n.\n\n\nClipperEnd\n parameters are discussed \nhere\n. Valid syntax in this package is: \nET_CLOSEDPOLYGON\n, \nET_CLOSEDLINE\n, \nET_OPENSQUARE\n, \nET_OPENROUND\n, \nET_OPENBUTT\n.\n\n\nTo do: Handle the type parameter of Polygon, which is ignored now.", 
            "title": "Abstract polygons"
        }, 
        {
            "location": "/polygons/#rectangles", 
            "text": "#  Devices.Rectangles.Rectangle     Type .   type Rectangle{T :Real}  : AbstractPolygon{T}\n    ll::Point{2,T}\n    ur::Point{2,T}\n    properties::Dict{Symbol, Any}\n    Rectangle(ll,ur) = new(ll,ur,Dict{Symbol,Any}())\n    Rectangle(ll,ur,props) = new(ll,ur,props)\nend  A rectangle, defined by opposing lower-left and upper-right corner coordinates.  #  Devices.Rectangles.Rectangle     Method .   Rectangle { T : Real } ( ll : :Point { 2 , T } ,   ur : :Point { 2 , T } ;   kwargs ...)   Convenience constructor for  Rectangle{T}  objects.  #  Devices.Rectangles.Rectangle     Method .   Rectangle{T :Real}(ll::Point{2,T}, ur::Point{2,T}, dict)  Convenience constructor for  Rectangle{T}  objects.  #  Devices.Rectangles.Rectangle     Method .   Rectangle { T : Real } ( width : :T ,   height : :T ;   kwargs ...)   Constructs  Rectangle{T}  objects by specifying the width and height rather than the lower-left and upper-right corners.  The rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of  Rectangle{Int}  type, this would not be possible if either  width  or  height  were odd numbers. This definition ensures type stability in the constructor.  #  Devices.bounds     Method .   bounds(r::Rectangle)  No-op (just returns  r ).  bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon  objects.  #  Devices.center     Method .   center(r::Rectangle)  Returns a Point corresponding to the center of the rectangle.  #  Devices.Rectangles.height     Method .   height(r::Rectangle)  Return the height of a rectangle.  #  Devices.Rectangles.isproper     Method .   isproper(r::Rectangle)  Returns  true  if the rectangle has a non-zero size and if the upper-right and lower-left corner coordinates  ur  and  ll  really are at the upper-right and lower-left. Otherwise, returns  false .  #  Base.minimum     Method .   minimum(r::Rectangle)  Returns the lower-left corner of a rectangle (Point object).  minimum(itr)  Returns the smallest element in a collection.  #  Base.maximum     Method .   maximum(r::Rectangle)  Returns the upper-right corner of a rectangle (Point object).  maximum(itr)  Returns the largest element in a collection.  #  Devices.Polygons.points     Method .   points{T :Real}(x::Rectangle{T})  Returns the array of  Point  objects defining the rectangle.  #  Devices.Rectangles.width     Method .   width(r::Rectangle)  Return the width of a rectangle.  #  Base.+     Method .   +(r::Rectangle, p::Point)  Translate a rectangle by  p .", 
            "title": "Rectangles"
        }, 
        {
            "location": "/polygons/#polygons", 
            "text": "#  Devices.Polygons.Polygon     Type .   type Polygon{T :Real}  : AbstractPolygon{T}\n    p::Array{Point{2,T},1}\n    properties::Dict{Symbol, Any}\n    Polygon(x,y) = new(x,y)\n    Polygon(x) = new(x, Dict{Symbol, Any}())\nend  Polygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).  #  Devices.Polygons.Polygon     Method .   Polygon { T : Real } ( parr : :AbstractArray { Point { 2 , T } , 1 } ;   kwargs ...)   Convenience constructor for a  Polygon{T}  object.  #  Devices.Polygons.Polygon     Method .   Polygon{T :Real}(parr::AbstractArray{Point{2,T},1}, dict)  Convenience constructor for a  Polygon{T}  object.  #  Devices.Polygons.Polygon     Method .   Polygon { T : Real } ( p0 : :Point { 2 , T } ,   p1 : :Point { 2 , T } ,   p2 : :Point { 2 , T } , \n     p3 : :Point { 2 , T } ...;   kwargs ...)   Convenience constructor for a  Polygon{T}  object.  #  Devices.bounds     Method .   bounds(p::Polygon)  Return a bounding Rectangle with no properties for polygon  p .  bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon  objects.  #  Devices.bounds     Method .   bounds{T :AbstractPolygon}(parr::AbstractArray{T})  Return a bounding  Rectangle  with no properties for an array  parr  of  AbstractPolygon  objects.  #  Devices.bounds     Method .   bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon  objects.  #  Base.minimum     Method .   minimum(x::Polygon)  Return the lower-left-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  minimum(itr)  Returns the smallest element in a collection.  #  Base.maximum     Method .   maximum(x::Polygon)  Return the upper-right-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  maximum(itr)  Returns the largest element in a collection.  #  Devices.Polygons.points     Method .   points(x::Polygon)  Returns the array of  Point  objects defining the polygon.", 
            "title": "Polygons"
        }, 
        {
            "location": "/polygons/#clipping-and-offsetting", 
            "text": "As of now this package's notion of polygons is that there are no \"inner holes.\" Probably it would be helpful if we expanded our definition.  For clipping polygons we use  GPC  to get triangle strips which never have holes in them. These are then rendered as polygons individually. An obvious downside is that subsequent offsetting will not work as desired.  For offsetting polygons we use  Clipper . Clipper does not seem to support triangle strips so although the clipping is probably superior we cannot use it easily for now.  #  Devices.Polygons.clip     Function .   clip{S :Real, T :Real}(op::ClipperOp, subject::Polygon{S}, clip::Polygon{T})  Clip polygon  subject  by polygon  clip  using operation  op  from the  Clipper library . The  Python wrapper  over the C++ library is used.  Valid  ClipperOp  include  CT_INTERSECTION ,  CT_UNION ,  CT_DIFFERENCE ,  CT_XOR .  clip(op::GPCOp, subject::Polygon{Cdouble}, clip::Polygon{Cdouble})  Use the GPC clipping library to do polygon manipulations. Valid GPCOp include  GPC_DIFF ,  GPC_INT ,  GPC_XOR ,  GPC_UNION .  #  Devices.Polygons.offset     Function .   offset{S :Real}(subject::Polygon{S}, delta::Real,\n        j::ClipperJoin=JT_MITER, e::ClipperEnd=ET_CLOSEDPOLYGON)  Offset a polygon  subject  by some amount  delta  using the  Clipper library . The  Python wrapper  over the C++ library is used.  ClipperJoin  parameters are discussed  here . Valid syntax in this package is:  JT_SQUARE ,  JT_ROUND ,  JT_MITER .  ClipperEnd  parameters are discussed  here . Valid syntax in this package is:  ET_CLOSEDPOLYGON ,  ET_CLOSEDLINE ,  ET_OPENSQUARE ,  ET_OPENROUND ,  ET_OPENBUTT .  To do: Handle the type parameter of Polygon, which is ignored now.", 
            "title": "Clipping and offsetting"
        }, 
        {
            "location": "/cells/", 
            "text": "Cells are used to logically group polygons or references to other cells into a single entity.\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nType\n.\n\n\n\n\ntype Cell{T\n:Real}\n    name::ASCIIString\n    elements::Array{AbstractPolygon{T},1}\n    refs::Array{CellRef,1}\n    create::DateTime\n    function even(str)\n        if mod(length(str),2) == 1\n            str*\n\u0000\n\n        else\n            str\n        end\n    end\n    Cell(x,y,z) = new(even(x), y, z, now())\n    Cell(x,y) = new(even(x), y, CellReference[], now())\n    Cell(x) = new(even(x), AbstractPolygon{T}[], CellReference[], now())\nend\n\n\n\n\n\nA cell has a name and contains polygons and references to \nCellArray\n or \nCellReference\n objects. It also records the time of its own creation. As currently implemented it mirrors the notion of cells in GDS-II files.\n\n\nIn the future, it may make sense to generalize the idea and permit \nPath\n objects within a Cell.\n\n\nTo add elements, push them to \nelements\n field; to add references, push them to \nrefs\n field.\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nMethod\n.\n\n\n\n\nCell(name::AbstractString)\n\n\n\n\n\nConvenience constructor for \nCell{Float64}\n.\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nMethod\n.\n\n\n\n\nCell{T\n:Real}(name::AbstractString, elements::AbstractArray{AbstractPolygon{T},1})\n\n\n\n\n\nConvenience constructor for \nCell{T}\n.\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nMethod\n.\n\n\n\n\nCell{T\n:Real}(name::AbstractString, elements::AbstractArray{AbstractPolygon{T},1},\n    refs::AbstractArray{CellReference,1})\n\n\n\n\n\nConvenience constructor for \nCell{T}\n.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds\n(\ncell\n:\n:Cell\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with no properties around all objects in \ncell\n.\n\n\n#\n\n\nDevices.center\n \n \nMethod\n.\n\n\n\n\ncenter(cell::Cell)\n\n\n\n\n\nConvenience method, equivalent to \ncenter(bounds(cell))\n. Returns the center of the bounding box of the cell.\n\n\n\n\nReferenced and arrayed cells\n\n\nCells can be arrayed or referenced within other cells for efficiency or to reduce display complexity.\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nType\n.\n\n\n\n\ntype CellArray{S,T} \n: CellRef{S,T}\n    cell::S\n    origin::Point{2,T}\n    deltacol::Point{2,T}\n    deltarow::Point{2,T}\n    col::Int\n    row::Int\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend\n\n\n\n\n\nArray of \ncell\n starting at \norigin\n with \nrow\n rows and \ncol\n columns, spanned by vectors \ndeltacol\n and \ndeltarow\n. Optional x-reflection \nxrefl\n, magnification factor \nmag\n, and rotation angle \nrot\n in degrees are for the array as a whole.\n\n\nThe type variable \nS\n is to avoid circular definitions with \nCell\n.\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nMethod\n.\n\n\n\n\nCellArray\n{\nT\n:\nReal\n}\n(\nx\n:\n:Cell\n,\n \norigin\n:\n:Point\n{\n2\n,\nT\n}\n,\n \ndc\n:\n:Point\n{\n2\n,\nT\n}\n,\n \ndr\n:\n:Point\n{\n2\n,\nT\n}\n,\n\n    \nc\n:\n:Integer\n,\n \nr\n:\n:Integer\n;\n \nxrefl\n=\nfalse\n,\n \nmag\n=\n1\n.0\n,\n \nrot\n=\n0\n.0\n)\n\n\n\n\n\n\nConstruct a \nCellArray{typeof(x),T}\n object, with \nxrefl\n, \nmag\n, and \nrot\n as keyword arguments (x-reflection, magnification factor, rotation in degrees).\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nMethod\n.\n\n\n\n\nCellArray\n{\nT\n:\nReal\n}\n(\nx\n:\n:Cell\n,\n \nc\n:\n:Range\n{\nT\n}\n,\n \nr\n:\n:Range\n{\nT\n}\n;\n\n    \nxrefl\n=\nfalse\n,\n \nmag\n=\n1\n.0\n,\n \nrot\n=\n0\n.0\n)\n\n\n\n\n\n\nConstruct a \nCellArray{typeof(x), T}\n based on ranges (probably \nLinSpace\n or \nFloatRange\n). \nc\n specifies column coordinates and \nr\n for the rows. Pairs from \nc\n and \nr\n specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting \nCellArray\n's bounding box; some care is required.\n\n\nxrefl\n, \nmag\n, and \nrot\n are keyword arguments (x-reflection, magnification factor, rotation in degrees).\n\n\n#\n\n\nDevices.Cells.CellReference\n \n \nType\n.\n\n\n\n\ntype CellReference{S,T} \n: CellRef{S,T}\n    cell::S\n    origin::Point{2,T}\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend\n\n\n\n\n\nReference to a \ncell\n positioned at \norigin\n, with optional x-reflection \nxrefl\n, magnification factor \nmag\n, and rotation angle \nrot\n in degrees.\n\n\nThe type variable \nS\n is to avoid circular definitions with \nCell\n.\n\n\n#\n\n\nDevices.Cells.CellReference\n \n \nMethod\n.\n\n\n\n\nCellReference\n{\nT\n:\nReal\n}\n(\nx\n:\n:Cell\n,\n \ny\n:\n:Point\n{\n2\n,\nT\n}\n;\n \nxrefl\n=\nfalse\n,\n \nmag\n=\n1\n.0\n,\n \nrot\n=\n0\n.0\n)\n\n\n\n\n\n\nConvenience constructor for \nCellReference{typeof(x), T}\n.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds\n(\nref\n:\n:CellArray\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with properties specified by \nkwargs...\n around all objects in \nref\n. The bounding box respects reflection, rotation, and magnification specified by \nref\n.\n\n\nPlease do rewrite this method when feeling motivated... it is very inefficient.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds\n(\nref\n:\n:CellReference\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with properties specified by \nkwargs...\n around all objects in \nref\n. The bounding box respects reflection, rotation, and magnification specified by \nref\n.\n\n\n\n\nResolving references\n\n\nWhen saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.\n\n\n#\n\n\nDevices.Cells.traverse!\n \n \nFunction\n.\n\n\n\n\ntraverse!(a::AbstractArray, c::Cell, level=1)\n\n\n\n\n\nGiven a cell, recursively traverse its references for other cells and add to array \na\n some tuples: \n(level, c)\n. \nlevel\n corresponds to how deep the cell was found, and \nc\n is the found cell.\n\n\n#\n\n\nDevices.Cells.order!\n \n \nFunction\n.\n\n\n\n\norder!(a::AbstractArray)\n\n\n\n\n\nGiven an array of tuples like that coming out of \ntraverse!\n, we sort by the \nlevel\n, strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).\n\n\nFor performance reasons, this function modifies \na\n but what you want is the returned result array.", 
            "title": "Cells"
        }, 
        {
            "location": "/cells/#referenced-and-arrayed-cells", 
            "text": "Cells can be arrayed or referenced within other cells for efficiency or to reduce display complexity.  #  Devices.Cells.CellArray     Type .   type CellArray{S,T}  : CellRef{S,T}\n    cell::S\n    origin::Point{2,T}\n    deltacol::Point{2,T}\n    deltarow::Point{2,T}\n    col::Int\n    row::Int\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend  Array of  cell  starting at  origin  with  row  rows and  col  columns, spanned by vectors  deltacol  and  deltarow . Optional x-reflection  xrefl , magnification factor  mag , and rotation angle  rot  in degrees are for the array as a whole.  The type variable  S  is to avoid circular definitions with  Cell .  #  Devices.Cells.CellArray     Method .   CellArray { T : Real } ( x : :Cell ,   origin : :Point { 2 , T } ,   dc : :Point { 2 , T } ,   dr : :Point { 2 , T } , \n     c : :Integer ,   r : :Integer ;   xrefl = false ,   mag = 1 .0 ,   rot = 0 .0 )   Construct a  CellArray{typeof(x),T}  object, with  xrefl ,  mag , and  rot  as keyword arguments (x-reflection, magnification factor, rotation in degrees).  #  Devices.Cells.CellArray     Method .   CellArray { T : Real } ( x : :Cell ,   c : :Range { T } ,   r : :Range { T } ; \n     xrefl = false ,   mag = 1 .0 ,   rot = 0 .0 )   Construct a  CellArray{typeof(x), T}  based on ranges (probably  LinSpace  or  FloatRange ).  c  specifies column coordinates and  r  for the rows. Pairs from  c  and  r  specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting  CellArray 's bounding box; some care is required.  xrefl ,  mag , and  rot  are keyword arguments (x-reflection, magnification factor, rotation in degrees).  #  Devices.Cells.CellReference     Type .   type CellReference{S,T}  : CellRef{S,T}\n    cell::S\n    origin::Point{2,T}\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend  Reference to a  cell  positioned at  origin , with optional x-reflection  xrefl , magnification factor  mag , and rotation angle  rot  in degrees.  The type variable  S  is to avoid circular definitions with  Cell .  #  Devices.Cells.CellReference     Method .   CellReference { T : Real } ( x : :Cell ,   y : :Point { 2 , T } ;   xrefl = false ,   mag = 1 .0 ,   rot = 0 .0 )   Convenience constructor for  CellReference{typeof(x), T} .  #  Devices.bounds     Method .   bounds ( ref : :CellArray ;   kwargs ...)   Returns a  Rectangle  bounding box with properties specified by  kwargs...  around all objects in  ref . The bounding box respects reflection, rotation, and magnification specified by  ref .  Please do rewrite this method when feeling motivated... it is very inefficient.  #  Devices.bounds     Method .   bounds ( ref : :CellReference ;   kwargs ...)   Returns a  Rectangle  bounding box with properties specified by  kwargs...  around all objects in  ref . The bounding box respects reflection, rotation, and magnification specified by  ref .", 
            "title": "Referenced and arrayed cells"
        }, 
        {
            "location": "/cells/#resolving-references", 
            "text": "When saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.  #  Devices.Cells.traverse!     Function .   traverse!(a::AbstractArray, c::Cell, level=1)  Given a cell, recursively traverse its references for other cells and add to array  a  some tuples:  (level, c) .  level  corresponds to how deep the cell was found, and  c  is the found cell.  #  Devices.Cells.order!     Function .   order!(a::AbstractArray)  Given an array of tuples like that coming out of  traverse! , we sort by the  level , strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).  For performance reasons, this function modifies  a  but what you want is the returned result array.", 
            "title": "Resolving references"
        }, 
        {
            "location": "/render/", 
            "text": "Rendering\n\n\n#\n\n\nDevices.render!\n \n \nFunction\n.\n\n\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nsegment\n:\n:Paths\n.Segment\n,\n \ns\n:\n:Paths\n.Style\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a \nsegment\n with style \ns\n to cell \nc\n.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nsegment\n:\n:Paths\n.Segment\n,\n \ns\n:\n:Paths\n.DecoratedStyle\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a \nsegment\n with decorated style \ns\n to cell \nc\n. This method draws the decorations before the path itself is drawn.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \np\n:\n:Path\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a path \np\n to a cell \nc\n.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Polygon\n,\n \ns\n:\n:Polygons\n.Style\n=\nPolygons\n.Plain\n();\n \nkwargs\n...)\n\n\n\n\n\n\nRender a polygon \nr\n to cell \nc\n, defaulting to plain styling.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \ns\n:\n:Rectangles\n.Style\n=\nRectangles\n.Plain\n();\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rectangle \nr\n to cell \nc\n, defaulting to plain styling.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \ns\n:\n:Rectangles\n.Rounded\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rounded rectangle \nr\n to cell \nc\n. This is accomplished by rendering a path around the outside of a (smaller than requested) solid rectangle. The bounding box of \nr\n is preserved.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \n:\n:Rectangles\n.Plain\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rectangle \nr\n to cell \nc\n with plain styling.\n\n\n\n\nSaving patterns\n\n\nTo save a pattern, make sure you are \nusing FileIO\n.\n\n\n#\n\n\nFileIO.save\n \n \nMethod\n.\n\n\n\n\nsave\n(:\n:Union\n{\nAbstractString\n,\nIO\n}\n,\n \ncell0\n:\n:Cell\n,\n \ncell\n:\n:Cell\n...)\n\n\n\nsave\n(\nf\n:\n:File\n{\nformat\nGDS\n}\n,\n \ncell0\n:\n:Cell\n,\n \ncell\n:\n:Cell\n...;\n\n\nname\n=\nGDSIILIB\n,\n \nprecision\n=\n1e-9\n,\n \nunit\n=\n1e-6\n,\n \nmodify\n=\nnow\n(),\n \nacc\n=\nnow\n(),\n\n\nverbose\n=\nfalse\n)\n`\n\n\n\n\n\n\nThis bottom method is implicitly called when you use the convenient syntax of the top method: \nsave(\"/path/to/my.gds\", cells_i_want_to_save...)\n\n\nThe \nname\n keyword argument is used for the internal library name of the GDS-II file and is probably inconsequential for modern workflows.\n\n\nThe \nverbose\n keyword argument allows you to monitor the output of \ntraverse!\n and \norder!\n if something funny is happening while saving.", 
            "title": "Rendering / saving"
        }, 
        {
            "location": "/render/#rendering", 
            "text": "#  Devices.render!     Function .   render !( c : :Cell ,   segment : :Paths .Segment ,   s : :Paths .Style ;   kwargs ...)   Render a  segment  with style  s  to cell  c .  render !( c : :Cell ,   segment : :Paths .Segment ,   s : :Paths .DecoratedStyle ;   kwargs ...)   Render a  segment  with decorated style  s  to cell  c . This method draws the decorations before the path itself is drawn.  render !( c : :Cell ,   p : :Path ;   kwargs ...)   Render a path  p  to a cell  c .  render !( c : :Cell ,   r : :Polygon ,   s : :Polygons .Style = Polygons .Plain ();   kwargs ...)   Render a polygon  r  to cell  c , defaulting to plain styling.  render !( c : :Cell ,   r : :Rectangle ,   s : :Rectangles .Style = Rectangles .Plain ();   kwargs ...)   Render a rectangle  r  to cell  c , defaulting to plain styling.  render !( c : :Cell ,   r : :Rectangle ,   s : :Rectangles .Rounded ;   kwargs ...)   Render a rounded rectangle  r  to cell  c . This is accomplished by rendering a path around the outside of a (smaller than requested) solid rectangle. The bounding box of  r  is preserved.  render !( c : :Cell ,   r : :Rectangle ,   : :Rectangles .Plain ;   kwargs ...)   Render a rectangle  r  to cell  c  with plain styling.", 
            "title": "Rendering"
        }, 
        {
            "location": "/render/#saving-patterns", 
            "text": "To save a pattern, make sure you are  using FileIO .  #  FileIO.save     Method .   save (: :Union { AbstractString , IO } ,   cell0 : :Cell ,   cell : :Cell ...)  save ( f : :File { format GDS } ,   cell0 : :Cell ,   cell : :Cell ...;  name = GDSIILIB ,   precision = 1e-9 ,   unit = 1e-6 ,   modify = now (),   acc = now (),  verbose = false ) `   This bottom method is implicitly called when you use the convenient syntax of the top method:  save(\"/path/to/my.gds\", cells_i_want_to_save...)  The  name  keyword argument is used for the internal library name of the GDS-II file and is probably inconsequential for modern workflows.  The  verbose  keyword argument allows you to monitor the output of  traverse!  and  order!  if something funny is happening while saving.", 
            "title": "Saving patterns"
        }, 
        {
            "location": "/idx/", 
            "text": "Index\n\n\n\n\nDevices.Cells.Cell\n\n\nDevices.Cells.Cell\n\n\nDevices.Cells.Cell\n\n\nDevices.Cells.Cell\n\n\nDevices.Cells.CellArray\n\n\nDevices.Cells.CellArray\n\n\nDevices.Cells.CellArray\n\n\nDevices.Cells.CellReference\n\n\nDevices.Cells.CellReference\n\n\nDevices.Cells.order!\n\n\nDevices.Cells.traverse!\n\n\nDevices.bounds\n\n\nDevices.bounds\n\n\nDevices.bounds\n\n\nDevices.center\n\n\nBase.append!\n\n\nDevices.Paths.CPW\n\n\nDevices.Paths.CompoundSegment\n\n\nDevices.Paths.CompoundStyle\n\n\nDevices.Paths.DecoratedStyle\n\n\nDevices.Paths.Path\n\n\nDevices.Paths.Path\n\n\nDevices.Paths.Path\n\n\nDevices.Paths.Path\n\n\nDevices.Paths.Segment\n\n\nDevices.Paths.Straight\n\n\nDevices.Paths.Style\n\n\nDevices.Paths.Trace\n\n\nDevices.Paths.Turn\n\n\nDevices.Paths.adjust!\n\n\nDevices.Paths.direction\n\n\nDevices.Paths.distance\n\n\nDevices.Paths.extent\n\n\nDevices.Paths.firststyle\n\n\nDevices.Paths.lastangle\n\n\nDevices.Paths.lastpoint\n\n\nDevices.Paths.laststyle\n\n\nDevices.Paths.launch!\n\n\nDevices.Paths.meander!\n\n\nDevices.Paths.origin\n\n\nDevices.Paths.param\n\n\nDevices.Paths.pathlength\n\n\nDevices.Paths.pathlength\n\n\nDevices.Paths.paths\n\n\nDevices.Paths.setorigin!\n\n\nDevices.Paths.set\u03b10!\n\n\nDevices.Paths.simplify!\n\n\nDevices.Paths.straight!\n\n\nDevices.Paths.turn!\n\n\nDevices.Paths.width\n\n\nDevices.Paths.\u03b10\n\n\nDevices.Points.getx\n\n\nDevices.Points.gety\n\n\nBase.+\n\n\nBase.maximum\n\n\nBase.maximum\n\n\nBase.minimum\n\n\nBase.minimum\n\n\nDevices.AbstractPolygon\n\n\nDevices.Polygons.Polygon\n\n\nDevices.Polygons.Polygon\n\n\nDevices.Polygons.Polygon\n\n\nDevices.Polygons.Polygon\n\n\nDevices.Polygons.clip\n\n\nDevices.Polygons.offset\n\n\nDevices.Polygons.points\n\n\nDevices.Polygons.points\n\n\nDevices.Rectangles.Rectangle\n\n\nDevices.Rectangles.Rectangle\n\n\nDevices.Rectangles.Rectangle\n\n\nDevices.Rectangles.Rectangle\n\n\nDevices.Rectangles.height\n\n\nDevices.Rectangles.isproper\n\n\nDevices.Rectangles.width\n\n\nDevices.bounds\n\n\nDevices.bounds\n\n\nDevices.bounds\n\n\nDevices.bounds\n\n\nDevices.center\n\n\nDevices.render!\n\n\nFileIO.save", 
            "title": "Index"
        }, 
        {
            "location": "/idx/#index", 
            "text": "Devices.Cells.Cell  Devices.Cells.Cell  Devices.Cells.Cell  Devices.Cells.Cell  Devices.Cells.CellArray  Devices.Cells.CellArray  Devices.Cells.CellArray  Devices.Cells.CellReference  Devices.Cells.CellReference  Devices.Cells.order!  Devices.Cells.traverse!  Devices.bounds  Devices.bounds  Devices.bounds  Devices.center  Base.append!  Devices.Paths.CPW  Devices.Paths.CompoundSegment  Devices.Paths.CompoundStyle  Devices.Paths.DecoratedStyle  Devices.Paths.Path  Devices.Paths.Path  Devices.Paths.Path  Devices.Paths.Path  Devices.Paths.Segment  Devices.Paths.Straight  Devices.Paths.Style  Devices.Paths.Trace  Devices.Paths.Turn  Devices.Paths.adjust!  Devices.Paths.direction  Devices.Paths.distance  Devices.Paths.extent  Devices.Paths.firststyle  Devices.Paths.lastangle  Devices.Paths.lastpoint  Devices.Paths.laststyle  Devices.Paths.launch!  Devices.Paths.meander!  Devices.Paths.origin  Devices.Paths.param  Devices.Paths.pathlength  Devices.Paths.pathlength  Devices.Paths.paths  Devices.Paths.setorigin!  Devices.Paths.set\u03b10!  Devices.Paths.simplify!  Devices.Paths.straight!  Devices.Paths.turn!  Devices.Paths.width  Devices.Paths.\u03b10  Devices.Points.getx  Devices.Points.gety  Base.+  Base.maximum  Base.maximum  Base.minimum  Base.minimum  Devices.AbstractPolygon  Devices.Polygons.Polygon  Devices.Polygons.Polygon  Devices.Polygons.Polygon  Devices.Polygons.Polygon  Devices.Polygons.clip  Devices.Polygons.offset  Devices.Polygons.points  Devices.Polygons.points  Devices.Rectangles.Rectangle  Devices.Rectangles.Rectangle  Devices.Rectangles.Rectangle  Devices.Rectangles.Rectangle  Devices.Rectangles.height  Devices.Rectangles.isproper  Devices.Rectangles.width  Devices.bounds  Devices.bounds  Devices.bounds  Devices.bounds  Devices.center  Devices.render!  FileIO.save", 
            "title": "Index"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The Devices.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}