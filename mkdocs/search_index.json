{
    "docs": [
        {
            "location": "/", 
            "text": "Devices.jl\n\n\nA \nJulia\n package for designing CAD files for superconducting devices.\n\n\n\n\nInstallation\n\n\n\n\n\n\nInstall \ngdspy\n, which is currently used as the backend for rendering GDS files and previewing them. Ensure that it is accessible from the Python installation that PyCall.jl is using.\n\n\n\n\n\n\nPkg.clone(\"https://github.com/ajkeller34/Devices.jl.git\")\n\n\n\n\n\n\n\n\nQuick start\n\n\nusing Devices\n\np = Path()\nstyle = launch!(p)\nstraight!(p,500,style)\nturn!(p,\u03c0/2,150)\nstraight!(p,500)\nlaunch!(p)\nrender(p)\nview()", 
            "title": "Home"
        }, 
        {
            "location": "/#devicesjl", 
            "text": "A  Julia  package for designing CAD files for superconducting devices.", 
            "title": "Devices.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install  gdspy , which is currently used as the backend for rendering GDS files and previewing them. Ensure that it is accessible from the Python installation that PyCall.jl is using.    Pkg.clone(\"https://github.com/ajkeller34/Devices.jl.git\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "using Devices\n\np = Path()\nstyle = launch!(p)\nstraight!(p,500,style)\nturn!(p,\u03c0/2,150)\nstraight!(p,500)\nlaunch!(p)\nrender(p)\nview()", 
            "title": "Quick start"
        }, 
        {
            "location": "/api/", 
            "text": "Index\n\n\n\n\nDevices.Paths.CPW\n\n\nDevices.Paths.Straight\n\n\nDevices.Paths.Style\n\n\nDevices.Paths.Trace\n\n\nDevices.Paths.Turn\n\n\nDevices.Paths.distance\n\n\nDevices.Paths.extent\n\n\nDevices.Paths.firstangle\n\n\nDevices.Paths.firstpoint\n\n\nDevices.Paths.firststyle\n\n\nDevices.Paths.lastangle\n\n\nDevices.Paths.lastpoint\n\n\nDevices.Paths.laststyle\n\n\nDevices.Paths.launch!\n\n\nDevices.Paths.paths\n\n\nDevices.Paths.preview\n\n\nDevices.Paths.straight!\n\n\nDevices.Paths.turn!\n\n\nDevices.Paths.width\n\n\nDevices.Points.Point\n\n\nDevices.Points.getx\n\n\nDevices.Points.gety\n\n\nDevices.view\n\n\n\n\n\n\nPoints\n\n\nPoints are implemented using the abstract type \nFixedVectorNoTuple\n from \nFixedSizeArrays.jl\n. This permits a fast, efficient representation of coordinates in the plane, which would not be true using ordinary \nArray\n objects, which can have variable length. Additionally, unlike \nTuple\n objects, we can add points together, simplifying many function definitions.\n\n\nTo interface with gdspy, we simply convert the \nPoint\n object to a \nTuple\n and let \nPyCall.jl\n figure out what to do.\n\n\n#\n\n\nDevices.Points.Point\n \n \nType\n.\n\n\n\n\nimmutable Point{T\n:Real} \n: FixedVectorNoTuple{2,T}\n\n\nA point in the plane (Cartesian coordinates).\n\n\n#\n\n\nDevices.Points.getx\n \n \nFunction\n.\n\n\n\n\ngetx(p::Point)\n\n\nGet the x-coordinate of a point.\n\n\n#\n\n\nDevices.Points.gety\n \n \nFunction\n.\n\n\n\n\ngety(p::Point)\n\n\nGet the y-coordinate of a point.\n\n\n\n\nPaths\n\n\n\n\nSegments\n\n\n#\n\n\nDevices.Paths.Straight\n \n \nType\n.\n\n\n\n\ntype Straight{T\n:Real} \n: Segment{T}\n\n\nA straight line segment is parameterized by its length. It begins at a point \norigin\n with initial angle \n\u03b10\n.\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the line segment is given by:\n\n\nt -\n origin + Point(t*l*cos(\u03b1),t*l*sin(\u03b1))\n\n\n#\n\n\nDevices.Paths.Turn\n \n \nType\n.\n\n\n\n\ntype Turn{T\n:Real} \n: Segment{T}\n\n\nA circular turn is parameterized by the turn angle \n\u03b1\n and turning radius \nr\n. It begins at a point \norigin\n with initial angle \n\u03b10\n.\n\n\nThe center of the circle is given by:\n\n\ncen = origin + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the turn is given by:\n\n\nt -\n cen + Point(r*cos(\u03b10-\u03c0/2+\u03b1*t), r*sin(\u03b10-\u03c0/2+\u03b1*t))\n\n\n\n\nStyles\n\n\n#\n\n\nDevices.Paths.Style\n \n \nType\n.\n\n\n\n\nabstract Style\n\n\nHow to render a given path segment.\n\n\n#\n\n\nDevices.Paths.Trace\n \n \nType\n.\n\n\n\n\ntype Trace \n: Style\n\n\nSimple, single trace.\n\n\n\n\nwidth::Function\n: trace width.\n\n\ndivs::Int\n: number of segments to render. Increase if you see artifacts.\n\n\n\n\n#\n\n\nDevices.Paths.CPW\n \n \nType\n.\n\n\n\n\ntype CPW \n: Style\n\n\nTwo adjacent traces can form a coplanar waveguide.\n\n\n\n\ntrace::Function\n: center conductor width.\n\n\ngap::Function\n: distance between center conductor edges and ground plane\n\n\ndivs::Int\n: number of segments to render. Increase if you see artifacts.\n\n\n\n\nMay need to be inverted with respect to a ground plane, depending on how the pattern is written.\n\n\n\n\nPath interrogation\n\n\n#\n\n\nDevices.Paths.firstpoint\n \n \nFunction\n.\n\n\n\n\nfirstpoint(p::Path)\n\n\nFirst point of a path.\n\n\nfirstpoint{T}(s::Segment{T})\n\n\nReturn the first point in a segment.\n\n\n#\n\n\nDevices.Paths.lastpoint\n \n \nFunction\n.\n\n\n\n\nlastpoint(p::Path)\n\n\nLast point of a path.\n\n\nlastpoint{T}(s::Segment{T})\n\n\nReturn the last point in a segment.\n\n\n#\n\n\nDevices.Paths.firstangle\n \n \nFunction\n.\n\n\n\n\nfirstangle(p::Path)\n\n\nFirst angle of a path.\n\n\n#\n\n\nDevices.Paths.lastangle\n \n \nFunction\n.\n\n\n\n\nlastangle(p::Path)\n\n\nLast angle of a path.\n\n\n#\n\n\nDevices.Paths.firststyle\n \n \nFunction\n.\n\n\n\n\nfirststyle(p::Path)\n\n\nStyle of the first segment of a path.\n\n\n#\n\n\nDevices.Paths.laststyle\n \n \nFunction\n.\n\n\n\n\nlaststyle(p::Path)\n\n\nStyle of the last segment of a path.\n\n\n\n\nPath building\n\n\n#\n\n\nDevices.Paths.launch!\n \n \nFunction\n.\n\n\n\n\nlaunch!(p::Path; extround=5, trace0=300, trace1=5,         gap0=150, gap1=2.5, flatlen=250, taperlen=250)\n\n\nAdd a launcher to the path. Somewhat intelligent in that the launcher will reverse it's orientation depending on if it is at the start or the end of a path.\n\n\nThere are numerous keyword arguments to control the behavior:\n\n\n\n\nextround\n: Rounding radius of the outermost corners; should be less than \ngap0\n.\n\n\ntrace0\n: Bond pad width.\n\n\ntrace1\n: Center trace width of next CPW segment.\n\n\ngap0\n: Gap width adjacent to bond pad.\n\n\ngap1\n: Gap width of next CPW segment.\n\n\nflatlen\n: Bond pad length.\n\n\ntaperlen\n: Length of taper region between bond pad and next CPW segment.\n\n\n\n\nReturns a \nStyle\n object suitable for continuity with the next segment. Ignore the returned style if you are terminating a path.\n\n\n#\n\n\nDevices.Paths.straight!\n \n \nFunction\n.\n\n\n\n\nstraight!(p::Path, l::Real)\n\n\nExtend a path \np\n straight by length \nl\n in the current direction.\n\n\n#\n\n\nDevices.Paths.turn!\n \n \nFunction\n.\n\n\n\n\nturn!(p::Path, \u03b1::Real, r::Real, sty::Style=laststyle(p))\n\n\nTurn a path \np\n by angle \n\u03b1\n with a turning radius \nr\n at unit velocity in the path direction. Positive angle turns left.\n\n\n\n\nRendering\n\n\n#\n\n\nDevices.Paths.preview\n \n \nFunction\n.\n\n\n\n\npreview(p::Path, pts::Integer=100; kw...)\n\n\nPlot the path using \nPlots.jl\n, enforcing square aspect ratio of the x and y limits. If using the UnicodePlots backend, pass keyword argument \nsize=(60,30)\n or a similar ratio for display with proper aspect ratio.\n\n\nNo styling of the path is shown, only the abstract path in the plane. A launcher will look no different than a straight line, for instance.\n\n\nWe reserve \nxlims\n and \nylims\n keyword arguments but all other valid Plots.jl keyword arguments are passed along to the plotting function.\n\n\n#\n\n\nDevices.view\n \n \nFunction\n.\n\n\n\n\nLaunch a LayoutViewer window.\n\n\n\n\nInterfacing with gdspy\n\n\n#\n\n\nDevices.Paths.distance\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the distance between the centers of parallel paths rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.extent\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns a distance tangential to the path specifying the lateral extent of the polygons rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.paths\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the number of parallel paths rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.width\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the width of paths rendered by gdspy.", 
            "title": "API"
        }, 
        {
            "location": "/api/#index", 
            "text": "Devices.Paths.CPW  Devices.Paths.Straight  Devices.Paths.Style  Devices.Paths.Trace  Devices.Paths.Turn  Devices.Paths.distance  Devices.Paths.extent  Devices.Paths.firstangle  Devices.Paths.firstpoint  Devices.Paths.firststyle  Devices.Paths.lastangle  Devices.Paths.lastpoint  Devices.Paths.laststyle  Devices.Paths.launch!  Devices.Paths.paths  Devices.Paths.preview  Devices.Paths.straight!  Devices.Paths.turn!  Devices.Paths.width  Devices.Points.Point  Devices.Points.getx  Devices.Points.gety  Devices.view", 
            "title": "Index"
        }, 
        {
            "location": "/api/#points", 
            "text": "Points are implemented using the abstract type  FixedVectorNoTuple  from  FixedSizeArrays.jl . This permits a fast, efficient representation of coordinates in the plane, which would not be true using ordinary  Array  objects, which can have variable length. Additionally, unlike  Tuple  objects, we can add points together, simplifying many function definitions.  To interface with gdspy, we simply convert the  Point  object to a  Tuple  and let  PyCall.jl  figure out what to do.  #  Devices.Points.Point     Type .   immutable Point{T :Real}  : FixedVectorNoTuple{2,T}  A point in the plane (Cartesian coordinates).  #  Devices.Points.getx     Function .   getx(p::Point)  Get the x-coordinate of a point.  #  Devices.Points.gety     Function .   gety(p::Point)  Get the y-coordinate of a point.", 
            "title": "Points"
        }, 
        {
            "location": "/api/#paths", 
            "text": "", 
            "title": "Paths"
        }, 
        {
            "location": "/api/#segments", 
            "text": "#  Devices.Paths.Straight     Type .   type Straight{T :Real}  : Segment{T}  A straight line segment is parameterized by its length. It begins at a point  origin  with initial angle  \u03b10 .  The parametric function over  t \u2208 [0,1]  describing the line segment is given by:  t -  origin + Point(t*l*cos(\u03b1),t*l*sin(\u03b1))  #  Devices.Paths.Turn     Type .   type Turn{T :Real}  : Segment{T}  A circular turn is parameterized by the turn angle  \u03b1  and turning radius  r . It begins at a point  origin  with initial angle  \u03b10 .  The center of the circle is given by:  cen = origin + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))  The parametric function over  t \u2208 [0,1]  describing the turn is given by:  t -  cen + Point(r*cos(\u03b10-\u03c0/2+\u03b1*t), r*sin(\u03b10-\u03c0/2+\u03b1*t))", 
            "title": "Segments"
        }, 
        {
            "location": "/api/#styles", 
            "text": "#  Devices.Paths.Style     Type .   abstract Style  How to render a given path segment.  #  Devices.Paths.Trace     Type .   type Trace  : Style  Simple, single trace.   width::Function : trace width.  divs::Int : number of segments to render. Increase if you see artifacts.   #  Devices.Paths.CPW     Type .   type CPW  : Style  Two adjacent traces can form a coplanar waveguide.   trace::Function : center conductor width.  gap::Function : distance between center conductor edges and ground plane  divs::Int : number of segments to render. Increase if you see artifacts.   May need to be inverted with respect to a ground plane, depending on how the pattern is written.", 
            "title": "Styles"
        }, 
        {
            "location": "/api/#path-interrogation", 
            "text": "#  Devices.Paths.firstpoint     Function .   firstpoint(p::Path)  First point of a path.  firstpoint{T}(s::Segment{T})  Return the first point in a segment.  #  Devices.Paths.lastpoint     Function .   lastpoint(p::Path)  Last point of a path.  lastpoint{T}(s::Segment{T})  Return the last point in a segment.  #  Devices.Paths.firstangle     Function .   firstangle(p::Path)  First angle of a path.  #  Devices.Paths.lastangle     Function .   lastangle(p::Path)  Last angle of a path.  #  Devices.Paths.firststyle     Function .   firststyle(p::Path)  Style of the first segment of a path.  #  Devices.Paths.laststyle     Function .   laststyle(p::Path)  Style of the last segment of a path.", 
            "title": "Path interrogation"
        }, 
        {
            "location": "/api/#path-building", 
            "text": "#  Devices.Paths.launch!     Function .   launch!(p::Path; extround=5, trace0=300, trace1=5,         gap0=150, gap1=2.5, flatlen=250, taperlen=250)  Add a launcher to the path. Somewhat intelligent in that the launcher will reverse it's orientation depending on if it is at the start or the end of a path.  There are numerous keyword arguments to control the behavior:   extround : Rounding radius of the outermost corners; should be less than  gap0 .  trace0 : Bond pad width.  trace1 : Center trace width of next CPW segment.  gap0 : Gap width adjacent to bond pad.  gap1 : Gap width of next CPW segment.  flatlen : Bond pad length.  taperlen : Length of taper region between bond pad and next CPW segment.   Returns a  Style  object suitable for continuity with the next segment. Ignore the returned style if you are terminating a path.  #  Devices.Paths.straight!     Function .   straight!(p::Path, l::Real)  Extend a path  p  straight by length  l  in the current direction.  #  Devices.Paths.turn!     Function .   turn!(p::Path, \u03b1::Real, r::Real, sty::Style=laststyle(p))  Turn a path  p  by angle  \u03b1  with a turning radius  r  at unit velocity in the path direction. Positive angle turns left.", 
            "title": "Path building"
        }, 
        {
            "location": "/api/#rendering", 
            "text": "#  Devices.Paths.preview     Function .   preview(p::Path, pts::Integer=100; kw...)  Plot the path using  Plots.jl , enforcing square aspect ratio of the x and y limits. If using the UnicodePlots backend, pass keyword argument  size=(60,30)  or a similar ratio for display with proper aspect ratio.  No styling of the path is shown, only the abstract path in the plane. A launcher will look no different than a straight line, for instance.  We reserve  xlims  and  ylims  keyword arguments but all other valid Plots.jl keyword arguments are passed along to the plotting function.  #  Devices.view     Function .   Launch a LayoutViewer window.", 
            "title": "Rendering"
        }, 
        {
            "location": "/api/#interfacing-with-gdspy", 
            "text": "#  Devices.Paths.distance     Function .   For a style  s  and parameteric argument  t , returns the distance between the centers of parallel paths rendered by gdspy.  #  Devices.Paths.extent     Function .   For a style  s  and parameteric argument  t , returns a distance tangential to the path specifying the lateral extent of the polygons rendered by gdspy.  #  Devices.Paths.paths     Function .   For a style  s  and parameteric argument  t , returns the number of parallel paths rendered by gdspy.  #  Devices.Paths.width     Function .   For a style  s  and parameteric argument  t , returns the width of paths rendered by gdspy.", 
            "title": "Interfacing with gdspy"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The Devices.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}