{
    "docs": [
        {
            "location": "/", 
            "text": "Devices.jl\n\n\nA \nJulia\n package for designing CAD files for superconducting devices.\n\n\n\n\nInstallation\n\n\n\n\nInstall Python packages\n\n\n\n\nInstall \ngdspy\n, which is currently used only for rendering paths into polygons: \npip install gdspy\n. Ensure that it is accessible from the Python installation that PyCall.jl is using. If the installation fails, it may be failing because it is trying to compile the Clipper library. We will use a Julia package for Clipper anyway. Try installing an older version of gdspy that does not have the Clipper library: \npip install 'gdspy==0.7.1' --force-reinstall\n.\n\n\nInstall \npyqrcode\n, which is used for generating QR codes: \npip install pyqrcode\n.\n\n\n\n\n\n\nInstall Julia packages\n\n\nWe use a custom version of the Clipper package, which we will need for making polygons compatible with GDS files.\n\n\n\n\nPkg.clone(\"https://github.com/PainterQubits/Clipper.jl.git\")\n\n\nPkg.checkout(\"Clipper\", \"pointinpoly\")\n\n\n\n\nYou will need to build the package to compile shared library / DLL files. This should just work on Mac OS X, and should also work on Windows provided you install \nVisual Studio\n and ensure that \nvcvarsall.bat\n and \ncl.exe\n are in your account's PATH variable. Probably these are located in: \nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\n and \nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\n, respectively.\n\n\n\n\nPkg.build(\"Clipper\")\n\n\nPkg.clone(\"https://github.com/PainterQubits/Devices.jl.git\")\n\n\n\n\nFinally, for convenience you may want to have \nDevices\n load up every time you open Julia. You can do this by adding the following to a file \n.juliarc.jl\n in the directory returned by \nhomedir()\n:\n\n\nusing Devices, Unitful, FileIO\nusing Unitful: \u03bcm, \u00b5m, nm, \u00b0, rad\n\n\n\n\n\nYou can then create and save CAD files with unit support as soon as Julia starts up. This will also enable the unqualified use of microns, nanometers, degrees, and radians (any other units you want to use will still need to be imported from Unitful).\n\n\n\n\nQuick start\n\n\nusing Devices, FileIO\n\np = Path()\nstyle = launch!(p)\nstraight!(p,500,style)\nturn!(p,\u03c0/2,150)\nstraight!(p,500)\nlaunch!(p)\nc = Cell(\nmain\n)\nrender!(c, p)\nsave(\ntest.gds\n, c)\n\n\n\n\n\n\n\nTroubleshooting\n\n\n\n\nIf you cannot save the GDS file, try deleting any file that happens to be at the target path. A corrupted file at the target path may prevent saving.\n\n\nDecorated styles should not become part of compound styles, for now. Avoid this by decorating / attaching cell references at the end.", 
            "title": "Home"
        }, 
        {
            "location": "/#devicesjl", 
            "text": "A  Julia  package for designing CAD files for superconducting devices.", 
            "title": "Devices.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/#install-python-packages", 
            "text": "Install  gdspy , which is currently used only for rendering paths into polygons:  pip install gdspy . Ensure that it is accessible from the Python installation that PyCall.jl is using. If the installation fails, it may be failing because it is trying to compile the Clipper library. We will use a Julia package for Clipper anyway. Try installing an older version of gdspy that does not have the Clipper library:  pip install 'gdspy==0.7.1' --force-reinstall .  Install  pyqrcode , which is used for generating QR codes:  pip install pyqrcode .", 
            "title": "Install Python packages"
        }, 
        {
            "location": "/#install-julia-packages", 
            "text": "We use a custom version of the Clipper package, which we will need for making polygons compatible with GDS files.   Pkg.clone(\"https://github.com/PainterQubits/Clipper.jl.git\")  Pkg.checkout(\"Clipper\", \"pointinpoly\")   You will need to build the package to compile shared library / DLL files. This should just work on Mac OS X, and should also work on Windows provided you install  Visual Studio  and ensure that  vcvarsall.bat  and  cl.exe  are in your account's PATH variable. Probably these are located in:  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC  and  C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin , respectively.   Pkg.build(\"Clipper\")  Pkg.clone(\"https://github.com/PainterQubits/Devices.jl.git\")   Finally, for convenience you may want to have  Devices  load up every time you open Julia. You can do this by adding the following to a file  .juliarc.jl  in the directory returned by  homedir() :  using Devices, Unitful, FileIO\nusing Unitful: \u03bcm, \u00b5m, nm, \u00b0, rad  You can then create and save CAD files with unit support as soon as Julia starts up. This will also enable the unqualified use of microns, nanometers, degrees, and radians (any other units you want to use will still need to be imported from Unitful).", 
            "title": "Install Julia packages"
        }, 
        {
            "location": "/#quick-start", 
            "text": "using Devices, FileIO\n\np = Path()\nstyle = launch!(p)\nstraight!(p,500,style)\nturn!(p,\u03c0/2,150)\nstraight!(p,500)\nlaunch!(p)\nc = Cell( main )\nrender!(c, p)\nsave( test.gds , c)", 
            "title": "Quick start"
        }, 
        {
            "location": "/#troubleshooting", 
            "text": "If you cannot save the GDS file, try deleting any file that happens to be at the target path. A corrupted file at the target path may prevent saving.  Decorated styles should not become part of compound styles, for now. Avoid this by decorating / attaching cell references at the end.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/points/", 
            "text": "Summary\n\n\nPoints live in a Cartesian coordinate system with \nReal\n or \nUnitful.Length\n coordinates:\n\n\njulia\n \nPoint\n(\n1\n,\n1\n)\n\n\n2-element Devices.Points.Point{Int64}:\n\n\n 1\n\n\n 1\n\n\n\njulia\n \nPoint\n(\n1.0\n,\n1.0\n)\n\n\n2-element Devices.Points.Point{Float64}:\n\n\n 1.0\n\n\n 1.0\n\n\n\njulia\n \nPoint\n(\n1.0\nu\n\u03bcm\n,\n \n1.0\nu\n\u03bcm\n)\n\n\n2-element Devices.Points.Point{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{\u03bcm}}}:\n\n\n 1.0 \u03bcm\n\n\n 1.0 \u03bcm\n\n\n\n\n\n\nIf a point has \nReal\n coordinates, the absence of a unit is interpreted to mean \n\u03bcm\n whenever the geometry is saved to a GDS format, but until then it is just considered to be a pure number. Therefore you cannot mix and match \nReal\n and \nLength\n coordinates:\n\n\njulia\n \nPoint\n(\n1.0\nu\n\u03bcm\n,\n \n1.0\n)\n\n\nERROR: Cannot use `Point` with this combination of types.\n\n\n\n\n\n\nYou can add Points together or scale them:\n\n\njulia\n \n3\n*\nPoint\n(\n1\n,\n1\n)\n+\nPoint\n(\n1\n,\n2\n)\n\n\n2-element Devices.Points.Point{Int64}:\n\n\n 4\n\n\n 5\n\n\n\n\n\n\nYou can also do affine transformations by composing any number of \nTranslation\n and \nRotation\ns, which will return a callable object representing the transformation. You can type the following Unicode symbols with \n\\degree\n and \n\\circ\n tab-completions in the Julia REPL or using the Atom package \nlatex-completions\n.\n\n\njulia\n \naff\n \n=\n \nRotation\n(\n90\n\u00b0\n)\n \n\u2218\n \nTranslation\n(\nPoint\n(\n1\n,\n2\n))\n\n\nAffineMap([6.12323e-17 -1.0; 1.0 6.12323e-17], (-2.0,1.0000000000000002))\n\n\n\njulia\n \naff\n(\nPoint\n(\n0\n,\n0\n))\n\n\n2-element Devices.Points.Point{Float64}:\n\n\n -2.0\n\n\n  1.0\n\n\n\n\n\n\n\n\nAPI\n\n\n#\n\n\nDevices.Coordinate\n \n \nConstant\n.\n\n\ntypealias Coordinate Union{Real,Length}\n\n\n\n\n\nType alias for numeric types suitable for coordinate systems.\n\n\nsource\n\n\n#\n\n\nDevices.Points.Point\n \n \nType\n.\n\n\nimmutable Point{T} \n: FieldVector{T}\n    x::T\n    y::T\nend\n\n\n\n\n\n2D Cartesian coordinate in the plane.\n\n\nsource\n\n\n#\n\n\nDevices.Points.getx\n \n \nFunction\n.\n\n\ngetx(p::Point)\n\n\n\n\n\nGet the x-coordinate of a point. You can also use \np.x\n or \np[1]\n.\n\n\nsource\n\n\n#\n\n\nDevices.Points.gety\n \n \nFunction\n.\n\n\ngety(p::Point)\n\n\n\n\n\nGet the y-coordinate of a point. You can also use \np.y\n or \np[2]\n.\n\n\nsource\n\n\n#\n\n\nDevices.Points.lowerleft\n \n \nFunction\n.\n\n\nlowerleft{T}(A::AbstractArray{Point{T}})\n\n\n\n\n\nReturns the lower-left \nPoint\n of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in \nA\n.\n\n\nExample:\n\n\njulia\n \nlowerleft\n([\nPoint\n(\n2\n,\n0\n),\nPoint\n(\n1\n,\n1\n),\nPoint\n(\n0\n,\n2\n),\nPoint\n(\n-\n1\n,\n3\n)])\n\n\n2-element Devices.Points.Point{Int64}:\n\n\n -1\n\n\n  0\n\n\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Points.upperright\n \n \nFunction\n.\n\n\nupperright{T}(A::AbstractArray{Point{T}})\n\n\n\n\n\nReturns the upper-right \nPoint\n of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in \nA\n.\n\n\nExample:\n\n\njulia\n \nupperright\n([\nPoint\n(\n2\n,\n0\n),\nPoint\n(\n1\n,\n1\n),\nPoint\n(\n0\n,\n2\n),\nPoint\n(\n-\n1\n,\n3\n)])\n\n\n2-element Devices.Points.Point{Int64}:\n\n\n 2\n\n\n 3\n\n\n\n\n\n\nsource\n\n\n\n\nImplementation details\n\n\nPoints are implemented using the abstract type \nFieldVector\n from \nStaticArrays.jl\n. This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike \nTuple\n objects, we can add points together, simplifying many function definitions.\n\n\nTo interface with gdspy, we simply convert the \nPoint\n object to a \nTuple\n and let \nPyCall.jl\n figure out what to do.", 
            "title": "Points"
        }, 
        {
            "location": "/points/#summary", 
            "text": "Points live in a Cartesian coordinate system with  Real  or  Unitful.Length  coordinates:  julia   Point ( 1 , 1 )  2-element Devices.Points.Point{Int64}:   1   1  julia   Point ( 1.0 , 1.0 )  2-element Devices.Points.Point{Float64}:   1.0   1.0  julia   Point ( 1.0 u \u03bcm ,   1.0 u \u03bcm )  2-element Devices.Points.Point{Quantity{Float64, Dimensions:{\ud835\udc0b}, Units:{\u03bcm}}}:   1.0 \u03bcm   1.0 \u03bcm   If a point has  Real  coordinates, the absence of a unit is interpreted to mean  \u03bcm  whenever the geometry is saved to a GDS format, but until then it is just considered to be a pure number. Therefore you cannot mix and match  Real  and  Length  coordinates:  julia   Point ( 1.0 u \u03bcm ,   1.0 )  ERROR: Cannot use `Point` with this combination of types.   You can add Points together or scale them:  julia   3 * Point ( 1 , 1 ) + Point ( 1 , 2 )  2-element Devices.Points.Point{Int64}:   4   5   You can also do affine transformations by composing any number of  Translation  and  Rotation s, which will return a callable object representing the transformation. You can type the following Unicode symbols with  \\degree  and  \\circ  tab-completions in the Julia REPL or using the Atom package  latex-completions .  julia   aff   =   Rotation ( 90 \u00b0 )   \u2218   Translation ( Point ( 1 , 2 ))  AffineMap([6.12323e-17 -1.0; 1.0 6.12323e-17], (-2.0,1.0000000000000002))  julia   aff ( Point ( 0 , 0 ))  2-element Devices.Points.Point{Float64}:   -2.0    1.0", 
            "title": "Summary"
        }, 
        {
            "location": "/points/#api", 
            "text": "#  Devices.Coordinate     Constant .  typealias Coordinate Union{Real,Length}  Type alias for numeric types suitable for coordinate systems.  source  #  Devices.Points.Point     Type .  immutable Point{T}  : FieldVector{T}\n    x::T\n    y::T\nend  2D Cartesian coordinate in the plane.  source  #  Devices.Points.getx     Function .  getx(p::Point)  Get the x-coordinate of a point. You can also use  p.x  or  p[1] .  source  #  Devices.Points.gety     Function .  gety(p::Point)  Get the y-coordinate of a point. You can also use  p.y  or  p[2] .  source  #  Devices.Points.lowerleft     Function .  lowerleft{T}(A::AbstractArray{Point{T}})  Returns the lower-left  Point  of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in  A .  Example:  julia   lowerleft ([ Point ( 2 , 0 ), Point ( 1 , 1 ), Point ( 0 , 2 ), Point ( - 1 , 3 )])  2-element Devices.Points.Point{Int64}:   -1    0   source  #  Devices.Points.upperright     Function .  upperright{T}(A::AbstractArray{Point{T}})  Returns the upper-right  Point  of the smallest bounding rectangle (with sides parallel to the x- and y-axes) that contains all points in  A .  Example:  julia   upperright ([ Point ( 2 , 0 ), Point ( 1 , 1 ), Point ( 0 , 2 ), Point ( - 1 , 3 )])  2-element Devices.Points.Point{Int64}:   2   3   source", 
            "title": "API"
        }, 
        {
            "location": "/points/#implementation-details", 
            "text": "Points are implemented using the abstract type  FieldVector  from  StaticArrays.jl . This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike  Tuple  objects, we can add points together, simplifying many function definitions.  To interface with gdspy, we simply convert the  Point  object to a  Tuple  and let  PyCall.jl  figure out what to do.", 
            "title": "Implementation details"
        }, 
        {
            "location": "/polygons/", 
            "text": "Abstract polygons\n\n\nIn this package, any polygon regardless of its concrete representation in memory should be a subtype of \nDevices.AbstractPolygon\n.\n\n\n#\n\n\nDevices.AbstractPolygon\n \n \nType\n.\n\n\nabstract AbstractPolygon{T\n:Coordinate}\n\n\n\n\n\nAnything you could call a polygon regardless of the underlying representation. Currently only \nRectangle\n or \nPolygon\n are concrete subtypes, but one could imagine further subtypes to represent specific shapes that appear in highly optimized pattern formats. Examples include the OASIS format (which has 25 implementations of trapezoids) or e-beam lithography pattern files like the Raith GPF format.\n\n\nsource\n\n\n\n\nAffine transformations\n\n\nThe mechanism for affine transformations is largely provided by the \nCoordinateTransformations.jl\n package. For convenience, the documentation for \nTranslation\n and \ncompose\n is reproduced below from that package. We implement our own 2D rotations.\n\n\nAn example of how to use affine transformations with polygons:\n\n\njulia\n \nr\n \n=\n \nRectangle\n(\n1\n,\n1\n)\n\n\nDevices.Rectangles.Rectangle{Int64}((0,0),(1,1),Dict{Symbol,Any}())\n\n\n\njulia\n \ntrans\n \n=\n \nTranslation\n(\n10\n,\n10\n)\n\n\nTranslation(10,10)\n\n\n\njulia\n \ntrans\n \n=\n \nRotation\n(\n90\n\u00b0\n)\n \n\u2218\n \ntrans\n\n\nAffineMap([6.12323e-17 -1.0; 1.0 6.12323e-17], [-10.0,10.0])\n\n\n\njulia\n \ntrans\n(\nr\n)\n\n\nDevices.Polygons.Polygon{Float64}(Devices.Points.Point{Float64}[(-10.0,10.0),(-10.0,11.0),(-11.0,11.0),(-11.0,10.0)],Dict{Symbol,Any}())\n\n\n\n\n\n\n#\n\n\nCoordinateTransformations.compose\n \n \nFunction\n.\n\n\ncompose(trans1, trans2)\ntrans1 \u2218 trans2\n\n\n\n\n\nTake two transformations and create a new transformation that is equivalent to successively applying \ntrans2\n to the coordinate, and then \ntrans1\n. By default will create a \nComposedTransformation\n, however this method can be overloaded for efficiency (e.g. two affine transformations naturally compose to a single affine transformation).\n\n\nsource\n\n\n#\n\n\nDevices.Points.Rotation\n \n \nFunction\n.\n\n\nRotation(\u0398)\n\n\n\n\n\nConstruct a rotation about the origin. Units accepted (no units \u21d2 radians).\n\n\nsource\n\n\n#\n\n\nCoordinateTransformations.Translation\n \n \nType\n.\n\n\nTranslation(v) \n: AbstractAffineMap\nTranslation(dx, dy)       (2D)\nTranslation(dx, dy, dz)   (3D)\n\n\n\n\n\nConstruct the \nTranslation\n transformation for translating Cartesian points by an offset \nv = (dx, dy, ...)\n\n\nsource\n\n\n\n\nClipping\n\n\n#\n\n\nDevices.Polygons.clip\n \n \nFunction\n.\n\n\nclip\n{\nS\n:\nCoordinate\n,\n \nT\n:\nCoordinate\n}\n(\nop\n:\n:Clipper\n.ClipType\n,\n\n    \ns\n:\n:AbstractPolygon\n{\nS\n}\n,\n \nc\n:\n:AbstractPolygon\n{\nT\n}\n;\n\n    \npfs\n:\n:Clipper\n.PolyFillType\n=\nClipper\n.PolyFillTypeEvenOdd\n,\n\n    \npfc\n:\n:Clipper\n.PolyFillType\n=\nClipper\n.PolyFillTypeEvenOdd\n)\n\n\n\n\n\n\nUsing the \nClipper\n library and the \nClipper.jl\n wrapper, perform polygon clipping. The first argument must be one of the following types :\n\n\n\n\nClipper.ClipTypeDifference\n\n\nClipper.ClipTypeIntersection\n\n\nClipper.ClipTypeUnion\n\n\nClipper.ClipTypeXor\n\n\n\n\nNote that these are types; you should not follow them with \n()\n. The second and third arguments are \nAbstractPolygon\n objects. Keyword arguments \npfs\n and \npfc\n specify polygon fill rules (see the \nClipper\n docs\n for further information). These arguments may include:\n\n\n\n\nClipper.PolyFillTypeNegative\n\n\nClipper.PolyFillTypePositive\n\n\nClipper.PolyFillTypeEvenOdd\n\n\nClipper.PolyFillTypeNonZero\n\n\n\n\nsource\n\n\nclip\n{\nS\n:\nAbstractPolygon\n,\n \nT\n:\nAbstractPolygon\n}\n(\nop\n:\n:Clipper\n.ClipType\n,\n\n    \ns\n:\n:AbstractVector\n{\nS\n}\n,\n \nc\n:\n:AbstractVector\n{\nT\n}\n;\n\n    \npfs\n:\n:Clipper\n.PolyFillType\n=\nClipper\n.PolyFillTypeEvenOdd\n,\n\n    \npfc\n:\n:Clipper\n.PolyFillType\n=\nClipper\n.PolyFillTypeEvenOdd\n)\n\n\n\n\n\n\nPerform polygon clipping. The first argument must be as listed above. The second and third arguments are arrays (vectors) of \nAbstractPolygon\ns. Keyword arguments are explained above.\n\n\nsource\n\n\nclip\n{\nT\n:\nPolygon\n}\n(\nop\n:\n:Clipper\n.ClipType\n,\n\n    \ns\n:\n:AbstractVector\n{\nT\n}\n,\n \nc\n:\n:AbstractVector\n{\nT\n}\n;\n\n    \npfs\n:\n:Clipper\n.PolyFillType\n=\nClipper\n.PolyFillTypeEvenOdd\n,\n\n    \npfc\n:\n:Clipper\n.PolyFillType\n=\nClipper\n.PolyFillTypeEvenOdd\n)\n\n\n\n\n\n\nPerform polygon clipping. The first argument must be as listed above. The second and third arguments are identically-typed arrays (vectors) of \nPolygon{T}\n objects. Keyword arguments are explained above.\n\n\nsource\n\n\n\n\nOffsetting\n\n\n#\n\n\nDevices.Polygons.offset\n \n \nFunction\n.\n\n\noffset\n{\nS\n:\nCoordinate\n}\n(\ns\n:\n:AbstractPolygon\n{\nS\n}\n,\n \ndelta\n:\n:Coordinate\n;\n\n    \nj\n:\n:Clipper\n.JoinType\n=\nClipper\n.JoinTypeMiter\n,\n\n    \ne\n:\n:Clipper\n.EndType\n=\nClipper\n.EndTypeClosedPolygon\n)\n\n\n\n\n\n\nUsing the \nClipper\n library and the \nClipper.jl\n wrapper, perform polygon offsetting.\n\n\nThe first argument should be an \nAbstractPolygon\n. The second argument is how much to offset the polygon. Keyword arguments include a \njoin type\n:\n\n\n\n\nClipper.JoinTypeMiter\n\n\nClipper.JoinTypeRound\n\n\nClipper.JoinTypeSquare\n\n\n\n\nand also an \nend type\n:\n\n\n\n\nClipper.EndTypeClosedPolygon\n\n\nClipper.EndTypeClosedLine\n\n\nClipper.EndTypeOpenSquare\n\n\nClipper.EndTypeOpenRound\n\n\nClipper.EndTypeOpenButt\n\n\n\n\nsource\n\n\noffset\n{\nS\n:\nAbstractPolygon\n}\n(\nsubject\n:\n:AbstractVector\n{\nS\n}\n,\n \ndelta\n:\n:Coordinate\n;\n\n    \nj\n:\n:Clipper\n.JoinType\n=\nClipper\n.JoinTypeMiter\n,\n\n    \ne\n:\n:Clipper\n.EndType\n=\nClipper\n.EndTypeClosedPolygon\n)\n\n\n\n\n\n\nPerform polygon offsetting. The first argument is an array (vector) of \nAbstractPolygon\ns. The second argument is how much to offset the polygon. Keyword arguments explained above.\n\n\nsource\n\n\noffset\n{\nS\n:\nPolygon\n}\n(\ns\n:\n:AbstractVector\n{\nS\n}\n,\n \ndelta\n:\n:Coordinate\n;\n\n    \nj\n:\n:Clipper\n.JoinType\n=\nClipper\n.JoinTypeMiter\n,\n\n    \ne\n:\n:Clipper\n.EndType\n=\nClipper\n.EndTypeClosedPolygon\n)\n\n\n\n\n\n\nPerform polygon offsetting. The first argument is an array (vector) of \nPolygon\ns. The second argument is how much to offset the polygon. Keyword arguments explained above.\n\n\nsource\n\n\n\n\nRectangle API\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nType\n.\n\n\ntype Rectangle{T} \n: AbstractPolygon{T}\n    ll::Point{T}\n    ur::Point{T}\n    properties::Dict{Symbol, Any}\n    Rectangle(ll,ur) = Rectangle(ll,ur,Dict{Symbol,Any}())\n    function Rectangle(a,b,props)\n        # Ensure ll is lower-left, ur is upper-right.\n        ll = Point(a.\n=b) .* a + Point(b.\n=a) .* b\n        ur = Point(a.\n=b) .* b + Point(b.\n=a) .* a\n        new(ll,ur,props)\n    end\nend\n\n\n\n\n\nA rectangle, defined by opposing lower-left and upper-right corner coordinates. Lower-left and upper-right are guaranteed to be such by the inner constructor.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\nRectangle\n(\nll\n:\n:Point\n,\n \nur\n:\n:Point\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for \nRectangle\n objects.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\nRectangle(width, height, kwargs...)\n\n\n\n\n\nConstructs \nRectangle\n objects by specifying the width and height rather than the lower-left and upper-right corners.\n\n\nThe rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of \nRectangle{Int}\n type, this would not be possible if either \nwidth\n or \nheight\n were odd numbers. This definition ensures type stability in the constructor.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(r::Rectangle)\n\n\n\n\n\nNo-op (just returns \nr\n).\n\n\nsource\n\n\n#\n\n\nDevices.center\n \n \nMethod\n.\n\n\ncenter(r::Rectangle)\n\n\n\n\n\nReturns a \nPoint\n corresponding to the center of the rectangle.\n\n\nsource\n\n\n#\n\n\nDevices.centered\n \n \nMethod\n.\n\n\ncentered(r::Rectangle)\n\n\n\n\n\nCenters a copy of \nr\n, with promoted coordinates if necessary. This function will not throw an \nInexactError()\n, even if \nr\n had integer coordinates.\n\n\nsource\n\n\n#\n\n\nDevices.centered!\n \n \nMethod\n.\n\n\ncentered!(r::Rectangle)\n\n\n\n\n\nCenters a rectangle. Will throw an \nInexactError()\n if the rectangle cannot be centered with integer coordinates.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.height\n \n \nMethod\n.\n\n\nheight(r::Rectangle)\n\n\n\n\n\nReturn the height of a rectangle.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.isproper\n \n \nMethod\n.\n\n\nisproper(r::Rectangle)\n\n\n\n\n\nReturns \ntrue\n if the rectangle has a non-zero size. Otherwise, returns \nfalse\n. Note that the upper-right and lower-left corners are enforced to be the \nur\n and \nll\n fields of a \nRectangle\n by the inner constructor.\n\n\nsource\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\nminimum(r::Rectangle)\n\n\n\n\n\nReturns the lower-left corner of a rectangle (Point object).\n\n\nsource\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\nmaximum(r::Rectangle)\n\n\n\n\n\nReturns the upper-right corner of a rectangle (Point object).\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.points\n \n \nMethod\n.\n\n\npoints{T}(x::Rectangle{T})\n\n\n\n\n\nReturns the array of \nPoint\n objects defining the rectangle.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.width\n \n \nMethod\n.\n\n\nwidth(r::Rectangle)\n\n\n\n\n\nReturn the width of a rectangle.\n\n\nsource\n\n\n#\n\n\nBase.:+\n \n \nMethod\n.\n\n\n+(r::Rectangle, p::Point)\n\n\n\n\n\nTranslate a rectangle by \np\n.\n\n\nsource\n\n\n\n\nPolygon API\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nType\n.\n\n\ntype Polygon{T} \n: AbstractPolygon{T}\n    p::Array{Point{T},1}\n    properties::Dict{Symbol, Any}\n    Polygon(x,y) = new(x,y)\n    Polygon(x) = new(x, Dict{Symbol, Any}())\nend\n\n\n\n\n\nPolygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\nPolygon\n{\nT\n}\n(\nparr\n:\n:AbstractArray\n{\nPoint\n{\nT\n}\n,\n1\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\nPolygon\n(\np0\n:\n:Point\n,\n \np1\n:\n:Point\n,\n \np2\n:\n:Point\n,\n \np3\n:\n:Point\n...;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(p::Polygon)\n\n\n\n\n\nReturn a bounding Rectangle with no properties for polygon \np\n.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds{T\n:AbstractPolygon}(parr::AbstractArray{T})\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for an array \nparr\n of \nAbstractPolygon\n objects.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\n objects.\n\n\nsource\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\nminimum(x::Polygon)\n\n\n\n\n\nReturn the lower-left-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nsource\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\nmaximum(x::Polygon)\n\n\n\n\n\nReturn the upper-right-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nsource\n\n\n#\n\n\nDevices.Polygons.points\n \n \nMethod\n.\n\n\npoints(x::Polygon)\n\n\n\n\n\nReturns the array of \nPoint\n objects defining the polygon.\n\n\nsource", 
            "title": "Abstract polygons"
        }, 
        {
            "location": "/polygons/#abstract-polygons", 
            "text": "In this package, any polygon regardless of its concrete representation in memory should be a subtype of  Devices.AbstractPolygon .  #  Devices.AbstractPolygon     Type .  abstract AbstractPolygon{T :Coordinate}  Anything you could call a polygon regardless of the underlying representation. Currently only  Rectangle  or  Polygon  are concrete subtypes, but one could imagine further subtypes to represent specific shapes that appear in highly optimized pattern formats. Examples include the OASIS format (which has 25 implementations of trapezoids) or e-beam lithography pattern files like the Raith GPF format.  source", 
            "title": "Abstract polygons"
        }, 
        {
            "location": "/polygons/#affine-transformations", 
            "text": "The mechanism for affine transformations is largely provided by the  CoordinateTransformations.jl  package. For convenience, the documentation for  Translation  and  compose  is reproduced below from that package. We implement our own 2D rotations.  An example of how to use affine transformations with polygons:  julia   r   =   Rectangle ( 1 , 1 )  Devices.Rectangles.Rectangle{Int64}((0,0),(1,1),Dict{Symbol,Any}())  julia   trans   =   Translation ( 10 , 10 )  Translation(10,10)  julia   trans   =   Rotation ( 90 \u00b0 )   \u2218   trans  AffineMap([6.12323e-17 -1.0; 1.0 6.12323e-17], [-10.0,10.0])  julia   trans ( r )  Devices.Polygons.Polygon{Float64}(Devices.Points.Point{Float64}[(-10.0,10.0),(-10.0,11.0),(-11.0,11.0),(-11.0,10.0)],Dict{Symbol,Any}())   #  CoordinateTransformations.compose     Function .  compose(trans1, trans2)\ntrans1 \u2218 trans2  Take two transformations and create a new transformation that is equivalent to successively applying  trans2  to the coordinate, and then  trans1 . By default will create a  ComposedTransformation , however this method can be overloaded for efficiency (e.g. two affine transformations naturally compose to a single affine transformation).  source  #  Devices.Points.Rotation     Function .  Rotation(\u0398)  Construct a rotation about the origin. Units accepted (no units \u21d2 radians).  source  #  CoordinateTransformations.Translation     Type .  Translation(v)  : AbstractAffineMap\nTranslation(dx, dy)       (2D)\nTranslation(dx, dy, dz)   (3D)  Construct the  Translation  transformation for translating Cartesian points by an offset  v = (dx, dy, ...)  source", 
            "title": "Affine transformations"
        }, 
        {
            "location": "/polygons/#clipping", 
            "text": "#  Devices.Polygons.clip     Function .  clip { S : Coordinate ,   T : Coordinate } ( op : :Clipper .ClipType , \n     s : :AbstractPolygon { S } ,   c : :AbstractPolygon { T } ; \n     pfs : :Clipper .PolyFillType = Clipper .PolyFillTypeEvenOdd , \n     pfc : :Clipper .PolyFillType = Clipper .PolyFillTypeEvenOdd )   Using the  Clipper  library and the  Clipper.jl  wrapper, perform polygon clipping. The first argument must be one of the following types :   Clipper.ClipTypeDifference  Clipper.ClipTypeIntersection  Clipper.ClipTypeUnion  Clipper.ClipTypeXor   Note that these are types; you should not follow them with  () . The second and third arguments are  AbstractPolygon  objects. Keyword arguments  pfs  and  pfc  specify polygon fill rules (see the  Clipper  docs  for further information). These arguments may include:   Clipper.PolyFillTypeNegative  Clipper.PolyFillTypePositive  Clipper.PolyFillTypeEvenOdd  Clipper.PolyFillTypeNonZero   source  clip { S : AbstractPolygon ,   T : AbstractPolygon } ( op : :Clipper .ClipType , \n     s : :AbstractVector { S } ,   c : :AbstractVector { T } ; \n     pfs : :Clipper .PolyFillType = Clipper .PolyFillTypeEvenOdd , \n     pfc : :Clipper .PolyFillType = Clipper .PolyFillTypeEvenOdd )   Perform polygon clipping. The first argument must be as listed above. The second and third arguments are arrays (vectors) of  AbstractPolygon s. Keyword arguments are explained above.  source  clip { T : Polygon } ( op : :Clipper .ClipType , \n     s : :AbstractVector { T } ,   c : :AbstractVector { T } ; \n     pfs : :Clipper .PolyFillType = Clipper .PolyFillTypeEvenOdd , \n     pfc : :Clipper .PolyFillType = Clipper .PolyFillTypeEvenOdd )   Perform polygon clipping. The first argument must be as listed above. The second and third arguments are identically-typed arrays (vectors) of  Polygon{T}  objects. Keyword arguments are explained above.  source", 
            "title": "Clipping"
        }, 
        {
            "location": "/polygons/#offsetting", 
            "text": "#  Devices.Polygons.offset     Function .  offset { S : Coordinate } ( s : :AbstractPolygon { S } ,   delta : :Coordinate ; \n     j : :Clipper .JoinType = Clipper .JoinTypeMiter , \n     e : :Clipper .EndType = Clipper .EndTypeClosedPolygon )   Using the  Clipper  library and the  Clipper.jl  wrapper, perform polygon offsetting.  The first argument should be an  AbstractPolygon . The second argument is how much to offset the polygon. Keyword arguments include a  join type :   Clipper.JoinTypeMiter  Clipper.JoinTypeRound  Clipper.JoinTypeSquare   and also an  end type :   Clipper.EndTypeClosedPolygon  Clipper.EndTypeClosedLine  Clipper.EndTypeOpenSquare  Clipper.EndTypeOpenRound  Clipper.EndTypeOpenButt   source  offset { S : AbstractPolygon } ( subject : :AbstractVector { S } ,   delta : :Coordinate ; \n     j : :Clipper .JoinType = Clipper .JoinTypeMiter , \n     e : :Clipper .EndType = Clipper .EndTypeClosedPolygon )   Perform polygon offsetting. The first argument is an array (vector) of  AbstractPolygon s. The second argument is how much to offset the polygon. Keyword arguments explained above.  source  offset { S : Polygon } ( s : :AbstractVector { S } ,   delta : :Coordinate ; \n     j : :Clipper .JoinType = Clipper .JoinTypeMiter , \n     e : :Clipper .EndType = Clipper .EndTypeClosedPolygon )   Perform polygon offsetting. The first argument is an array (vector) of  Polygon s. The second argument is how much to offset the polygon. Keyword arguments explained above.  source", 
            "title": "Offsetting"
        }, 
        {
            "location": "/polygons/#rectangle-api", 
            "text": "#  Devices.Rectangles.Rectangle     Type .  type Rectangle{T}  : AbstractPolygon{T}\n    ll::Point{T}\n    ur::Point{T}\n    properties::Dict{Symbol, Any}\n    Rectangle(ll,ur) = Rectangle(ll,ur,Dict{Symbol,Any}())\n    function Rectangle(a,b,props)\n        # Ensure ll is lower-left, ur is upper-right.\n        ll = Point(a. =b) .* a + Point(b. =a) .* b\n        ur = Point(a. =b) .* b + Point(b. =a) .* a\n        new(ll,ur,props)\n    end\nend  A rectangle, defined by opposing lower-left and upper-right corner coordinates. Lower-left and upper-right are guaranteed to be such by the inner constructor.  source  #  Devices.Rectangles.Rectangle     Method .  Rectangle ( ll : :Point ,   ur : :Point ;   kwargs ...)   Convenience constructor for  Rectangle  objects.  source  #  Devices.Rectangles.Rectangle     Method .  Rectangle(width, height, kwargs...)  Constructs  Rectangle  objects by specifying the width and height rather than the lower-left and upper-right corners.  The rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of  Rectangle{Int}  type, this would not be possible if either  width  or  height  were odd numbers. This definition ensures type stability in the constructor.  source  #  Devices.bounds     Method .  bounds(r::Rectangle)  No-op (just returns  r ).  source  #  Devices.center     Method .  center(r::Rectangle)  Returns a  Point  corresponding to the center of the rectangle.  source  #  Devices.centered     Method .  centered(r::Rectangle)  Centers a copy of  r , with promoted coordinates if necessary. This function will not throw an  InexactError() , even if  r  had integer coordinates.  source  #  Devices.centered!     Method .  centered!(r::Rectangle)  Centers a rectangle. Will throw an  InexactError()  if the rectangle cannot be centered with integer coordinates.  source  #  Devices.Rectangles.height     Method .  height(r::Rectangle)  Return the height of a rectangle.  source  #  Devices.Rectangles.isproper     Method .  isproper(r::Rectangle)  Returns  true  if the rectangle has a non-zero size. Otherwise, returns  false . Note that the upper-right and lower-left corners are enforced to be the  ur  and  ll  fields of a  Rectangle  by the inner constructor.  source  #  Base.minimum     Method .  minimum(r::Rectangle)  Returns the lower-left corner of a rectangle (Point object).  source  #  Base.maximum     Method .  maximum(r::Rectangle)  Returns the upper-right corner of a rectangle (Point object).  source  #  Devices.Polygons.points     Method .  points{T}(x::Rectangle{T})  Returns the array of  Point  objects defining the rectangle.  source  #  Devices.Rectangles.width     Method .  width(r::Rectangle)  Return the width of a rectangle.  source  #  Base.:+     Method .  +(r::Rectangle, p::Point)  Translate a rectangle by  p .  source", 
            "title": "Rectangle API"
        }, 
        {
            "location": "/polygons/#polygon-api", 
            "text": "#  Devices.Polygons.Polygon     Type .  type Polygon{T}  : AbstractPolygon{T}\n    p::Array{Point{T},1}\n    properties::Dict{Symbol, Any}\n    Polygon(x,y) = new(x,y)\n    Polygon(x) = new(x, Dict{Symbol, Any}())\nend  Polygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).  source  #  Devices.Polygons.Polygon     Method .  Polygon { T } ( parr : :AbstractArray { Point { T } , 1 } ;   kwargs ...)   Convenience constructor for a  Polygon{T}  object.  source  #  Devices.Polygons.Polygon     Method .  Polygon ( p0 : :Point ,   p1 : :Point ,   p2 : :Point ,   p3 : :Point ...;   kwargs ...)   Convenience constructor for a  Polygon{T}  object.  source  #  Devices.bounds     Method .  bounds(p::Polygon)  Return a bounding Rectangle with no properties for polygon  p .  source  #  Devices.bounds     Method .  bounds{T :AbstractPolygon}(parr::AbstractArray{T})  Return a bounding  Rectangle  with no properties for an array  parr  of  AbstractPolygon  objects.  source  #  Devices.bounds     Method .  bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon  objects.  source  #  Base.minimum     Method .  minimum(x::Polygon)  Return the lower-left-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  source  #  Base.maximum     Method .  maximum(x::Polygon)  Return the upper-right-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  source  #  Devices.Polygons.points     Method .  points(x::Polygon)  Returns the array of  Point  objects defining the polygon.  source", 
            "title": "Polygon API"
        }, 
        {
            "location": "/cells/", 
            "text": "Cells\n\n\nCells are used to logically group polygons or references to other cells into a single entity. They can contain references to other cells or arrays of other cells. They also store polygons. Here is the definition of a \nCell\n:\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nType\n.\n\n\ntype Cell{T\n:Coordinate}\n    name::String\n    elements::Vector{Polygon{T}}\n    refs::Vector{CellRef}\n    create::DateTime\n    Cell(x,y,z,t) = new(x, y, z, t)\n    Cell(x,y,z) = new(x, y, z, now())\n    Cell(x,y) = new(x, y, CellRef[], now())\n    Cell(x) = new(x, Polygon{T}[], CellRef[], now())\n    Cell() = begin\n        c = new()\n        c.elements = Polygon{T}[]\n        c.refs = CellRef[]\n        c.create = now()\n        c\n    end\nend\n\n\n\n\n\nA cell has a name and contains polygons and references to \nCellArray\n or \nCellReference\n objects. It also records the time of its own creation. As currently implemented it mirrors the notion of cells in GDS-II files.\n\n\nTo add elements, push them to \nelements\n field (or use \nrender!\n); to add references, push them to \nrefs\n field.\n\n\nsource\n\n\nThe type parameter of a \nCell{T}\n object is used in two ways:\n\n\n\n\nDetermine the units of the coordinates of all polygons in a cell, as well as origins and offset vectors of \nCellArray\ns and \nCellReference\ns.\n\n\nDetermine whether the cell will contain integer coordinates or floating-point coordinates. Currently, you cannot do a whole lot (particularly with regard to paths) if the cell has integer coordinates. However, they do have an inherent advantage because the coordinates are exact, and ultimately the GDS-II file represents shapes with integer coordinates. In the future, we intend to improve support for cells with integer coordinates.\n\n\n\n\nFor instance, \nCell{typeof(1.0u\"nm\")}\n specifies a cell where the database unit is \nnm\n and polygons may have \nFloat64\n-based coordinates (the type of \n1.0\n is \nFloat64\n). Note that \nCell{typeof(2.0u\"nm\")}\n does not mean the database unit is 2.0nm, because the returned type is the same. If that is intended, instead make a new unit such that one of that new unit is equal to 2nm. You can do this using the \n@unit\n macro in Unitful.\n\n\nFor most cases, if you want to use units, \nCell{typeof(1.0u\"nm\")}(\"my_cell_name\")\n is a good way to construct a cell which will ultimately have all coordinates rounded to the nearest \nnm\n when exported into GDS-II. You can add polygons with whatever length units you want to such a cell, and the coordinates will be converted automatically to \nnm\n. You can change \nnm\n to \npm\n or \nfm\n or whatever, but this will limit the pattern extent and probably doesn't make sense anyway.\n\n\nIf you don't want units, just construct the cell with a name only: \nCell(\"my_cell_name\")\n will return a \nCell{Float64}\n object. In this case too, the ultimate database resolution is \n1nm\n; until exporting the cell into a GDS-II file, the coordinates are interpreted to be in units of \n1\u03bcm\n. This behavior cannot be changed for cells without units.\n\n\n\n\nCell API\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nMethod\n.\n\n\nCell(name::AbstractString)\n\n\n\n\n\nConvenience constructor for \nCell{typeof(1.0u\"nm\")}\n.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nMethod\n.\n\n\nCell{T\n:AbstractPolygon}(name::AbstractString, elements::AbstractVector{T})\n\n\n\n\n\nConvenience constructor for \nCell{T}\n.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds\n{\nT\n:\nCoordinate\n}\n(\ncell\n:\n:Cell\n{\nT\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with no properties around all objects in \ncell\n.\n\n\nsource\n\n\n#\n\n\nDevices.center\n \n \nMethod\n.\n\n\ncenter(cell::Cell)\n\n\n\n\n\nConvenience method, equivalent to \ncenter(bounds(cell))\n. Returns the center of the bounding box of the cell.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.name\n \n \nMethod\n.\n\n\nname(x::Cell)\n\n\n\n\n\nReturns the name of the cell.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.dbscale\n \n \nMethod\n.\n\n\ndbscale{T}(c::Cell{T})\n\n\n\n\n\nGive the database scale for a cell. The database scale is the smallest increment of length that will be represented in the output CAD file.\n\n\nFor \nCell{T\n:Length}\n, the database scale is \nT(1)\n. For floating-point lengths, this means that anything after the decimal point will be rounded off. For this reason, Cell{typeof(1.0nm)} is probably the most convenient type to work with.\n\n\nThe database scale of a \nCell{T\n:Real}\n is assumed to be \n1nm\n (\n1.0nm\n if \nT \n: AbstractFloat\n) because insufficient information is provided to know otherwise.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.dbscale\n \n \nMethod\n.\n\n\ndbscale(cell::Cell...)\n\n\n\n\n\nChoose an appropriate database scale for a GDSII file given \nCell\ns of different types. The smallest database scale of all cells considered is returned.\n\n\nsource\n\n\n\n\nReferenced and arrayed cells\n\n\nCells can be arrayed or referenced within other cells for efficiency or to reduce display complexity.\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nType\n.\n\n\ntype CellArray{S,T} \n: CellRef{S,T}\n    cell::T\n    origin::Point{S}\n    deltacol::Point{S}\n    deltarow::Point{S}\n    col::Int\n    row::Int\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend\n\n\n\n\n\nArray of \ncell\n starting at \norigin\n with \nrow\n rows and \ncol\n columns, spanned by vectors \ndeltacol\n and \ndeltarow\n. Optional x-reflection \nxrefl\n, magnification factor \nmag\n, and rotation angle \nrot\n for the array as a whole. If an angle is given without units it is assumed to be in radians.\n\n\nThe type variable \nT\n is to avoid circular definitions with \nCell\n.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nMethod\n.\n\n\nCellArray\n{\nT\n:\nCoordinate\n}\n(\nx\n,\n \norigin\n:\n:Point\n{\nT\n}\n,\n \ndc\n:\n:Point\n{\nT\n}\n,\n\n    \ndr\n:\n:Point\n{\nT\n}\n,\n \nc\n:\n:Integer\n,\n \nr\n:\n:Integer\n;\n \nxrefl\n=\nfalse\n,\n \nmag\n=\n1\n.0\n,\n \nrot\n=\n0\n.0\n)\n\n\n\n\n\n\nConstruct a \nCellArray{T,typeof(x)}\n object.\n\n\nKeyword arguments specify the column vector, row vector, number of columns, number of rows, x-reflection, magnification factor, and rotation. Synonyms are accepted for these keywords:\n\n\n\n\nColumn vector: \n:deltacol\n, \n:dcol\n, \n:dc\n, \n:vcol\n, \n:colv\n, \n:colvec\n, \n:colvector\n, \n:columnv\n, \n:columnvec\n, \n:columnvector\n\n\nRow vector: \n:deltarow\n, \n:drow\n, \n:dr\n, \n:vrow\n, \n:rv\n, \n:rowvec\n, \n:rowvector\n\n\nNumber of columns: \n:nc\n, \n:numcols\n, \n:numcol\n, \n:ncols\n, \n:ncol\n\n\nNumber of rows: \n:nr\n, \n:numrows\n, \n:numrow\n, \n:nrows\n, \n:nrow\n\n\nX-reflection: \n:xrefl\n, \n:xreflection\n, \n:refl\n, \n:reflect\n, \n:xreflect\n, \n:xmirror\n, \n:mirror\n\n\nMagnification: \n:mag\n, \n:magnification\n, \n:magnify\n, \n:zoom\n, \n:scale\n\n\nRotation: \n:rot\n, \n:rotation\n, \n:rotate\n, \n:angle\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nMethod\n.\n\n\nCellArray\n{\nT\n:\nCoordinate\n}\n(\nx\n,\n \nc\n:\n:Range\n{\nT\n}\n,\n \nr\n:\n:Range\n{\nT\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConstruct a \nCellArray{T,typeof(x)}\n based on ranges (probably \nLinSpace\n or \nFloatRange\n). \nc\n specifies column coordinates and \nr\n for the rows. Pairs from \nc\n and \nr\n specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting \nCellArray\n's bounding box; some care is required.\n\n\nKeyword arguments specify x-reflection, magnification factor, and rotation, with synonyms allowed:\n\n\n\n\nX-reflection: \n:xrefl\n, \n:xreflection\n, \n:refl\n, \n:reflect\n, \n:xreflect\n, \n:xmirror\n, \n:mirror\n\n\nMagnification: \n:mag\n, \n:magnification\n, \n:magnify\n, \n:zoom\n, \n:scale\n\n\nRotation: \n:rot\n, \n:rotation\n, \n:rotate\n, \n:angle\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Cells.CellReference\n \n \nType\n.\n\n\ntype CellReference{S,T} \n: CellRef{S,T}\n    cell::T\n    origin::Point{S}\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend\n\n\n\n\n\nReference to a \ncell\n positioned at \norigin\n, with optional x-reflection \nxrefl\n, magnification factor \nmag\n, and rotation angle \nrot\n. If an angle is given without units it is assumed to be in radians.\n\n\nThe type variable \nT\n is to avoid circular definitions with \nCell\n.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.CellReference\n \n \nType\n.\n\n\nCellReference\n{\nT\n:\nCoordinate\n}\n(\nx\n,\n \ny\n:\n:Point\n{\nT\n}\n=\nPoint\n(\n0\n.,\n0\n.);\n \nkwargs\n...\n\n\n\n\n\n\nConvenience constructor for \nCellReference{typeof(x), T}\n.\n\n\nKeyword arguments can specify x-reflection, magnification, or rotation. Synonyms are accepted, in case you forget the \"correct keyword\"...\n\n\n\n\nX-reflection: \n:xrefl\n, \n:xreflection\n, \n:refl\n, \n:reflect\n, \n:xreflect\n, \n:xmirror\n, \n:mirror\n\n\nMagnification: \n:mag\n, \n:magnification\n, \n:magnify\n, \n:zoom\n, \n:scale\n\n\nRotation: \n:rot\n, \n:rotation\n, \n:rotate\n, \n:angle\n\n\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds\n(\nref\n:\n:CellArray\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with properties specified by \nkwargs...\n around all objects in \nref\n. The bounding box respects reflection, rotation, and magnification specified by \nref\n.\n\n\nPlease do rewrite this method when feeling motivated... it is very inefficient.\n\n\nsource\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds\n(\nref\n:\n:CellReference\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with properties specified by \nkwargs...\n around all objects in \nref\n. The bounding box respects reflection, rotation, and magnification specified by \nref\n.\n\n\nsource\n\n\n#\n\n\nBase.copy\n \n \nMethod\n.\n\n\ncopy(x::CellReference)\n\n\n\n\n\nCreates a shallow copy of \nx\n (does not copy the referenced cell).\n\n\nsource\n\n\n#\n\n\nBase.copy\n \n \nMethod\n.\n\n\ncopy(x::CellArray)\n\n\n\n\n\nCreates a shallow copy of \nx\n (does not copy the arrayed cell).\n\n\nsource\n\n\n#\n\n\nDevices.Cells.name\n \n \nMethod\n.\n\n\nname(x::CellReference)\n\n\n\n\n\nReturns the name of the referenced cell.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.name\n \n \nMethod\n.\n\n\nname(x::CellArray)\n\n\n\n\n\nReturns the name of the arrayed cell.\n\n\nsource\n\n\n\n\nResolving references\n\n\nSometimes it can be helpful to go between coordinate systems of cells and the cells they reference. This package provides methods to generate affine transforms to do this as easily as possible.\n\n\n#\n\n\nCoordinateTransformations.transform\n \n \nMethod\n.\n\n\ntransform(c::Cell, d::CellRef)\n\n\n\n\n\nGiven a Cell \nc\n containing \nCellReference\n or \nCellArray\n \nd\n in its tree of references, this function returns a \nCoordinateTransformations.AffineMap\n object that lets you translate from the coordinate system of \nd\n to the coordinate system of \nc\n.\n\n\nIf the \nsame exact\n \nCellReference\n or \nCellArray\n (as in \n===\n, same address in memory) is included multiple times in the tree of references, then the resulting transform will be based on the first time it is encountered. The tree is traversed one level at a time to find the reference (optimized for shallow references).\n\n\nExample: You want to translate (2.0,3.0) in the coordinate system of the referenced cell to the coordinate system of \nc\n.\n\n\njulia\n \ntrans\n \n=\n \ntransform\n(\nc\n,\nd\n)\n\n\n\njulia\n \ntrans\n(\nPoint\n(\n2.0\n,\n3.0\n))\n\n\n\n\n\n\nsource\n\n\nIn some cases it may be desirable to resolve cell references or arrays into their corresponding polygons. This operation is called \"flattening.\"\n\n\n#\n\n\nDevices.Cells.flatten!\n \n \nFunction\n.\n\n\nflatten!(c::Cell)\n\n\nAll cell references and arrays are turned into polygons and added to cell \nc\n. The references and arrays are then removed. This \"flattening\" of the cell is recursive: references in referenced cells are flattened too. The modified cell is returned.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.flatten\n \n \nFunction\n.\n\n\nflatten{T\n:Coordinate}(c::Cell{T})\n\n\nAll cell references and arrays are resolved into polygons, recursively. Together with the polygons already in cell \nc\n, an array of polygons (type \nAbstractPolygon{T}\n) is returned. The cell \nc\n remains unmodified.\n\n\nsource\n\n\nflatten(c::CellReference)\n\n\nCell reference \nc\n is resolved into polygons, recursively. An array of polygons (type \nAbstractPolygon\n) is returned. The cell reference \nc\n remains unmodified.\n\n\nsource\n\n\nflatten(c::CellArray)\n\n\nCell array \nc\n is resolved into polygons, recursively. An array of polygons (type \nAbstractPolygon\n) is returned. The cell array \nc\n remains unmodified.\n\n\nsource\n\n\n\n\nMiscellaneous\n\n\nWhen saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.\n\n\n#\n\n\nDevices.Cells.traverse!\n \n \nFunction\n.\n\n\ntraverse!(a::AbstractArray, c::Cell, level=1)\n\n\n\n\n\nGiven a cell, recursively traverse its references for other cells and add to array \na\n some tuples: \n(level, c)\n. \nlevel\n corresponds to how deep the cell was found, and \nc\n is the found cell.\n\n\nsource\n\n\n#\n\n\nDevices.Cells.order!\n \n \nFunction\n.\n\n\norder!(a::AbstractArray)\n\n\n\n\n\nGiven an array of tuples like that coming out of \ntraverse!\n, we sort by the \nlevel\n, strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).\n\n\nFor performance reasons, this function modifies \na\n but what you want is the returned result array.\n\n\nsource", 
            "title": "Cells"
        }, 
        {
            "location": "/cells/#cells", 
            "text": "Cells are used to logically group polygons or references to other cells into a single entity. They can contain references to other cells or arrays of other cells. They also store polygons. Here is the definition of a  Cell :  #  Devices.Cells.Cell     Type .  type Cell{T :Coordinate}\n    name::String\n    elements::Vector{Polygon{T}}\n    refs::Vector{CellRef}\n    create::DateTime\n    Cell(x,y,z,t) = new(x, y, z, t)\n    Cell(x,y,z) = new(x, y, z, now())\n    Cell(x,y) = new(x, y, CellRef[], now())\n    Cell(x) = new(x, Polygon{T}[], CellRef[], now())\n    Cell() = begin\n        c = new()\n        c.elements = Polygon{T}[]\n        c.refs = CellRef[]\n        c.create = now()\n        c\n    end\nend  A cell has a name and contains polygons and references to  CellArray  or  CellReference  objects. It also records the time of its own creation. As currently implemented it mirrors the notion of cells in GDS-II files.  To add elements, push them to  elements  field (or use  render! ); to add references, push them to  refs  field.  source  The type parameter of a  Cell{T}  object is used in two ways:   Determine the units of the coordinates of all polygons in a cell, as well as origins and offset vectors of  CellArray s and  CellReference s.  Determine whether the cell will contain integer coordinates or floating-point coordinates. Currently, you cannot do a whole lot (particularly with regard to paths) if the cell has integer coordinates. However, they do have an inherent advantage because the coordinates are exact, and ultimately the GDS-II file represents shapes with integer coordinates. In the future, we intend to improve support for cells with integer coordinates.   For instance,  Cell{typeof(1.0u\"nm\")}  specifies a cell where the database unit is  nm  and polygons may have  Float64 -based coordinates (the type of  1.0  is  Float64 ). Note that  Cell{typeof(2.0u\"nm\")}  does not mean the database unit is 2.0nm, because the returned type is the same. If that is intended, instead make a new unit such that one of that new unit is equal to 2nm. You can do this using the  @unit  macro in Unitful.  For most cases, if you want to use units,  Cell{typeof(1.0u\"nm\")}(\"my_cell_name\")  is a good way to construct a cell which will ultimately have all coordinates rounded to the nearest  nm  when exported into GDS-II. You can add polygons with whatever length units you want to such a cell, and the coordinates will be converted automatically to  nm . You can change  nm  to  pm  or  fm  or whatever, but this will limit the pattern extent and probably doesn't make sense anyway.  If you don't want units, just construct the cell with a name only:  Cell(\"my_cell_name\")  will return a  Cell{Float64}  object. In this case too, the ultimate database resolution is  1nm ; until exporting the cell into a GDS-II file, the coordinates are interpreted to be in units of  1\u03bcm . This behavior cannot be changed for cells without units.", 
            "title": "Cells"
        }, 
        {
            "location": "/cells/#cell-api", 
            "text": "#  Devices.Cells.Cell     Method .  Cell(name::AbstractString)  Convenience constructor for  Cell{typeof(1.0u\"nm\")} .  source  #  Devices.Cells.Cell     Method .  Cell{T :AbstractPolygon}(name::AbstractString, elements::AbstractVector{T})  Convenience constructor for  Cell{T} .  source  #  Devices.bounds     Method .  bounds { T : Coordinate } ( cell : :Cell { T } ;   kwargs ...)   Returns a  Rectangle  bounding box with no properties around all objects in  cell .  source  #  Devices.center     Method .  center(cell::Cell)  Convenience method, equivalent to  center(bounds(cell)) . Returns the center of the bounding box of the cell.  source  #  Devices.Cells.name     Method .  name(x::Cell)  Returns the name of the cell.  source  #  Devices.Cells.dbscale     Method .  dbscale{T}(c::Cell{T})  Give the database scale for a cell. The database scale is the smallest increment of length that will be represented in the output CAD file.  For  Cell{T :Length} , the database scale is  T(1) . For floating-point lengths, this means that anything after the decimal point will be rounded off. For this reason, Cell{typeof(1.0nm)} is probably the most convenient type to work with.  The database scale of a  Cell{T :Real}  is assumed to be  1nm  ( 1.0nm  if  T  : AbstractFloat ) because insufficient information is provided to know otherwise.  source  #  Devices.Cells.dbscale     Method .  dbscale(cell::Cell...)  Choose an appropriate database scale for a GDSII file given  Cell s of different types. The smallest database scale of all cells considered is returned.  source", 
            "title": "Cell API"
        }, 
        {
            "location": "/cells/#referenced-and-arrayed-cells", 
            "text": "Cells can be arrayed or referenced within other cells for efficiency or to reduce display complexity.  #  Devices.Cells.CellArray     Type .  type CellArray{S,T}  : CellRef{S,T}\n    cell::T\n    origin::Point{S}\n    deltacol::Point{S}\n    deltarow::Point{S}\n    col::Int\n    row::Int\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend  Array of  cell  starting at  origin  with  row  rows and  col  columns, spanned by vectors  deltacol  and  deltarow . Optional x-reflection  xrefl , magnification factor  mag , and rotation angle  rot  for the array as a whole. If an angle is given without units it is assumed to be in radians.  The type variable  T  is to avoid circular definitions with  Cell .  source  #  Devices.Cells.CellArray     Method .  CellArray { T : Coordinate } ( x ,   origin : :Point { T } ,   dc : :Point { T } , \n     dr : :Point { T } ,   c : :Integer ,   r : :Integer ;   xrefl = false ,   mag = 1 .0 ,   rot = 0 .0 )   Construct a  CellArray{T,typeof(x)}  object.  Keyword arguments specify the column vector, row vector, number of columns, number of rows, x-reflection, magnification factor, and rotation. Synonyms are accepted for these keywords:   Column vector:  :deltacol ,  :dcol ,  :dc ,  :vcol ,  :colv ,  :colvec ,  :colvector ,  :columnv ,  :columnvec ,  :columnvector  Row vector:  :deltarow ,  :drow ,  :dr ,  :vrow ,  :rv ,  :rowvec ,  :rowvector  Number of columns:  :nc ,  :numcols ,  :numcol ,  :ncols ,  :ncol  Number of rows:  :nr ,  :numrows ,  :numrow ,  :nrows ,  :nrow  X-reflection:  :xrefl ,  :xreflection ,  :refl ,  :reflect ,  :xreflect ,  :xmirror ,  :mirror  Magnification:  :mag ,  :magnification ,  :magnify ,  :zoom ,  :scale  Rotation:  :rot ,  :rotation ,  :rotate ,  :angle   source  #  Devices.Cells.CellArray     Method .  CellArray { T : Coordinate } ( x ,   c : :Range { T } ,   r : :Range { T } ;   kwargs ...)   Construct a  CellArray{T,typeof(x)}  based on ranges (probably  LinSpace  or  FloatRange ).  c  specifies column coordinates and  r  for the rows. Pairs from  c  and  r  specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting  CellArray 's bounding box; some care is required.  Keyword arguments specify x-reflection, magnification factor, and rotation, with synonyms allowed:   X-reflection:  :xrefl ,  :xreflection ,  :refl ,  :reflect ,  :xreflect ,  :xmirror ,  :mirror  Magnification:  :mag ,  :magnification ,  :magnify ,  :zoom ,  :scale  Rotation:  :rot ,  :rotation ,  :rotate ,  :angle   source  #  Devices.Cells.CellReference     Type .  type CellReference{S,T}  : CellRef{S,T}\n    cell::T\n    origin::Point{S}\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend  Reference to a  cell  positioned at  origin , with optional x-reflection  xrefl , magnification factor  mag , and rotation angle  rot . If an angle is given without units it is assumed to be in radians.  The type variable  T  is to avoid circular definitions with  Cell .  source  #  Devices.Cells.CellReference     Type .  CellReference { T : Coordinate } ( x ,   y : :Point { T } = Point ( 0 ., 0 .);   kwargs ...   Convenience constructor for  CellReference{typeof(x), T} .  Keyword arguments can specify x-reflection, magnification, or rotation. Synonyms are accepted, in case you forget the \"correct keyword\"...   X-reflection:  :xrefl ,  :xreflection ,  :refl ,  :reflect ,  :xreflect ,  :xmirror ,  :mirror  Magnification:  :mag ,  :magnification ,  :magnify ,  :zoom ,  :scale  Rotation:  :rot ,  :rotation ,  :rotate ,  :angle   source  #  Devices.bounds     Method .  bounds ( ref : :CellArray ;   kwargs ...)   Returns a  Rectangle  bounding box with properties specified by  kwargs...  around all objects in  ref . The bounding box respects reflection, rotation, and magnification specified by  ref .  Please do rewrite this method when feeling motivated... it is very inefficient.  source  #  Devices.bounds     Method .  bounds ( ref : :CellReference ;   kwargs ...)   Returns a  Rectangle  bounding box with properties specified by  kwargs...  around all objects in  ref . The bounding box respects reflection, rotation, and magnification specified by  ref .  source  #  Base.copy     Method .  copy(x::CellReference)  Creates a shallow copy of  x  (does not copy the referenced cell).  source  #  Base.copy     Method .  copy(x::CellArray)  Creates a shallow copy of  x  (does not copy the arrayed cell).  source  #  Devices.Cells.name     Method .  name(x::CellReference)  Returns the name of the referenced cell.  source  #  Devices.Cells.name     Method .  name(x::CellArray)  Returns the name of the arrayed cell.  source", 
            "title": "Referenced and arrayed cells"
        }, 
        {
            "location": "/cells/#resolving-references", 
            "text": "Sometimes it can be helpful to go between coordinate systems of cells and the cells they reference. This package provides methods to generate affine transforms to do this as easily as possible.  #  CoordinateTransformations.transform     Method .  transform(c::Cell, d::CellRef)  Given a Cell  c  containing  CellReference  or  CellArray   d  in its tree of references, this function returns a  CoordinateTransformations.AffineMap  object that lets you translate from the coordinate system of  d  to the coordinate system of  c .  If the  same exact   CellReference  or  CellArray  (as in  === , same address in memory) is included multiple times in the tree of references, then the resulting transform will be based on the first time it is encountered. The tree is traversed one level at a time to find the reference (optimized for shallow references).  Example: You want to translate (2.0,3.0) in the coordinate system of the referenced cell to the coordinate system of  c .  julia   trans   =   transform ( c , d )  julia   trans ( Point ( 2.0 , 3.0 ))   source  In some cases it may be desirable to resolve cell references or arrays into their corresponding polygons. This operation is called \"flattening.\"  #  Devices.Cells.flatten!     Function .  flatten!(c::Cell)  All cell references and arrays are turned into polygons and added to cell  c . The references and arrays are then removed. This \"flattening\" of the cell is recursive: references in referenced cells are flattened too. The modified cell is returned.  source  #  Devices.Cells.flatten     Function .  flatten{T :Coordinate}(c::Cell{T})  All cell references and arrays are resolved into polygons, recursively. Together with the polygons already in cell  c , an array of polygons (type  AbstractPolygon{T} ) is returned. The cell  c  remains unmodified.  source  flatten(c::CellReference)  Cell reference  c  is resolved into polygons, recursively. An array of polygons (type  AbstractPolygon ) is returned. The cell reference  c  remains unmodified.  source  flatten(c::CellArray)  Cell array  c  is resolved into polygons, recursively. An array of polygons (type  AbstractPolygon ) is returned. The cell array  c  remains unmodified.  source", 
            "title": "Resolving references"
        }, 
        {
            "location": "/cells/#miscellaneous", 
            "text": "When saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.  #  Devices.Cells.traverse!     Function .  traverse!(a::AbstractArray, c::Cell, level=1)  Given a cell, recursively traverse its references for other cells and add to array  a  some tuples:  (level, c) .  level  corresponds to how deep the cell was found, and  c  is the found cell.  source  #  Devices.Cells.order!     Function .  order!(a::AbstractArray)  Given an array of tuples like that coming out of  traverse! , we sort by the  level , strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).  For performance reasons, this function modifies  a  but what you want is the returned result array.  source", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/paths/", 
            "text": "Paths\n\n\n#\n\n\nDevices.Paths.Path\n \n \nType\n.\n\n\ntype Path{T\n:Coordinate} \n: AbstractVector{Node{T}}\n    p0::Point{T}\n    \u03b10::typeof(0.0\u00b0)\n    style0::ContinuousStyle{T}\n    nodes::Array{Node{T},1}\nend\n\n\n\n\n\nType for abstracting an arbitrary styled path in the plane. Iterating returns tuples of (\nsegment\n, \nstyle\n).\n\n\nsource\n\n\n#\n\n\nDevices.Paths.Path\n \n \nMethod\n.\n\n\nPath\n{\nT\n:\nCoordinate\n}\n(\np0\n:\n:Point\n{\nT\n}\n=\nPoint\n(\n0\n.0\n,\n0\n.0\n);\n \n\u03b1\n0\n=\n0\n.0\n,\n \nstyle0\n:\n:Style\n=\nTrace\n(\n1\n.0\n))\n\n\n\n\n\n\nConvenience constructor for \nPath{T}\n object.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.pathlength\n \n \nMethod\n.\n\n\npathlength(p::Path)\n\n\n\n\n\nPhysical length of a path. Note that \nlength\n will return the number of segments in a path, not the physical length of the path.\n\n\nsource\n\n\n\n\nSegments\n\n\n#\n\n\nDevices.Paths.Segment\n \n \nType\n.\n\n\nabstract Segment{T\n:Coordinate}\n\n\n\n\n\nPath segment in the plane. All Segment objects should have the implement the following methods:\n\n\n\n\npathlength\n\n\np0\n\n\n\u03b10\n\n\nsetp0!\n\n\nset\u03b10!\n\n\n\u03b11\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Paths.Straight\n \n \nType\n.\n\n\ntype Straight{T} \n: ContinuousSegment{T}\n    l::T\n    p0::Point{T}\n    \u03b10::typeof(0.0\u00b0)\n    f::Function\n    Straight(l, p0, \u03b10) = begin\n        s = new(l, p0, \u03b10)\n        s.f = t-\n(s.p0+Point(t*s.l*cos(s.\u03b10),t*s.l*sin(s.\u03b10)))\n        s\n    end\nend\n\n\n\n\n\nA straight line segment is parameterized by its length. It begins at a point \np0\n with initial angle \n\u03b10\n.\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the line segment is given by:\n\n\nt -\n p0 + Point(t*l*cos(\u03b1),t*l*sin(\u03b1))\n\n\nsource\n\n\n#\n\n\nDevices.Paths.Turn\n \n \nType\n.\n\n\ntype Turn{T} \n: Segment{T}\n    \u03b1::typeof(1.0\u00b0)\n    r::T\n    p0::Point{T}\n    \u03b10::typeof(1.0\u00b0)\n    f::Function\n    Turn(\u03b1, r, p0, \u03b10) = begin\n        s = new(\u03b1, r, p0, \u03b10)\n        s.f = t-\nbegin\n            cen = s.p0 + Point(s.r*cos(s.\u03b10+sign(s.\u03b1)*\u03c0/2), s.r*sin(s.\u03b10+sign(s.\u03b1)*\u03c0/2))\n            cen + Point(s.r*cos(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t), s.r*sin(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t))\n        end\n        s\n    end\nend\n\n\n\n\n\nA circular turn is parameterized by the turn angle \n\u03b1\n and turning radius \nr\n. It begins at a point \np0\n with initial angle \n\u03b10\n.\n\n\nThe center of the circle is given by:\n\n\ncen = p0 + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the turn is given by:\n\n\nt -\n cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))\n\n\nsource\n\n\n#\n\n\nDevices.Paths.Corner\n \n \nType\n.\n\n\ntype Corner{T} \n: DiscreteSegment{T}\n    \u03b1::typeof(1.0\u00b0)\n    p0::Point{T}\n    \u03b10::typeof(1.0\u00b0)\n    extent::T\n    Corner(a) = new(a, Point(zero(T),zero(T)), 0.0\u00b0, zero(T))\n    Corner(a,b,c,d) = new(a,b,c,d)\nend\n\n\n\n\n\nA corner, or sudden kink in a path. The only parameter is the angle \n\u03b1\n of the kink. The kink begins at a point \np0\n with initial angle \n\u03b10\n. It will also end at \np0\n, since the corner has zero path length. However, during rendering, neighboring segments will be tweaked slightly so that the rendered path is properly centered about the path function (the rendered corner has a finite width).\n\n\nsource\n\n\n#\n\n\nDevices.Paths.CompoundSegment\n \n \nType\n.\n\n\ntype CompoundSegment{T} \n: ContinuousSegment{T}\n    segments::Vector{Segment{T}}\n    f::Function\n\n    CompoundSegment(segments) = begin\n        if any(x-\nisa(x,Corner), segments)\n            error(\ncannot have corners in a `CompoundSegment`. You may have \n,\n                \ntried to simplify a path containing `Corner` objects.\n)\n        else\n            s = new(deepcopy(Array(segments)))\n            s.f = param(s.segments)\n            s\n        end\n    end\nend\n\n\n\n\n\nConsider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes. The array of segments given to the constructor is copied and retained by the compound segment.\n\n\nNote that \nCorner\ns introduce a discontinuity in the derivative of the path function, and are not allowed in a \nCompoundSegment\n.\n\n\nsource\n\n\n\n\nStyles\n\n\n#\n\n\nDevices.Paths.Style\n \n \nType\n.\n\n\nabstract Style{T\n:Coordinate}\n\n\n\n\n\nHow to render a given path segment. All styles should implement the following methods:\n\n\n\n\ndistance\n\n\nextent\n\n\npaths\n\n\nwidth\n\n\ndivs\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Paths.ContinuousStyle\n \n \nType\n.\n\n\nabstract ContinuousStyle{T} \n: Style{T}\n\n\n\n\n\nAny style that applies to segments which have non-zero path length.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.DiscreteStyle\n \n \nType\n.\n\n\nabstract DiscreteStyle{T} \n: Style{T}\n\n\n\n\n\nAny style that applies to segments which have zero path length.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.Trace\n \n \nType\n.\n\n\ntype Trace{T} \n: ContinuousStyle{T}\n    width::Function\n    divs::Int\nend\n\n\n\n\n\nSimple, single trace.\n\n\n\n\nwidth::Function\n: trace width.\n\n\ndivs::Int\n: number of segments to render. Increase if you see artifacts.\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Paths.CPW\n \n \nType\n.\n\n\ntype CPW{T} \n: ContinuousStyle{T}\n    trace::Function\n    gap::Function\n    divs::Int\nend\n\n\n\n\n\nTwo adjacent traces can form a coplanar waveguide.\n\n\n\n\ntrace::Function\n: center conductor width.\n\n\ngap::Function\n: distance between center conductor edges and ground plane\n\n\ndivs::Int\n: number of segments to render. Increase if you see artifacts.\n\n\n\n\nMay need to be inverted with respect to a ground plane, depending on how the pattern is written.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.CompoundStyle\n \n \nType\n.\n\n\ntype CompoundStyle{T} \n: ContinuousStyle{T}\n    styles::Vector{Style{T}}\n    divs::Vector{Float64}\n    f::Function\nend\n\n\n\n\n\nCombines styles together, typically for use with a \nCompoundSegment\n.\n\n\n\n\nstyles\n: Array of styles making up the object. This is shallow-copied\n\n\n\n\nby the outer constructor.\n\n\n\n\ndivs\n: An array of \nt\n values needed for rendering the parameteric path.\n\n\nf\n: returns tuple of style index and the \nt\n to use for that\n\n\n\n\nstyle's parametric function.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.DecoratedStyle\n \n \nType\n.\n\n\ntype DecoratedStyle{T} \n: ContinuousStyle{T}\n    s::Style{T}\n    ts::Array{Float64,1}\n    dirs::Array{Int,1}\n    refs::Array{CellReference{T},1}\n    DecoratedStyle(s) = begin\n        a = new(s)\n        a.ts = Float64[]\n        a.dirs = Int[]\n        a.refs = CellReference{T}[]\n        a\n    end\n    DecoratedStyle(s,t,d,r) = new(s,t,d,r)\nend\n\n\n\n\n\nStyle with decorations, like structures periodically repeated along the path, etc.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.undecorated\n \n \nFunction\n.\n\n\nundecorated(s::Style)\n\n\n\n\n\nReturns \ns\n.\n\n\nsource\n\n\nundecorated(s::DecoratedStyle)\n\n\n\n\n\nReturns the underlying, undecorated style.\n\n\nsource\n\n\n\n\nPath interrogation\n\n\n#\n\n\nDevices.Paths.direction\n \n \nFunction\n.\n\n\ndirection(p::Function, t)\n\n\n\n\n\nFor some parameteric function \np(t)\u21a6Point(x(t),y(t))\n, returns the angle at which the path is pointing for a given \nt\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.pathlength\n \n \nFunction\n.\n\n\npathlength{T}(s::Segment{T}, verbose::Bool=false)\n\n\n\n\n\nReturn the length of a segment (calculated).\n\n\nsource\n\n\npathlength(p::Path)\n\n\n\n\n\nPhysical length of a path. Note that \nlength\n will return the number of segments in a path, not the physical length of the path.\n\n\nsource\n\n\npathlength(p::AbstractArray)\n\n\n\n\n\nTotal physical length of segments.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.p0\n \n \nFunction\n.\n\n\np0{T}(s::Segment{T})\n\n\n\n\n\nReturn the first point in a segment (calculated).\n\n\nsource\n\n\np0(p::Path)\n\n\n\n\n\nFirst point of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.setp0!\n \n \nFunction\n.\n\n\nsetp0!(s::Straight, p::Point)\n\n\n\n\n\nSet the p0 of a straight segment.\n\n\nsource\n\n\nsetp0!(s::Turn, p::Point)\n\n\n\n\n\nSet the p0 of a turn.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.\u03b10\n \n \nFunction\n.\n\n\n\u03b10(s::Segment)\n\n\n\n\n\nReturn the first angle in a segment (calculated).\n\n\nsource\n\n\n\u03b10(p::Path)\n\n\n\n\n\nFirst angle of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.set\u03b10!\n \n \nFunction\n.\n\n\nset\u03b10!(s::Straight, \u03b10\u2032)\n\n\n\n\n\nSet the angle of a straight segment.\n\n\nsource\n\n\nset\u03b10!(s::Turn, \u03b10\u2032)\n\n\n\n\n\nSet the starting angle of a turn.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.p1\n \n \nFunction\n.\n\n\np1{T}(s::Segment{T})\n\n\n\n\n\nReturn the last point in a segment (calculated).\n\n\nsource\n\n\np1(p::Path)\n\n\n\n\n\nLast point of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.\u03b11\n \n \nFunction\n.\n\n\n\u03b11(s::Segment)\n\n\n\n\n\nReturn the last angle in a segment (calculated).\n\n\nsource\n\n\n\u03b11(p::Path)\n\n\n\n\n\nLast angle of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.style0\n \n \nFunction\n.\n\n\nstyle0(p::Path)\n\n\n\n\n\nStyle of the first segment of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.style1\n \n \nFunction\n.\n\n\nstyle1(p::Path)\n\n\n\n\n\nStyle of the last segment of a path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.discretestyle1\n \n \nFunction\n.\n\n\ndiscretestyle1{T}(p::Path{T})\n\n\n\n\n\nReturns the last-used discrete style in the path. If one was not used, returns \nSimpleCornerStyle()\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.contstyle1\n \n \nFunction\n.\n\n\ncontstyle1(p::Path)\n\n\n\n\n\nReturns the last-used discrete style in the path. If one was not used, returns \np.style0\n.\n\n\nsource\n\n\n\n\nPath building\n\n\n#\n\n\nBase.append!\n \n \nMethod\n.\n\n\nappend!(p::Path, p\u2032::Path)\n\n\n\n\n\nGiven paths \np\n and \np\u2032\n, path \np\u2032\n is appended to path \np\n. The p0 and initial angle of the first segment from path \np\u2032\n is modified to match the last point and last angle of path \np\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.adjust!\n \n \nFunction\n.\n\n\nadjust!(p::Path, n::Integer=1)\n\n\n\n\n\nAdjust a path's parametric functions starting from index \nn\n. Used internally whenever segments are inserted into the path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.attach!\n \n \nFunction\n.\n\n\nattach\n!(\np\n:\n:Path\n,\n \nc\n:\n:CellReference\n,\n \nt\n:\n:Real\n;\n \ni\n:\n:Integer\n=\nlength\n(\np\n),\n \nwhere\n:\n:Integer\n=\n0\n)\n\n\n\n\n\n\nAttach \nc\n along a path.\n\n\nBy default, the attachment occurs at \nt \u2208 [0,1]\n along the most recent path segment, but a different path segment index can be specified using \ni\n. The reference is oriented with zero rotation if the path is pointing at 0\u00b0, otherwise it is rotated with the path.\n\n\nThe origin of the cell reference tells the method where to place the cell \nwith respect to a coordinate system that rotates with the path\n. Suppose the path is a straight line with angle 0\u00b0. Then an origin of \nPoint(0.,10.)\n will put the cell at 10 above the path, or 10 to the left of the path if it turns left by 90\u00b0.\n\n\nThe \nwhere\n option is for convenience. If \nwhere == 0\n, nothing special happens. If \nwhere == -1\n, then the point of attachment for the reference is on the leftmost edge of the waveguide (the rendered polygons; the path itself has no width). Likewise if \nwhere == 1\n, the point of attachment is on the rightmost edge. This option does not automatically rotate the cell reference, apart from what is already done as described in the first paragraph. You can think of this option as setting a special origin for the coordinate system that rotates with the path. For instance, an origin for the cell reference of \nPoint(0.,10.)\n together with \nwhere == -1\n will put the cell at 10 above the edge of a rendered (finite width) path with angle 0\u00b0.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.corner!\n \n \nFunction\n.\n\n\ncorner!{T\n:Coordinate}(p::Path{T}, \u03b1, sty::DiscreteStyle=discretestyle1(p))\n\n\n\n\n\nAppend a sharp turn or \"corner\" to path \np\n with angle \n\u03b1\n.\n\n\nThe style chosen for this corner, if not specified, is the last \nDiscreteStyle\n used in the path, or \nSimpleCornerStyle\n if one has not been used yet.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.meander!\n \n \nFunction\n.\n\n\nmeander!{T\n:Real}(p::Path{T}, len, r, straightlen, \u03b1::Real)\n\n\n\n\n\nAlternate between going straight with length \nstraightlen\n and turning with radius \nr\n and angle \n\u03b1\n. Each turn goes the opposite direction of the previous. The total length is \nlen\n. Useful for making resonators.\n\n\nThe straight and turn segments are combined into a \nCompoundSegment\n and appended to the path \np\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.param\n \n \nFunction\n.\n\n\nparam{T\n:Coordinate}(c::AbstractVector{Segment{T}})\n\n\n\n\n\nReturn a parametric function over the domain [0,1] that represents the compound segments.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.simplify\n \n \nFunction\n.\n\n\nsimplify(p::Path, inds::UnitRange=1:length(p))\n\n\n\n\n\nAt \ninds\n, segments of a path are turned into a \nCompoundSegment\n and styles of a path are turned into a \nCompoundStyle\n. The method returns a tuple, \n(segment, style)\n.\n\n\n\n\nIndexing the path becomes more sane when you can combine several path\n\n\n\n\nsegments into one logical element. A launcher would have several indices in a path unless you could simplify it.\n\n\n\n\nYou don't need to think hard about boundaries between straights and turns\n\n\n\n\nwhen you want a continuous styling of a very long path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.simplify!\n \n \nFunction\n.\n\n\nsimplify!(p::Path, inds::UnitRange=1:length(p))\n\n\n\n\n\nIn-place version of \nsimplify\n.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.straight!\n \n \nFunction\n.\n\n\nstraight!{T\n:Coordinate}(p::Path{T}, l::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))\n\n\n\n\n\nExtend a path \np\n straight by length \nl\n in the current direction. By default, we take the last continuous style in the path.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.turn!\n \n \nFunction\n.\n\n\nturn!{T\n:Coordinate}(p::Path{T}, \u03b1, r::Coordinate, sty::Style=style1(p))\n\n\n\n\n\nTurn a path \np\n by angle \n\u03b1\n with a turning radius \nr\n in the current direction. Positive angle turns left.\n\n\nsource\n\n\nturn!{T\n:Coordinate}(p::Path{T}, s::String, r::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))\n\n\n\n\n\nTurn a path \np\n with direction coded by string \ns\n:\n\n\n\n\n\"l\": turn by \u03c0/2 radians (left)\n\n\n\"r\": turn by -\u03c0/2 radians (right)\n\n\n\"lrlrllrrll\": do those turns in that order\n\n\n\n\nBy default, we take the last continuous style in the path.\n\n\nsource\n\n\n\n\nAttachments\n\n\nWhen you call \nattach!\n, you are defining a coordinate system local to somewhere along the target \nPath\n, saying that a \nCellReference\n should be placed at the origin of that coordinate system (or slightly away from it if you want the cell to be one one side of the path or the other). The local coordinate system will rotate as the path changes orientations. The origin of the \nCellReference\n corresponds how the referenced cell should be displaced with respect to the origin of the local coordinate system. This differs from the usual meaning of the origin of a \nCellReference\n, which is how the referenced cell should be displaced with respect to the origin of a containing \nCell\n.\n\n\nThe same \nCellReference\n can be attached to multiple points along multiple paths. If the cell reference is modified (e.g. rotation, origin, magnification) before rendering, the changes should be reflected at all attachment points. The attachment of the cell reference is in some sense an abstraction: a \nCellReference\n must ultimately live inside a \nCell\n, but an unrendered \nPath\n does not live inside any cell. If the path is modified further before rendering, the attachment points should follow the path modifications, moving the origins of the local coordinate systems. The origin fields of the cell references do not change as the path is modified.\n\n\nAttachments are implemented by introducing a \nPaths.DecoratedStyle\n, which is kind of a meta-\nStyle\n: it remembers where to attach \nCellReferences\n, but how the path itself is actually drawn is deferred to a different \nStyle\n object that it retains a reference to. One can repeat a \nDecoratedStyle\n with one attachment to achieve a periodic placement of \nCellReferences\n (like a \nCellArray\n, but along the path). Or, one long segment with a \nDecoratedStyle\n could have several attachments to achieve a similar effect.\n\n\nWhen a \nPath\n is rendered, it is turned into \nPolygons\n living in some \nCell\n. The attachments remain \nCellReferences\n, now living inside of a \nCell\n and not tied to an abstract path. The notion of local coordinate systems along the path no longer makes sense because the abstract path has been made concrete, and the polygons are living in the coordinate system of the containing cell. Each attachment to the former path now must have its origin referenced to the origin of the containing cell, not to local path coordinate systems. Additionally, the references may need to rotate according to how the path was locally oriented. As a result, even if the same \nCellReference\n was attached multiple times to a path, now we need distinct \nCellReference\n objects for each attachment, as well as for each time a corresponding \nDecoratedStyle\n is rendered.\n\n\nSuppose we want the ability to transform between coordinate systems, especially between the coordinate system of a referenced cell and the coordinate system of a parent cell. At first glance it would seem like we could simply define a transform function, taking the parent cell and the cell reference we are interested in. But how would we actually identify the particular cell reference we want? Looking in the tree of references for an attached \nCellReference\n will not work: distinct \nCellReferences\n needed to be made after the path was rendered, and so the particular \nCellReference\n object initially attached is not actually in the \nCell\n containing the rendered path.\n\n\nTo overcome this problem, we make searching for the appropriate \nCellReference\n easier. Suppose a path with attachments has been rendered to a \nCell\n, which is bound to symbol \naaa\n. A \nCellReference\n referring to a cell named \"bbb\" was attached twice. To recall the second attachment: \naaa[\"bbb\",2]\n (the index defaults to 1 if unspecified). We can go deeper if we want to refer to references inside that attachment: \naaa[\"bbb\",2][\"ccc\"]\n. In this manner, it is easy to find the right \nCellReference\n to use with \nCells.transform(::Cell, ::Cells.CellRef)\n.\n\n\n\n\nInterfacing with gdspy\n\n\nThe Python package \ngdspy\n is used for rendering paths into polygons. Ultimately we intend to remove this dependency.\n\n\n#\n\n\nDevices.Paths.distance\n \n \nFunction\n.\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the distance between the centers of parallel paths rendered by gdspy.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.extent\n \n \nFunction\n.\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns a distance tangential to the path specifying the lateral extent of the polygons rendered by gdspy.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.paths\n \n \nFunction\n.\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the number of parallel paths rendered by gdspy.\n\n\nsource\n\n\n#\n\n\nDevices.Paths.width\n \n \nFunction\n.\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the width of paths rendered by gdspy.\n\n\nsource", 
            "title": "Paths"
        }, 
        {
            "location": "/paths/#paths", 
            "text": "#  Devices.Paths.Path     Type .  type Path{T :Coordinate}  : AbstractVector{Node{T}}\n    p0::Point{T}\n    \u03b10::typeof(0.0\u00b0)\n    style0::ContinuousStyle{T}\n    nodes::Array{Node{T},1}\nend  Type for abstracting an arbitrary styled path in the plane. Iterating returns tuples of ( segment ,  style ).  source  #  Devices.Paths.Path     Method .  Path { T : Coordinate } ( p0 : :Point { T } = Point ( 0 .0 , 0 .0 );   \u03b1 0 = 0 .0 ,   style0 : :Style = Trace ( 1 .0 ))   Convenience constructor for  Path{T}  object.  source  #  Devices.Paths.pathlength     Method .  pathlength(p::Path)  Physical length of a path. Note that  length  will return the number of segments in a path, not the physical length of the path.  source", 
            "title": "Paths"
        }, 
        {
            "location": "/paths/#segments", 
            "text": "#  Devices.Paths.Segment     Type .  abstract Segment{T :Coordinate}  Path segment in the plane. All Segment objects should have the implement the following methods:   pathlength  p0  \u03b10  setp0!  set\u03b10!  \u03b11   source  #  Devices.Paths.Straight     Type .  type Straight{T}  : ContinuousSegment{T}\n    l::T\n    p0::Point{T}\n    \u03b10::typeof(0.0\u00b0)\n    f::Function\n    Straight(l, p0, \u03b10) = begin\n        s = new(l, p0, \u03b10)\n        s.f = t- (s.p0+Point(t*s.l*cos(s.\u03b10),t*s.l*sin(s.\u03b10)))\n        s\n    end\nend  A straight line segment is parameterized by its length. It begins at a point  p0  with initial angle  \u03b10 .  The parametric function over  t \u2208 [0,1]  describing the line segment is given by:  t -  p0 + Point(t*l*cos(\u03b1),t*l*sin(\u03b1))  source  #  Devices.Paths.Turn     Type .  type Turn{T}  : Segment{T}\n    \u03b1::typeof(1.0\u00b0)\n    r::T\n    p0::Point{T}\n    \u03b10::typeof(1.0\u00b0)\n    f::Function\n    Turn(\u03b1, r, p0, \u03b10) = begin\n        s = new(\u03b1, r, p0, \u03b10)\n        s.f = t- begin\n            cen = s.p0 + Point(s.r*cos(s.\u03b10+sign(s.\u03b1)*\u03c0/2), s.r*sin(s.\u03b10+sign(s.\u03b1)*\u03c0/2))\n            cen + Point(s.r*cos(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t), s.r*sin(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t))\n        end\n        s\n    end\nend  A circular turn is parameterized by the turn angle  \u03b1  and turning radius  r . It begins at a point  p0  with initial angle  \u03b10 .  The center of the circle is given by:  cen = p0 + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))  The parametric function over  t \u2208 [0,1]  describing the turn is given by:  t -  cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))  source  #  Devices.Paths.Corner     Type .  type Corner{T}  : DiscreteSegment{T}\n    \u03b1::typeof(1.0\u00b0)\n    p0::Point{T}\n    \u03b10::typeof(1.0\u00b0)\n    extent::T\n    Corner(a) = new(a, Point(zero(T),zero(T)), 0.0\u00b0, zero(T))\n    Corner(a,b,c,d) = new(a,b,c,d)\nend  A corner, or sudden kink in a path. The only parameter is the angle  \u03b1  of the kink. The kink begins at a point  p0  with initial angle  \u03b10 . It will also end at  p0 , since the corner has zero path length. However, during rendering, neighboring segments will be tweaked slightly so that the rendered path is properly centered about the path function (the rendered corner has a finite width).  source  #  Devices.Paths.CompoundSegment     Type .  type CompoundSegment{T}  : ContinuousSegment{T}\n    segments::Vector{Segment{T}}\n    f::Function\n\n    CompoundSegment(segments) = begin\n        if any(x- isa(x,Corner), segments)\n            error( cannot have corners in a `CompoundSegment`. You may have  ,\n                 tried to simplify a path containing `Corner` objects. )\n        else\n            s = new(deepcopy(Array(segments)))\n            s.f = param(s.segments)\n            s\n        end\n    end\nend  Consider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes. The array of segments given to the constructor is copied and retained by the compound segment.  Note that  Corner s introduce a discontinuity in the derivative of the path function, and are not allowed in a  CompoundSegment .  source", 
            "title": "Segments"
        }, 
        {
            "location": "/paths/#styles", 
            "text": "#  Devices.Paths.Style     Type .  abstract Style{T :Coordinate}  How to render a given path segment. All styles should implement the following methods:   distance  extent  paths  width  divs   source  #  Devices.Paths.ContinuousStyle     Type .  abstract ContinuousStyle{T}  : Style{T}  Any style that applies to segments which have non-zero path length.  source  #  Devices.Paths.DiscreteStyle     Type .  abstract DiscreteStyle{T}  : Style{T}  Any style that applies to segments which have zero path length.  source  #  Devices.Paths.Trace     Type .  type Trace{T}  : ContinuousStyle{T}\n    width::Function\n    divs::Int\nend  Simple, single trace.   width::Function : trace width.  divs::Int : number of segments to render. Increase if you see artifacts.   source  #  Devices.Paths.CPW     Type .  type CPW{T}  : ContinuousStyle{T}\n    trace::Function\n    gap::Function\n    divs::Int\nend  Two adjacent traces can form a coplanar waveguide.   trace::Function : center conductor width.  gap::Function : distance between center conductor edges and ground plane  divs::Int : number of segments to render. Increase if you see artifacts.   May need to be inverted with respect to a ground plane, depending on how the pattern is written.  source  #  Devices.Paths.CompoundStyle     Type .  type CompoundStyle{T}  : ContinuousStyle{T}\n    styles::Vector{Style{T}}\n    divs::Vector{Float64}\n    f::Function\nend  Combines styles together, typically for use with a  CompoundSegment .   styles : Array of styles making up the object. This is shallow-copied   by the outer constructor.   divs : An array of  t  values needed for rendering the parameteric path.  f : returns tuple of style index and the  t  to use for that   style's parametric function.  source  #  Devices.Paths.DecoratedStyle     Type .  type DecoratedStyle{T}  : ContinuousStyle{T}\n    s::Style{T}\n    ts::Array{Float64,1}\n    dirs::Array{Int,1}\n    refs::Array{CellReference{T},1}\n    DecoratedStyle(s) = begin\n        a = new(s)\n        a.ts = Float64[]\n        a.dirs = Int[]\n        a.refs = CellReference{T}[]\n        a\n    end\n    DecoratedStyle(s,t,d,r) = new(s,t,d,r)\nend  Style with decorations, like structures periodically repeated along the path, etc.  source  #  Devices.Paths.undecorated     Function .  undecorated(s::Style)  Returns  s .  source  undecorated(s::DecoratedStyle)  Returns the underlying, undecorated style.  source", 
            "title": "Styles"
        }, 
        {
            "location": "/paths/#path-interrogation", 
            "text": "#  Devices.Paths.direction     Function .  direction(p::Function, t)  For some parameteric function  p(t)\u21a6Point(x(t),y(t)) , returns the angle at which the path is pointing for a given  t .  source  #  Devices.Paths.pathlength     Function .  pathlength{T}(s::Segment{T}, verbose::Bool=false)  Return the length of a segment (calculated).  source  pathlength(p::Path)  Physical length of a path. Note that  length  will return the number of segments in a path, not the physical length of the path.  source  pathlength(p::AbstractArray)  Total physical length of segments.  source  #  Devices.Paths.p0     Function .  p0{T}(s::Segment{T})  Return the first point in a segment (calculated).  source  p0(p::Path)  First point of a path.  source  #  Devices.Paths.setp0!     Function .  setp0!(s::Straight, p::Point)  Set the p0 of a straight segment.  source  setp0!(s::Turn, p::Point)  Set the p0 of a turn.  source  #  Devices.Paths.\u03b10     Function .  \u03b10(s::Segment)  Return the first angle in a segment (calculated).  source  \u03b10(p::Path)  First angle of a path.  source  #  Devices.Paths.set\u03b10!     Function .  set\u03b10!(s::Straight, \u03b10\u2032)  Set the angle of a straight segment.  source  set\u03b10!(s::Turn, \u03b10\u2032)  Set the starting angle of a turn.  source  #  Devices.Paths.p1     Function .  p1{T}(s::Segment{T})  Return the last point in a segment (calculated).  source  p1(p::Path)  Last point of a path.  source  #  Devices.Paths.\u03b11     Function .  \u03b11(s::Segment)  Return the last angle in a segment (calculated).  source  \u03b11(p::Path)  Last angle of a path.  source  #  Devices.Paths.style0     Function .  style0(p::Path)  Style of the first segment of a path.  source  #  Devices.Paths.style1     Function .  style1(p::Path)  Style of the last segment of a path.  source  #  Devices.Paths.discretestyle1     Function .  discretestyle1{T}(p::Path{T})  Returns the last-used discrete style in the path. If one was not used, returns  SimpleCornerStyle() .  source  #  Devices.Paths.contstyle1     Function .  contstyle1(p::Path)  Returns the last-used discrete style in the path. If one was not used, returns  p.style0 .  source", 
            "title": "Path interrogation"
        }, 
        {
            "location": "/paths/#path-building", 
            "text": "#  Base.append!     Method .  append!(p::Path, p\u2032::Path)  Given paths  p  and  p\u2032 , path  p\u2032  is appended to path  p . The p0 and initial angle of the first segment from path  p\u2032  is modified to match the last point and last angle of path  p .  source  #  Devices.Paths.adjust!     Function .  adjust!(p::Path, n::Integer=1)  Adjust a path's parametric functions starting from index  n . Used internally whenever segments are inserted into the path.  source  #  Devices.Paths.attach!     Function .  attach !( p : :Path ,   c : :CellReference ,   t : :Real ;   i : :Integer = length ( p ),   where : :Integer = 0 )   Attach  c  along a path.  By default, the attachment occurs at  t \u2208 [0,1]  along the most recent path segment, but a different path segment index can be specified using  i . The reference is oriented with zero rotation if the path is pointing at 0\u00b0, otherwise it is rotated with the path.  The origin of the cell reference tells the method where to place the cell  with respect to a coordinate system that rotates with the path . Suppose the path is a straight line with angle 0\u00b0. Then an origin of  Point(0.,10.)  will put the cell at 10 above the path, or 10 to the left of the path if it turns left by 90\u00b0.  The  where  option is for convenience. If  where == 0 , nothing special happens. If  where == -1 , then the point of attachment for the reference is on the leftmost edge of the waveguide (the rendered polygons; the path itself has no width). Likewise if  where == 1 , the point of attachment is on the rightmost edge. This option does not automatically rotate the cell reference, apart from what is already done as described in the first paragraph. You can think of this option as setting a special origin for the coordinate system that rotates with the path. For instance, an origin for the cell reference of  Point(0.,10.)  together with  where == -1  will put the cell at 10 above the edge of a rendered (finite width) path with angle 0\u00b0.  source  #  Devices.Paths.corner!     Function .  corner!{T :Coordinate}(p::Path{T}, \u03b1, sty::DiscreteStyle=discretestyle1(p))  Append a sharp turn or \"corner\" to path  p  with angle  \u03b1 .  The style chosen for this corner, if not specified, is the last  DiscreteStyle  used in the path, or  SimpleCornerStyle  if one has not been used yet.  source  #  Devices.Paths.meander!     Function .  meander!{T :Real}(p::Path{T}, len, r, straightlen, \u03b1::Real)  Alternate between going straight with length  straightlen  and turning with radius  r  and angle  \u03b1 . Each turn goes the opposite direction of the previous. The total length is  len . Useful for making resonators.  The straight and turn segments are combined into a  CompoundSegment  and appended to the path  p .  source  #  Devices.Paths.param     Function .  param{T :Coordinate}(c::AbstractVector{Segment{T}})  Return a parametric function over the domain [0,1] that represents the compound segments.  source  #  Devices.Paths.simplify     Function .  simplify(p::Path, inds::UnitRange=1:length(p))  At  inds , segments of a path are turned into a  CompoundSegment  and styles of a path are turned into a  CompoundStyle . The method returns a tuple,  (segment, style) .   Indexing the path becomes more sane when you can combine several path   segments into one logical element. A launcher would have several indices in a path unless you could simplify it.   You don't need to think hard about boundaries between straights and turns   when you want a continuous styling of a very long path.  source  #  Devices.Paths.simplify!     Function .  simplify!(p::Path, inds::UnitRange=1:length(p))  In-place version of  simplify .  source  #  Devices.Paths.straight!     Function .  straight!{T :Coordinate}(p::Path{T}, l::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))  Extend a path  p  straight by length  l  in the current direction. By default, we take the last continuous style in the path.  source  #  Devices.Paths.turn!     Function .  turn!{T :Coordinate}(p::Path{T}, \u03b1, r::Coordinate, sty::Style=style1(p))  Turn a path  p  by angle  \u03b1  with a turning radius  r  in the current direction. Positive angle turns left.  source  turn!{T :Coordinate}(p::Path{T}, s::String, r::Coordinate,\n    sty::ContinuousStyle=contstyle1(p))  Turn a path  p  with direction coded by string  s :   \"l\": turn by \u03c0/2 radians (left)  \"r\": turn by -\u03c0/2 radians (right)  \"lrlrllrrll\": do those turns in that order   By default, we take the last continuous style in the path.  source", 
            "title": "Path building"
        }, 
        {
            "location": "/paths/#attachments", 
            "text": "When you call  attach! , you are defining a coordinate system local to somewhere along the target  Path , saying that a  CellReference  should be placed at the origin of that coordinate system (or slightly away from it if you want the cell to be one one side of the path or the other). The local coordinate system will rotate as the path changes orientations. The origin of the  CellReference  corresponds how the referenced cell should be displaced with respect to the origin of the local coordinate system. This differs from the usual meaning of the origin of a  CellReference , which is how the referenced cell should be displaced with respect to the origin of a containing  Cell .  The same  CellReference  can be attached to multiple points along multiple paths. If the cell reference is modified (e.g. rotation, origin, magnification) before rendering, the changes should be reflected at all attachment points. The attachment of the cell reference is in some sense an abstraction: a  CellReference  must ultimately live inside a  Cell , but an unrendered  Path  does not live inside any cell. If the path is modified further before rendering, the attachment points should follow the path modifications, moving the origins of the local coordinate systems. The origin fields of the cell references do not change as the path is modified.  Attachments are implemented by introducing a  Paths.DecoratedStyle , which is kind of a meta- Style : it remembers where to attach  CellReferences , but how the path itself is actually drawn is deferred to a different  Style  object that it retains a reference to. One can repeat a  DecoratedStyle  with one attachment to achieve a periodic placement of  CellReferences  (like a  CellArray , but along the path). Or, one long segment with a  DecoratedStyle  could have several attachments to achieve a similar effect.  When a  Path  is rendered, it is turned into  Polygons  living in some  Cell . The attachments remain  CellReferences , now living inside of a  Cell  and not tied to an abstract path. The notion of local coordinate systems along the path no longer makes sense because the abstract path has been made concrete, and the polygons are living in the coordinate system of the containing cell. Each attachment to the former path now must have its origin referenced to the origin of the containing cell, not to local path coordinate systems. Additionally, the references may need to rotate according to how the path was locally oriented. As a result, even if the same  CellReference  was attached multiple times to a path, now we need distinct  CellReference  objects for each attachment, as well as for each time a corresponding  DecoratedStyle  is rendered.  Suppose we want the ability to transform between coordinate systems, especially between the coordinate system of a referenced cell and the coordinate system of a parent cell. At first glance it would seem like we could simply define a transform function, taking the parent cell and the cell reference we are interested in. But how would we actually identify the particular cell reference we want? Looking in the tree of references for an attached  CellReference  will not work: distinct  CellReferences  needed to be made after the path was rendered, and so the particular  CellReference  object initially attached is not actually in the  Cell  containing the rendered path.  To overcome this problem, we make searching for the appropriate  CellReference  easier. Suppose a path with attachments has been rendered to a  Cell , which is bound to symbol  aaa . A  CellReference  referring to a cell named \"bbb\" was attached twice. To recall the second attachment:  aaa[\"bbb\",2]  (the index defaults to 1 if unspecified). We can go deeper if we want to refer to references inside that attachment:  aaa[\"bbb\",2][\"ccc\"] . In this manner, it is easy to find the right  CellReference  to use with  Cells.transform(::Cell, ::Cells.CellRef) .", 
            "title": "Attachments"
        }, 
        {
            "location": "/paths/#interfacing-with-gdspy", 
            "text": "The Python package  gdspy  is used for rendering paths into polygons. Ultimately we intend to remove this dependency.  #  Devices.Paths.distance     Function .  For a style  s  and parameteric argument  t , returns the distance between the centers of parallel paths rendered by gdspy.  source  #  Devices.Paths.extent     Function .  For a style  s  and parameteric argument  t , returns a distance tangential to the path specifying the lateral extent of the polygons rendered by gdspy.  source  #  Devices.Paths.paths     Function .  For a style  s  and parameteric argument  t , returns the number of parallel paths rendered by gdspy.  source  #  Devices.Paths.width     Function .  For a style  s  and parameteric argument  t , returns the width of paths rendered by gdspy.  source", 
            "title": "Interfacing with gdspy"
        }, 
        {
            "location": "/tags/", 
            "text": "For convenience\n\n\n#\n\n\nDevices.Tags.qrcode!\n \n \nFunction\n.\n\n\nqrcode\n!\n{\nT\n:\nCoordinate\n}\n(\na\n:\n:AbstractString\n,\n \nc\n:\n:Cell\n{\nT\n}\n;\n \npixel\n:\n:T\n=\nT\n(\n1\n),\n \nkwargs\n...)\n\n\n\n\n\n\nRenders a QR code of the string \na\n with pixel size \npixel\n to cell \nc\n. The pixel size defaults to one of whatever the cell's unit is. The lower left of the QR code will be at the origin of the cell.\n\n\nsource\n\n\n#\n\n\nDevices.Tags.radialcut\n \n \nFunction\n.\n\n\nradialcut\n{\nT\n:\nCoordinate\n}\n(\nr\n:\n:T\n,\n \n\u0398\n,\n \nc\n:\n:T\n;\n \nnarc\n=\n197\n)\n\n\n\n\n\n\nReturns a polygon for a radial cut (like a radial stub with no metal). The polygon has to be subtracted from a ground plane.\n\n\nThe parameter \nc\n is made available in the method signature rather than \na\n because the focus of the arc (top of polygon) can easily centered in a waveguide. If it is desirable to control \na\n instead, use trig: \na/2 = c*tan(\u0398/2)\n.\n\n\nParameters as follows, where X marks the origin and nothing above the origin is part of the resulting polygon:\n\n\n                          \u039b\n                         \u2571\u2502\u2572\n                        \u2571 \u2502 \u2572\n                       \u2571  |  \u2572\n                 .    \u2571   \u2502\u0398/2\u2572\n                .    \u2571    \u2502----\u2572\n               \u2571    \u2571   c \u2502     \u2572\n              \u2571    \u2571      \u2502      \u2572\n             \u2571    \u2571       \u2502       \u2572\n            r    \u2571        \u2502        \u2572\n           \u2571    \u2571         \u2502         \u2572\n          \u2571    \u2571\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2572\n         \u2571    \u2571 {\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500} \u2572\n        .    \u2571                         \u2572\n       .    \u2571                           \u2572\n           \u2571                             \u2572\n          \u2571                               \u2572\n         \u2571                                 \u2572\n         \u2500\u2500\u2510                             \u250c\u2500\u2500\n           \u2514\u2500\u2500\u2510                       \u250c\u2500\u2500\u2518\n              \u2514\u2500\u2500\u2510                 \u250c\u2500\u2500\u2518\n                 \u2514\u2500\u2500\u2510           \u250c\u2500\u2500\u2518\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    (circular arc)\n\n\n\n\n\nsource\n\n\n#\n\n\nDevices.Tags.radialstub\n \n \nFunction\n.\n\n\nradialstub\n{\nT\n:\nCoordinate\n}\n(\nr\n:\n:T\n,\n \n\u0398\n,\n \nc\n:\n:T\n,\n \nt\n:\n:T\n;\n \nnarc\n=\n197\n)\n\n\n\n\n\n\nSee also the documentation for \nradialcut\n.\n\n\nReturns a polygon for a radial stub. The polygon has to be subtracted from a ground plane, and will leave a defect in the ground plane of uniform width \nt\n that outlines the (metallic) radial stub. \nr\n refers to the radius of the actual stub, not the radius of the circular arc bounding the ground plane defect. Likewise \nc\n has an analogous meaning to that in \nradialcut\n except it refers here to the radial stub, not the ground plane defect.\n\n\nsource\n\n\n#\n\n\nDevices.Tags.checkerboard\n \n \nFunction\n.\n\n\ncheckerboard\n{\nT\n:\nCoordinate\n}\n(\npixsize\n:\n:T\n=\n10\n.;\n \nrows\n=\n28\n,\n \nkwargs\n...)\n\n\n\n\n\n\nGenerate a checkerboard pattern suitable for contrast curve measurement, or getting the base dose for BEAMER PEC. Returns a uniquely named cell with the rendered polygons inside.\n\n\nNote that the tip radius of the Ambios XP-2 profilometer in the KNI is 2.5\u03bcm.\n\n\nsource\n\n\n#\n\n\nDevices.Tags.pecbasedose\n \n \nFunction\n.\n\n\npecbasedose(kwargs...)\n\n\n\n\n\nGenerate lines and spaces suitable for obtaining the base dose for BEAMER PEC (100 keV on Si).\n\n\nTo do: Modify to be more flexible for other substrates, beam energies, etc.\n\n\nsource\n\n\n#\n\n\nDevices.Tags.surf1d\n \n \nFunction\n.\n\n\nsurf1d(length, width, contour_fn; zbins=20, step=1., max_seg_len=1.)\n\n\n\n\n\nGiven \nlength\n and \nwidth\n of a rectangular patch, this generates a mesh for 3D surface PEC according to a particular contour function \ncontour_fn\n. The meshing is done in the length direction (+y). The number of bins (layers) can be controlled with \nzbins\n, the maximum step change in the resist height is given by \nstep\n, and the \nmax_seg_len\n is the maximum segment length in the mesh.\n\n\nsource", 
            "title": "For convenience"
        }, 
        {
            "location": "/tags/#for-convenience", 
            "text": "#  Devices.Tags.qrcode!     Function .  qrcode ! { T : Coordinate } ( a : :AbstractString ,   c : :Cell { T } ;   pixel : :T = T ( 1 ),   kwargs ...)   Renders a QR code of the string  a  with pixel size  pixel  to cell  c . The pixel size defaults to one of whatever the cell's unit is. The lower left of the QR code will be at the origin of the cell.  source  #  Devices.Tags.radialcut     Function .  radialcut { T : Coordinate } ( r : :T ,   \u0398 ,   c : :T ;   narc = 197 )   Returns a polygon for a radial cut (like a radial stub with no metal). The polygon has to be subtracted from a ground plane.  The parameter  c  is made available in the method signature rather than  a  because the focus of the arc (top of polygon) can easily centered in a waveguide. If it is desirable to control  a  instead, use trig:  a/2 = c*tan(\u0398/2) .  Parameters as follows, where X marks the origin and nothing above the origin is part of the resulting polygon:                            \u039b\n                         \u2571\u2502\u2572\n                        \u2571 \u2502 \u2572\n                       \u2571  |  \u2572\n                 .    \u2571   \u2502\u0398/2\u2572\n                .    \u2571    \u2502----\u2572\n               \u2571    \u2571   c \u2502     \u2572\n              \u2571    \u2571      \u2502      \u2572\n             \u2571    \u2571       \u2502       \u2572\n            r    \u2571        \u2502        \u2572\n           \u2571    \u2571         \u2502         \u2572\n          \u2571    \u2571\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500X\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2572\n         \u2571    \u2571 {\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 a \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500} \u2572\n        .    \u2571                         \u2572\n       .    \u2571                           \u2572\n           \u2571                             \u2572\n          \u2571                               \u2572\n         \u2571                                 \u2572\n         \u2500\u2500\u2510                             \u250c\u2500\u2500\n           \u2514\u2500\u2500\u2510                       \u250c\u2500\u2500\u2518\n              \u2514\u2500\u2500\u2510                 \u250c\u2500\u2500\u2518\n                 \u2514\u2500\u2500\u2510           \u250c\u2500\u2500\u2518\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    (circular arc)  source  #  Devices.Tags.radialstub     Function .  radialstub { T : Coordinate } ( r : :T ,   \u0398 ,   c : :T ,   t : :T ;   narc = 197 )   See also the documentation for  radialcut .  Returns a polygon for a radial stub. The polygon has to be subtracted from a ground plane, and will leave a defect in the ground plane of uniform width  t  that outlines the (metallic) radial stub.  r  refers to the radius of the actual stub, not the radius of the circular arc bounding the ground plane defect. Likewise  c  has an analogous meaning to that in  radialcut  except it refers here to the radial stub, not the ground plane defect.  source  #  Devices.Tags.checkerboard     Function .  checkerboard { T : Coordinate } ( pixsize : :T = 10 .;   rows = 28 ,   kwargs ...)   Generate a checkerboard pattern suitable for contrast curve measurement, or getting the base dose for BEAMER PEC. Returns a uniquely named cell with the rendered polygons inside.  Note that the tip radius of the Ambios XP-2 profilometer in the KNI is 2.5\u03bcm.  source  #  Devices.Tags.pecbasedose     Function .  pecbasedose(kwargs...)  Generate lines and spaces suitable for obtaining the base dose for BEAMER PEC (100 keV on Si).  To do: Modify to be more flexible for other substrates, beam energies, etc.  source  #  Devices.Tags.surf1d     Function .  surf1d(length, width, contour_fn; zbins=20, step=1., max_seg_len=1.)  Given  length  and  width  of a rectangular patch, this generates a mesh for 3D surface PEC according to a particular contour function  contour_fn . The meshing is done in the length direction (+y). The number of bins (layers) can be controlled with  zbins , the maximum step change in the resist height is given by  step , and the  max_seg_len  is the maximum segment length in the mesh.  source", 
            "title": "For convenience"
        }, 
        {
            "location": "/render/", 
            "text": "Rectangle styles\n\n\n#\n\n\nDevices.Rectangles.Plain\n \n \nType\n.\n\n\ntype Plain \n: Style end\n\n\n\n\n\nPlain rectangle style. Use this if you are fond for the simpler times when rectangles were just rectangles.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Rounded\n \n \nType\n.\n\n\ntype Rounded{T\n:Coordinate} \n: Style\n    r::T\nend\n\n\n\n\n\nRounded rectangle style. All corners are rounded off with a given radius \nr\n. The bounding box of the unstyled rectangle should remain unaffected.\n\n\nsource\n\n\n#\n\n\nDevices.Rectangles.Undercut\n \n \nType\n.\n\n\ntype Undercut{T\n:Coordinate} \n: Style\n    ucl::T\n    uct::T\n    ucr::T\n    ucb::T\nend\n\n\n\n\n\nUndercut rectangles. In each direction around a rectangle (left, top, right, bottom) an undercut is rendered on a different layer.\n\n\nsource\n\n\n\n\nPolygon styles\n\n\n#\n\n\nDevices.Polygons.Plain\n \n \nType\n.\n\n\nPlain polygon style.\n\n\nsource\n\n\n\n\nRender methods\n\n\n#\n\n\nDevices.render!\n \n \nFunction\n.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \ns\n:\n:Rectangles\n.Style\n=\nRectangles\n.Plain\n();\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rectangle \nr\n to cell \nc\n, defaulting to plain styling.\n\n\nReturns an array of the AbstractPolygons added to the cell.\n\n\nsource\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \n:\n:Rectangles\n.Plain\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rectangle \nr\n to cell \nc\n with plain styling.\n\n\nReturns an array with the rectangle in it.\n\n\nsource\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \ns\n:\n:Rectangles\n.Rounded\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rounded rectangle \nr\n to cell \nc\n. This is accomplished by rendering a path around the outside of a (smaller than requested) solid rectangle. The bounding box of \nr\n is preserved.\n\n\nReturns an array of the AbstractPolygons added to the cell.\n\n\nsource\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \ns\n:\n:Rectangles\n.Undercut\n;\n\n    \nlayer\n=\n0\n,\n \nuclayer\n=\n0\n,\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rectangle \nr\n to cell \nc\n. Additionally, put a hollow border around the rectangle with layer \nuclayer\n. Useful for undercut structures.\n\n\nReturns an array of the AbstractPolygons added to the cell.\n\n\nsource\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Polygon\n,\n \ns\n:\n:Polygons\n.Style\n=\nPolygons\n.Plain\n();\n \nkwargs\n...)\n\n\n\n\n\n\nRender a polygon \nr\n to cell \nc\n, defaulting to plain styling.\n\n\nsource\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \np\n:\n:Path\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a path \np\n to a cell \nc\n.\n\n\nsource\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nsegment\n:\n:Paths\n.Segment\n,\n \ns\n:\n:Paths\n.Style\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a \nsegment\n with style \ns\n to cell \nc\n.\n\n\nsource\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nsegment\n:\n:Paths\n.Segment\n,\n \ns\n:\n:Paths\n.DecoratedStyle\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a \nsegment\n with decorated style \ns\n to cell \nc\n. Cell references held by the decorated style will have their fields modified by this method, which is why they are shallow copied in the \nPaths.attach!\n function.\n\n\nThis method draws the decorations before the path itself is drawn.\n\n\nsource", 
            "title": "Rendering"
        }, 
        {
            "location": "/render/#rectangle-styles", 
            "text": "#  Devices.Rectangles.Plain     Type .  type Plain  : Style end  Plain rectangle style. Use this if you are fond for the simpler times when rectangles were just rectangles.  source  #  Devices.Rectangles.Rounded     Type .  type Rounded{T :Coordinate}  : Style\n    r::T\nend  Rounded rectangle style. All corners are rounded off with a given radius  r . The bounding box of the unstyled rectangle should remain unaffected.  source  #  Devices.Rectangles.Undercut     Type .  type Undercut{T :Coordinate}  : Style\n    ucl::T\n    uct::T\n    ucr::T\n    ucb::T\nend  Undercut rectangles. In each direction around a rectangle (left, top, right, bottom) an undercut is rendered on a different layer.  source", 
            "title": "Rectangle styles"
        }, 
        {
            "location": "/render/#polygon-styles", 
            "text": "#  Devices.Polygons.Plain     Type .  Plain polygon style.  source", 
            "title": "Polygon styles"
        }, 
        {
            "location": "/render/#render-methods", 
            "text": "#  Devices.render!     Function .  render !( c : :Cell ,   r : :Rectangle ,   s : :Rectangles .Style = Rectangles .Plain ();   kwargs ...)   Render a rectangle  r  to cell  c , defaulting to plain styling.  Returns an array of the AbstractPolygons added to the cell.  source  render !( c : :Cell ,   r : :Rectangle ,   : :Rectangles .Plain ;   kwargs ...)   Render a rectangle  r  to cell  c  with plain styling.  Returns an array with the rectangle in it.  source  render !( c : :Cell ,   r : :Rectangle ,   s : :Rectangles .Rounded ;   kwargs ...)   Render a rounded rectangle  r  to cell  c . This is accomplished by rendering a path around the outside of a (smaller than requested) solid rectangle. The bounding box of  r  is preserved.  Returns an array of the AbstractPolygons added to the cell.  source  render !( c : :Cell ,   r : :Rectangle ,   s : :Rectangles .Undercut ; \n     layer = 0 ,   uclayer = 0 ,   kwargs ...)   Render a rectangle  r  to cell  c . Additionally, put a hollow border around the rectangle with layer  uclayer . Useful for undercut structures.  Returns an array of the AbstractPolygons added to the cell.  source  render !( c : :Cell ,   r : :Polygon ,   s : :Polygons .Style = Polygons .Plain ();   kwargs ...)   Render a polygon  r  to cell  c , defaulting to plain styling.  source  render !( c : :Cell ,   p : :Path ;   kwargs ...)   Render a path  p  to a cell  c .  source  render !( c : :Cell ,   segment : :Paths .Segment ,   s : :Paths .Style ;   kwargs ...)   Render a  segment  with style  s  to cell  c .  source  render !( c : :Cell ,   segment : :Paths .Segment ,   s : :Paths .DecoratedStyle ;   kwargs ...)   Render a  segment  with decorated style  s  to cell  c . Cell references held by the decorated style will have their fields modified by this method, which is why they are shallow copied in the  Paths.attach!  function.  This method draws the decorations before the path itself is drawn.  source", 
            "title": "Render methods"
        }, 
        {
            "location": "/fileio/", 
            "text": "This package can load/save patterns in the GDS-II format only. In the future it may be useful to implement machine-specific pattern formats to force fracturing or dosing in an explicit manner.\n\n\n\n\nLoading patterns\n\n\nTo load a pattern, make sure you are \nusing FileIO\n.\n\n\n#\n\n\nFileIO.load\n \n \nMethod\n.\n\n\nload\n(\nf\n:\n:File\n{\nformat\nGDS\n}\n;\n \nverbose\n=\nfalse\n)\n\n\n\n\n\n\nA dictionary of top-level cells (\nCell\n objects) found in the GDS-II file is returned. The dictionary keys are the cell names. The other cells in the GDS-II file are retained by \nCellReference\n or \nCellArray\n objects held by the top-level cells. Currently, cell references and arrays are not implemented.\n\n\nThe FileIO package recognizes files based on \"magic bytes\" at the start of the file. To permit any version of GDS-II file to be read, we consider the magic bytes to be the GDS HEADER tag (\n0x0002\n), preceded by the number of bytes in total (\n0x0006\n) for the entire HEADER record. The last well-documented version of GDS-II is v6.0.0, encoded as \n0x0258 == 600\n. LayoutEditor appears to save a version 7 as \n0x0007\n, which as far as I can tell is unofficial, and probably just permits more layers than 64, or extra characters in cell names, etc.\n\n\nIf the database scale is \n1\u03bcm\n, \n1nm\n, or \n1pm\n, then the corresponding unit is used for the resulting imported cells. Otherwise, an \"anonymous unit\" is used that will display as \nu\"2.4\u03bcm\"\n if the database scale is 2.4\u03bcm, say.\n\n\nWarnings are thrown if the GDS-II file does not begin with a BGNLIB record following the HEADER record, but loading will proceed.\n\n\nEncountering an ENDLIB record will discard the remainder of the GDS-II file without warning. If no ENDLIB record is present, a warning will be thrown.\n\n\nThe content of some records are currently discarded (mainly the more obscure GDS-II record types, but also BGNLIB and LIBNAME).\n\n\nsource\n\n\n\n\nSaving patterns\n\n\nTo save a pattern, make sure you are \nusing FileIO\n.\n\n\n#\n\n\nFileIO.save\n \n \nMethod\n.\n\n\nsave\n(:\n:Union\n{\nAbstractString\n,\nIO\n}\n,\n \ncell0\n:\n:Cell\n{\nT\n}\n,\n \ncell\n:\n:Cell\n...)\n\n\n\nsave\n(\nf\n:\n:File\n{\nformat\nGDS\n}\n,\n \ncell0\n:\n:Cell\n,\n \ncell\n:\n:Cell\n...;\n\n\nname\n=\nGDSIILIB\n,\n \nuserunit\n=\n1\n\u03bc\nm\n,\n \nmodify\n=\nnow\n(),\n \nacc\n=\nnow\n(),\n\n\nverbose\n=\nfalse\n)\n`\n\n\n\n\n\n\nThis bottom method is implicitly called when you use the convenient syntax of the top method: \nsave(\"/path/to/my.gds\", cells_i_want_to_save...)\n\n\nThe \nname\n keyword argument is used for the internal library name of the GDS-II file and is probably inconsequential for modern workflows.\n\n\nThe \nuserunit\n keyword sets what 1.0 corresponds to when viewing this file in graphical GDS editors with inferior unit support.\n\n\nThe \nmodify\n and \nacc\n keywords correspond to the date of last modification and the date of last accession. It would be unusual to have this differ from \nnow()\n.\n\n\nThe \nverbose\n keyword argument allows you to monitor the output of \ntraverse!\n and \norder!\n if something funny is happening while saving.\n\n\nsource\n\n\n\n\nInternals\n\n\n#\n\n\nDevices.GDS.GDSFloat\n \n \nType\n.\n\n\nabstract GDSFloat \n: Real\n\n\nFloating-point formats found in GDS-II files.\n\n\nsource\n\n\n#\n\n\nDevices.GDS.GDS64\n \n \nType\n.\n\n\nbitstype 64 GDS64 \n: GDSFloat\n\n\n\"8-byte (64-bit) real\" format found in GDS-II files.\n\n\nsource\n\n\n#\n\n\nBase.bits\n \n \nMethod\n.\n\n\nbits(x::GDS64)\n\n\nA string giving the literal bit representation of a GDS64 number.\n\n\nsource\n\n\n#\n\n\nBase.bswap\n \n \nMethod\n.\n\n\nbswap(x::GDS64)\n\n\nByte-swap a GDS64 number. Used implicitly by \nhton\n, \nntoh\n for endian conversion.\n\n\nsource\n\n\n#\n\n\nDevices.GDS.gdswrite\n \n \nFunction\n.\n\n\ngdswrite(io::IO, cell::Cell, dbs::Length)\n\n\n\n\n\nWrite a \nCell\n to an IO buffer. The creation and modification date of the cell are written first, followed by the cell name, the polygons in the cell, and finally any references or arrays.\n\n\nsource\n\n\ngdswrite{T\n:Real}(io::IO, el::Polygon{T}, dbs)\ngdswrite{T\n:Length}(io::IO, poly::Polygon{T}, dbs)\n\n\n\n\n\nWrite a polygon to an IO buffer. The layer and datatype are written first, then the boundary of the polygon is written in a 32-bit integer format with specified database scale.\n\n\nNote that polygons without units are presumed to be in microns.\n\n\nsource\n\n\ngdswrite{T\n:Real}(io::IO, ref::CellReference{T}, dbs)\ngdswrite{T\n:Length}(io::IO, el::CellReference{T}, dbs)\n\n\n\n\n\nWrite a \nCellReference\n to an IO buffer. The name of the referenced cell is written first. Reflection, magnification, and rotation info are written next. Finally, the origin of the cell reference is written.\n\n\nNote that cell references without units on their \norigin\n are presumed to be in microns.\n\n\nsource\n\n\ngdswrite(io::IO, a::CellArray, dbs)\n\n\n\n\n\nWrite a \nCellArray\n to an IO buffer. The name of the referenced cell is written first. Reflection, magnification, and rotation info are written next. After that the number of columns and rows are written. Finally, the origin, column vector, and row vector are written.\n\n\nNote that cell references without units on their \norigin\n are presumed to be in microns.\n\n\nsource\n\n\n#\n\n\nDevices.GDS.strans\n \n \nFunction\n.\n\n\nstrans(io::IO, ref)\n\n\n\n\n\nWrites bytes to the IO stream (if needed) to encode x-reflection, magnification, and rotation settings of a reference or array. Returns the number of bytes written.\n\n\nsource\n\n\n#\n\n\nBase.write\n \n \nMethod\n.\n\n\nwrite(s::IO, x::GDS64)\n\n\n\n\n\nWrite a GDS64 number to an IO stream.\n\n\nsource\n\n\n#\n\n\nBase.read\n \n \nMethod\n.\n\n\nread(s::IO, ::Type{GDS64})\n\n\n\n\n\nRead a GDS64 number from an IO stream.\n\n\nsource", 
            "title": "File formats"
        }, 
        {
            "location": "/fileio/#loading-patterns", 
            "text": "To load a pattern, make sure you are  using FileIO .  #  FileIO.load     Method .  load ( f : :File { format GDS } ;   verbose = false )   A dictionary of top-level cells ( Cell  objects) found in the GDS-II file is returned. The dictionary keys are the cell names. The other cells in the GDS-II file are retained by  CellReference  or  CellArray  objects held by the top-level cells. Currently, cell references and arrays are not implemented.  The FileIO package recognizes files based on \"magic bytes\" at the start of the file. To permit any version of GDS-II file to be read, we consider the magic bytes to be the GDS HEADER tag ( 0x0002 ), preceded by the number of bytes in total ( 0x0006 ) for the entire HEADER record. The last well-documented version of GDS-II is v6.0.0, encoded as  0x0258 == 600 . LayoutEditor appears to save a version 7 as  0x0007 , which as far as I can tell is unofficial, and probably just permits more layers than 64, or extra characters in cell names, etc.  If the database scale is  1\u03bcm ,  1nm , or  1pm , then the corresponding unit is used for the resulting imported cells. Otherwise, an \"anonymous unit\" is used that will display as  u\"2.4\u03bcm\"  if the database scale is 2.4\u03bcm, say.  Warnings are thrown if the GDS-II file does not begin with a BGNLIB record following the HEADER record, but loading will proceed.  Encountering an ENDLIB record will discard the remainder of the GDS-II file without warning. If no ENDLIB record is present, a warning will be thrown.  The content of some records are currently discarded (mainly the more obscure GDS-II record types, but also BGNLIB and LIBNAME).  source", 
            "title": "Loading patterns"
        }, 
        {
            "location": "/fileio/#saving-patterns", 
            "text": "To save a pattern, make sure you are  using FileIO .  #  FileIO.save     Method .  save (: :Union { AbstractString , IO } ,   cell0 : :Cell { T } ,   cell : :Cell ...)  save ( f : :File { format GDS } ,   cell0 : :Cell ,   cell : :Cell ...;  name = GDSIILIB ,   userunit = 1 \u03bc m ,   modify = now (),   acc = now (),  verbose = false ) `   This bottom method is implicitly called when you use the convenient syntax of the top method:  save(\"/path/to/my.gds\", cells_i_want_to_save...)  The  name  keyword argument is used for the internal library name of the GDS-II file and is probably inconsequential for modern workflows.  The  userunit  keyword sets what 1.0 corresponds to when viewing this file in graphical GDS editors with inferior unit support.  The  modify  and  acc  keywords correspond to the date of last modification and the date of last accession. It would be unusual to have this differ from  now() .  The  verbose  keyword argument allows you to monitor the output of  traverse!  and  order!  if something funny is happening while saving.  source", 
            "title": "Saving patterns"
        }, 
        {
            "location": "/fileio/#internals", 
            "text": "#  Devices.GDS.GDSFloat     Type .  abstract GDSFloat  : Real  Floating-point formats found in GDS-II files.  source  #  Devices.GDS.GDS64     Type .  bitstype 64 GDS64  : GDSFloat  \"8-byte (64-bit) real\" format found in GDS-II files.  source  #  Base.bits     Method .  bits(x::GDS64)  A string giving the literal bit representation of a GDS64 number.  source  #  Base.bswap     Method .  bswap(x::GDS64)  Byte-swap a GDS64 number. Used implicitly by  hton ,  ntoh  for endian conversion.  source  #  Devices.GDS.gdswrite     Function .  gdswrite(io::IO, cell::Cell, dbs::Length)  Write a  Cell  to an IO buffer. The creation and modification date of the cell are written first, followed by the cell name, the polygons in the cell, and finally any references or arrays.  source  gdswrite{T :Real}(io::IO, el::Polygon{T}, dbs)\ngdswrite{T :Length}(io::IO, poly::Polygon{T}, dbs)  Write a polygon to an IO buffer. The layer and datatype are written first, then the boundary of the polygon is written in a 32-bit integer format with specified database scale.  Note that polygons without units are presumed to be in microns.  source  gdswrite{T :Real}(io::IO, ref::CellReference{T}, dbs)\ngdswrite{T :Length}(io::IO, el::CellReference{T}, dbs)  Write a  CellReference  to an IO buffer. The name of the referenced cell is written first. Reflection, magnification, and rotation info are written next. Finally, the origin of the cell reference is written.  Note that cell references without units on their  origin  are presumed to be in microns.  source  gdswrite(io::IO, a::CellArray, dbs)  Write a  CellArray  to an IO buffer. The name of the referenced cell is written first. Reflection, magnification, and rotation info are written next. After that the number of columns and rows are written. Finally, the origin, column vector, and row vector are written.  Note that cell references without units on their  origin  are presumed to be in microns.  source  #  Devices.GDS.strans     Function .  strans(io::IO, ref)  Writes bytes to the IO stream (if needed) to encode x-reflection, magnification, and rotation settings of a reference or array. Returns the number of bytes written.  source  #  Base.write     Method .  write(s::IO, x::GDS64)  Write a GDS64 number to an IO stream.  source  #  Base.read     Method .  read(s::IO, ::Type{GDS64})  Read a GDS64 number from an IO stream.  source", 
            "title": "Internals"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The Devices.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}