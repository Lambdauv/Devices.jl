{
    "docs": [
        {
            "location": "/", 
            "text": "Devices.jl\n\n\nA \nJulia\n package for designing CAD files for superconducting devices.\n\n\n\n\nInstallation\n\n\n\n\nInstall Python packages\n\n\n\n\n\n\nInstall \ngdspy\n, which is currently used only for rendering paths into polygons: \npip install gdspy\n. Ensure that it is accessible from the Python installation that PyCall.jl is using. If the installation fails, it may be failing because it is trying to compile the Clipper library. We will use a Julia package for Clipper anyway. Try installing an older version of gdspy that does not have the Clipper library: \npip install 'gdspy==0.7.1' --force-reinstall\n.\n\n\n\n\n\n\nInstall \npyqrcode\n, which is used for generating QR codes: \npip install pyqrcode\n.\n\n\n\n\n\n\n\n\nInstall Julia packages\n\n\nWe use a custom version of the Clipper package, which we will need for making polygons compatible with GDS files.\n\n\n\n\nPkg.clone(\"https://github.com/ajkeller34/Clipper.jl.git\")\n\n\nPkg.checkout(\"Clipper\", \"pointinpoly\")\n\n\n\n\nYou will need to build the package to compile shared library / DLL files. This should just work on Mac OS X, and should also work on Windows provided you install Visual Studio and ensure that \nvcvarsall.bat\n and \ncl.exe\n are in your account's PATH variable.\n\n\n\n\nPkg.build(\"Clipper\")\n\n\n\n\n\n\nAnd finally...\n\n\n\n\nPkg.clone(\"https://github.com/ajkeller34/Devices.jl.git\")\n\n\n\n\n\n\nQuick start\n\n\nusing Devices, FileIO\n\np = Path()\nstyle = launch!(p)\nstraight!(p,500,style)\nturn!(p,\u03c0/2,150)\nstraight!(p,500)\nlaunch!(p)\nc = Cell(\nmain\n)\nrender!(c, p)\nsave(\ntest.gds\n, c)\n\n\n\n\n\n\n\nTroubleshooting\n\n\n\n\nIf you cannot save the GDS file, try deleting any file that happens to be at the target path.\n\n\nDecorated styles should not become part of compound styles, for now. Avoid this by decorating / attaching cell references at the end.", 
            "title": "Home"
        }, 
        {
            "location": "/#devicesjl", 
            "text": "A  Julia  package for designing CAD files for superconducting devices.", 
            "title": "Devices.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/#install-python-packages", 
            "text": "Install  gdspy , which is currently used only for rendering paths into polygons:  pip install gdspy . Ensure that it is accessible from the Python installation that PyCall.jl is using. If the installation fails, it may be failing because it is trying to compile the Clipper library. We will use a Julia package for Clipper anyway. Try installing an older version of gdspy that does not have the Clipper library:  pip install 'gdspy==0.7.1' --force-reinstall .    Install  pyqrcode , which is used for generating QR codes:  pip install pyqrcode .", 
            "title": "Install Python packages"
        }, 
        {
            "location": "/#install-julia-packages", 
            "text": "We use a custom version of the Clipper package, which we will need for making polygons compatible with GDS files.   Pkg.clone(\"https://github.com/ajkeller34/Clipper.jl.git\")  Pkg.checkout(\"Clipper\", \"pointinpoly\")   You will need to build the package to compile shared library / DLL files. This should just work on Mac OS X, and should also work on Windows provided you install Visual Studio and ensure that  vcvarsall.bat  and  cl.exe  are in your account's PATH variable.   Pkg.build(\"Clipper\")", 
            "title": "Install Julia packages"
        }, 
        {
            "location": "/#and-finally", 
            "text": "Pkg.clone(\"https://github.com/ajkeller34/Devices.jl.git\")", 
            "title": "And finally..."
        }, 
        {
            "location": "/#quick-start", 
            "text": "using Devices, FileIO\n\np = Path()\nstyle = launch!(p)\nstraight!(p,500,style)\nturn!(p,\u03c0/2,150)\nstraight!(p,500)\nlaunch!(p)\nc = Cell( main )\nrender!(c, p)\nsave( test.gds , c)", 
            "title": "Quick start"
        }, 
        {
            "location": "/#troubleshooting", 
            "text": "If you cannot save the GDS file, try deleting any file that happens to be at the target path.  Decorated styles should not become part of compound styles, for now. Avoid this by decorating / attaching cell references at the end.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/points/", 
            "text": "Points are implemented using the abstract type \nFixedVectorNoTuple\n from \nFixedSizeArrays.jl\n. This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike \nTuple\n objects, we can add points together, simplifying many function definitions.\n\n\nTo interface with gdspy, we simply convert the \nPoint\n object to a \nTuple\n and let \nPyCall.jl\n figure out what to do.\n\n\n#\n\n\nDevices.Points.getx\n \n \nFunction\n.\n\n\ngetx(p::Point)\n\n\n\n\n\nGet the x-coordinate of a point.\n\n\n#\n\n\nDevices.Points.gety\n \n \nFunction\n.\n\n\ngety(p::Point)\n\n\n\n\n\nGet the y-coordinate of a point.", 
            "title": "Points"
        }, 
        {
            "location": "/paths/", 
            "text": "Paths\n\n\n#\n\n\nDevices.Paths.Path\n \n \nType\n.\n\n\ntype Path{T\n:Real} \n: AbstractArray{Tuple{Segment{T},Style},1}\n    p0::Point{2,T}\n    \u03b10::Real\n    style0::Style\n    segments::Array{Segment{T},1}\n    styles::Array{Style,1}\n    attachments::Array{CellReference,1}\n    Path(p0::Point{2,T}, \u03b10::Real, style0::Style, segments::Array{Segment{T},1},\n        styles::Array{Style,1}) = new(p0, \u03b10, style0, segments, styles)\n    Path(style::Style) =\n        new(Point(zero(T),zero(T)), 0.0, style, Segment{T}[], Style[])\nend\n\n\n\n\n\nType for abstracting an arbitrary styled path in the plane. Iterating returns tuples of (\nsegment\n, \nstyle\n).\n\n\nPath\n{\nT\n:\nReal\n}\n(\np0\n:\n:Point\n{\n2\n,\nT\n}\n=\nPoint\n(\n0\n.0\n,\n0\n.0\n);\n \n\u03b1\n0\n:\n:Real\n=\n0\n.0\n,\n \nstyle0\n:\n:Style\n=\nTrace\n(\n1\n.0\n))\n\n\n\n\n\n\nConvenience constructor for \nPath{T}\n object.\n\n\n#\n\n\nDevices.Paths.Path\n \n \nMethod\n.\n\n\nPath\n{\nT\n:\nReal\n}\n(\np0\n:\n:Point\n{\n2\n,\nT\n}\n=\nPoint\n(\n0\n.0\n,\n0\n.0\n);\n \n\u03b1\n0\n:\n:Real\n=\n0\n.0\n,\n \nstyle0\n:\n:Style\n=\nTrace\n(\n1\n.0\n))\n\n\n\n\n\n\nConvenience constructor for \nPath{T}\n object.\n\n\n#\n\n\nDevices.Paths.pathlength\n \n \nMethod\n.\n\n\npathlength(p::Path)\n\n\n\n\n\nPhysical length of a path. Note that \nlength\n will return the number of segments in a path, not the physical length.\n\n\n\n\nSegments\n\n\n#\n\n\nDevices.Paths.Segment\n \n \nType\n.\n\n\nabstract Segment{T\n:Real}\n\n\n\n\n\nPath segment in the plane. All Segment objects should have the implement the following methods:\n\n\n\n\nlength\n\n\np0\n\n\n\u03b10\n\n\nsetp0!\n\n\nset\u03b10!\n\n\n\u03b11\n\n\n\n\n#\n\n\nDevices.Paths.Straight\n \n \nType\n.\n\n\ntype Straight{T\n:Real} \n: Segment{T}\n    l::T\n    p0::Point{2,T}\n    \u03b10::Real\n    f::Function\n    Straight(l, p0, \u03b10) = begin\n        s = new(l, p0, \u03b10)\n        s.f = t-\n(s.p0+Point(t*s.l*cos(s.\u03b10),t*s.l*sin(s.\u03b10)))\n        s\n    end\nend\n\n\n\n\n\nA straight line segment is parameterized by its length. It begins at a point \np0\n with initial angle \n\u03b10\n.\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the line segment is given by:\n\n\nt -\n p0 + Point(t*l*cos(\u03b1),t*l*sin(\u03b1))\n\n\n#\n\n\nDevices.Paths.Turn\n \n \nType\n.\n\n\ntype Turn{T\n:Real} \n: Segment{T}\n    \u03b1::Real\n    r::T\n    p0::Point{2,T}\n    \u03b10::Real\n    f::Function\n    Turn(\u03b1, r, p0, \u03b10) = begin\n        s = new(\u03b1, r, p0, \u03b10)\n        s.f = t-\nbegin\n            cen = s.p0 + Point(s.r*cos(s.\u03b10+sign(s.\u03b1)*\u03c0/2), s.r*sin(s.\u03b10+sign(s.\u03b1)*\u03c0/2))\n            cen + Point(s.r*cos(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t), s.r*sin(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t))\n        end\n        s\n    end\nend\n\n\n\n\n\nA circular turn is parameterized by the turn angle \n\u03b1\n and turning radius \nr\n. It begins at a point \np0\n with initial angle \n\u03b10\n.\n\n\nThe center of the circle is given by:\n\n\ncen = p0 + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the turn is given by:\n\n\nt -\n cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))\n\n\n#\n\n\nDevices.Paths.CompoundSegment\n \n \nType\n.\n\n\ntype CompoundSegment{T\n:Real} \n: Segment{T}\n    segments::Array{Segment{T},1}\n    f::Function\n\n    CompoundSegment(segments) = begin\n        s = new(Array(segments))\n        s.f = param(s)\n        s\n    end\nend\n\n\n\n\n\nConsider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes. The array of segments given to the constructor is deep-copied and retained by the compound segment.\n\n\n\n\nStyles\n\n\n#\n\n\nDevices.Paths.Style\n \n \nType\n.\n\n\nabstract Style\n\n\n\n\n\nHow to render a given path segment. All styles should implement the following methods:\n\n\n\n\ndistance\n\n\nextent\n\n\npaths\n\n\nwidth\n\n\ndivs\n\n\n\n\n#\n\n\nDevices.Paths.Trace\n \n \nType\n.\n\n\ntype Trace \n: Style\n    width::Function\n    divs::Int\nend\n\n\n\n\n\nSimple, single trace.\n\n\n\n\nwidth::Function\n: trace width.\n\n\ndivs::Int\n: number of segments to render. Increase if you see artifacts.\n\n\n\n\n#\n\n\nDevices.Paths.CPW\n \n \nType\n.\n\n\ntype CPW \n: Style\n    trace::Function\n    gap::Function\n    divs::Int\nend\n\n\n\n\n\nTwo adjacent traces can form a coplanar waveguide.\n\n\n\n\ntrace::Function\n: center conductor width.\n\n\ngap::Function\n: distance between center conductor edges and ground plane\n\n\ndivs::Int\n: number of segments to render. Increase if you see artifacts.\n\n\n\n\nMay need to be inverted with respect to a ground plane, depending on how the pattern is written.\n\n\n#\n\n\nDevices.Paths.CompoundStyle\n \n \nType\n.\n\n\ntype CompoundStyle \n: Style\n    styles::Array{Style,1}\n    divs::Array{Float64,1}\n    f::Function\nend\n\n\n\n\n\nCombines styles together, typically for use with a \nCompoundSegment\n.\n\n\n\n\nstyles\n: Array of styles making up the object. This is shallow-copied by the outer constructor.\n\n\ndivs\n: An array of \nt\n values needed for rendering the parameteric path.\n\n\nf\n: returns tuple of style index and the \nt\n to use for that style's parametric function.\n\n\n\n\n#\n\n\nDevices.Paths.DecoratedStyle\n \n \nType\n.\n\n\ntype DecoratedStyle \n: Style\n    s::Style\n    ts::AbstractArray{Float64,1}\n    dirs::Array{Int,1}\n    cellrefs::Array{CellReference,1}\n    DecoratedStyle(s) = begin\n        a = new(s)\n        a.ts = Float64[]\n        a.dirs = Int[]\n        a.cells = CellReference[]\n    end\n    DecoratedStyle(s,t,r,c) = new(s,t,r,c)\nend\n\n\n\n\n\nStyle with decorations, like periodic structures along the path, etc.\n\n\n#\n\n\nDevices.Paths.undecorated\n \n \nFunction\n.\n\n\nundecorated(s::DecoratedStyle)\n\n\n\n\n\nReturns the underlying, undecorated style.\n\n\nundecorated(s::Style)\n\n\n\n\n\nReturns \ns\n.\n\n\n\n\nPath interrogation\n\n\n#\n\n\nDevices.Paths.direction\n \n \nFunction\n.\n\n\ndirection(p::Function, t)\n\n\n\n\n\nFor some parameteric function \np(t)\u21a6Point(x(t),y(t))\n, returns the angle at which the path is pointing for a given \nt\n.\n\n\n#\n\n\nDevices.Paths.pathlength\n \n \nFunction\n.\n\n\npathlength(p::Path)\n\n\n\n\n\nPhysical length of a path. Note that \nlength\n will return the number of segments in a path, not the physical length.\n\n\npathlength(p::AbstractArray{Segment})\n\n\n\n\n\nTotal physical length of segments.\n\n\n#\n\n\nDevices.Paths.p0\n \n \nFunction\n.\n\n\np0{T}(s::Segment{T})\n\n\n\n\n\nReturn the first point in a segment (calculated).\n\n\np0(p::Path)\n\n\n\n\n\nFirst point of a path.\n\n\n#\n\n\nDevices.Paths.setp0!\n \n \nFunction\n.\n\n\nsetp0!(s::Straight, p::Point)\n\n\n\n\n\nSet the p0 of a straight segment.\n\n\nsetp0!(s::Turn, p::Point)\n\n\n\n\n\nSet the p0 of a turn.\n\n\n#\n\n\nDevices.Paths.\u03b10\n \n \nFunction\n.\n\n\n\u03b10(s::Segment)\n\n\n\n\n\nReturn the first angle in a segment (calculated).\n\n\n\u03b10(p::Path)\n\n\n\n\n\nFirst angle of a path.\n\n\n#\n\n\nDevices.Paths.set\u03b10!\n \n \nFunction\n.\n\n\nset\u03b10!(s::Straight, \u03b10\u2032)\n\n\n\n\n\nSet the angle of a straight segment.\n\n\nset\u03b10!(s::Turn, \u03b10\u2032)\n\n\n\n\n\nSet the starting angle of a turn.\n\n\n#\n\n\nDevices.Paths.p1\n \n \nFunction\n.\n\n\np1{T}(s::Segment{T})\n\n\n\n\n\nReturn the last point in a segment (calculated).\n\n\np1(p::Path)\n\n\n\n\n\nLast point of a path.\n\n\n#\n\n\nDevices.Paths.\u03b11\n \n \nFunction\n.\n\n\n\u03b11(s::Segment)\n\n\n\n\n\nReturn the last angle in a segment (calculated).\n\n\n\u03b11(p::Path)\n\n\n\n\n\nLast angle of a path.\n\n\n#\n\n\nDevices.Paths.style0\n \n \nFunction\n.\n\n\nstyle0(p::Path)\n\n\n\n\n\nStyle of the first segment of a path.\n\n\n#\n\n\nDevices.Paths.style1\n \n \nFunction\n.\n\n\nstyle1(p::Path)\n\n\n\n\n\nStyle of the last segment of a path.\n\n\n\n\nPath building\n\n\n#\n\n\nBase.append!\n \n \nMethod\n.\n\n\nappend!(p::Path, p\u2032::Path)\n\n\n\n\n\nGiven paths \np\n and \np\u2032\n, path \np\u2032\n is appended to path \np\n. The p0 and initial angle of the first segment from path \np\u2032\n is modified to match the last point and last angle of path \np\n.\n\n\n#\n\n\nDevices.Paths.adjust!\n \n \nFunction\n.\n\n\nadjust!(p::Path, n::Integer=1)\n\n\n\n\n\nAdjust a path's parametric functions starting from index \nn\n. Used internally whenever segments are inserted into the path.\n\n\n#\n\n\nDevices.Paths.attach!\n \n \nFunction\n.\n\n\nattach\n!(\np\n:\n:Path\n,\n \nc\n:\n:CellReference\n,\n \nt\n:\n:Real\n;\n \ni\n:\n:Integer\n=\nlength\n(\np\n),\n \nwhere\n:\n:Integer\n=\n0\n)\n\n\n\n\n\n\nAttach a shallow copy of \nc\n along a path (the referenced cell is not copied). The copied \nCellReference\n is returned so that it can be used with the \nCells.transform(::Cell, ::Cells.CellRef)\n function.\n\n\nBy default, the attachment occurs at \nt \u2208 [0,1]\n along the most recent path segment, but a different path segment index can be specified using \ni\n. The reference is oriented with zero rotation if the path is pointing at 0\u00b0, otherwise it is rotated with the path.\n\n\nThe origin of the cell reference tells the method where to place the cell \nwith respect to a coordinate system that rotates with the path\n. Suppose the path is a straight line with angle 0\u00b0. Then an origin of \nPoint(0.,10.)\n will put the cell at 10 above the path, or 10 to the left of the path if it turns left by 90\u00b0.\n\n\nThe \nwhere\n option is for convenience. If \nwhere == 0\n, nothing special happens. If \nwhere == -1\n, then the point of attachment for the reference is on the leftmost edge of the waveguide (the rendered polygons; the path itself has no width). Likewise if \nwhere == 1\n, the point of attachment is on the rightmost edge. This option does not automatically rotate the cell reference, apart from what is already done as described in the first paragraph. You can think of this option as setting a special origin for the coordinate system that rotates with the path. For instance, an origin for the cell reference of \nPoint(0.,10.)\n together with \nwhere == -1\n will put the cell at 10 above the edge of a rendered (finite width) path with angle 0\u00b0.\n\n\n#\n\n\nDevices.Paths.attachments\n \n \nFunction\n.\n\n\nattachments(p::Path)\n\n\n\n\n\nReturns the array of attachments for a given path. These are the cell references tied to the path by \nattach!\n.\n\n\n#\n\n\nDevices.Paths.meander!\n \n \nFunction\n.\n\n\nmeander!{T\n:Real}(p::Path{T}, len, r, straightlen, \u03b1::Real)\n\n\n\n\n\nAlternate between going straight with length \nstraightlen\n and turning with radius \nr\n and angle \n\u03b1\n. Each turn goes the opposite direction of the previous. The total length is \nlen\n. Useful for making resonators.\n\n\nThe straight and turn segments are combined into a \nCompoundSegment\n and appended to the path \np\n.\n\n\n#\n\n\nDevices.Paths.param\n \n \nFunction\n.\n\n\nparam{T\n:Real}(seg::AbstractArray{Segment{T},1})\n\n\nReturns the function needed for a \nCompoundStyle\n. The segments array is shallow-copied for use in the function.\n\n\nparam{T\n:Real}(c::CompoundSegment{T})\n\n\n\n\n\nReturn a parametric function over the domain [0,1] that represents the compound segment.\n\n\n#\n\n\nDevices.Paths.simplify\n \n \nFunction\n.\n\n\nsimplify(p::Path)\n\n\n\n\n\nAll segments and styles of a path are turned into a \nCompoundSegment\n and \nCompoundStyle\n.\n\n\nsimplify(p::Path, inds::UnitRange)\n\n\n\n\n\nAt \ninds\n, segments of a path are turned into a \nCompoundSegment\n and styles of a path are turned into a \nCompoundStyle\n. The method returns a tuple, \n(segment, style)\n.\n\n\n\n\nIndexing the path becomes more sane when you can combine several path segments into one logical element. A launcher would have several indices in a path unless you could simplify it.\n\n\nYou don't need to think hard about boundaries between straights and turns when you want a continuous styling of a very long path.\n\n\n\n\n#\n\n\nDevices.Paths.simplify!\n \n \nFunction\n.\n\n\nsimplify!(p::Path)\n\n\n\n\n\nIn-place version of \nsimplify\n.\n\n\nsimplify!(p::Path, inds::UnitRange)\n\n\n\n\n\nIn-place version of \nsimplify\n.\n\n\n#\n\n\nDevices.Paths.straight!\n \n \nFunction\n.\n\n\nstraight!(p::Path, l::Real)\n\n\n\n\n\nExtend a path \np\n straight by length \nl\n in the current direction.\n\n\n#\n\n\nDevices.Paths.turn!\n \n \nFunction\n.\n\n\nturn!(p::Path, \u03b1::Real, r::Real, sty::Style=style1(p))\n\n\n\n\n\nTurn a path \np\n by angle \n\u03b1\n with a turning radius \nr\n in the current direction. Positive angle turns left.\n\n\nturn!(p::Path, s::ASCIIString, r::Real, sty::Style=style1(p))\n\n\n\n\n\nTurn a path \np\n with direction coded by string \ns\n:\n\n\n\n\n\"l\": turn by \u03c0/2 (left)\n\n\n\"r\": turn by -\u03c0/2 (right)\n\n\n\"lrlrllrrll\": do those turns in that order\n\n\n\n\n\n\nInterfacing with gdspy\n\n\nThe Python package \ngdspy\n is used for rendering paths into polygons. Ultimately we intend to remove this dependency.\n\n\n#\n\n\nDevices.Paths.distance\n \n \nFunction\n.\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the distance between the centers of parallel paths rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.extent\n \n \nFunction\n.\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns a distance tangential to the path specifying the lateral extent of the polygons rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.paths\n \n \nFunction\n.\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the number of parallel paths rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.width\n \n \nFunction\n.\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the width of paths rendered by gdspy.", 
            "title": "Paths"
        }, 
        {
            "location": "/paths/#paths", 
            "text": "#  Devices.Paths.Path     Type .  type Path{T :Real}  : AbstractArray{Tuple{Segment{T},Style},1}\n    p0::Point{2,T}\n    \u03b10::Real\n    style0::Style\n    segments::Array{Segment{T},1}\n    styles::Array{Style,1}\n    attachments::Array{CellReference,1}\n    Path(p0::Point{2,T}, \u03b10::Real, style0::Style, segments::Array{Segment{T},1},\n        styles::Array{Style,1}) = new(p0, \u03b10, style0, segments, styles)\n    Path(style::Style) =\n        new(Point(zero(T),zero(T)), 0.0, style, Segment{T}[], Style[])\nend  Type for abstracting an arbitrary styled path in the plane. Iterating returns tuples of ( segment ,  style ).  Path { T : Real } ( p0 : :Point { 2 , T } = Point ( 0 .0 , 0 .0 );   \u03b1 0 : :Real = 0 .0 ,   style0 : :Style = Trace ( 1 .0 ))   Convenience constructor for  Path{T}  object.  #  Devices.Paths.Path     Method .  Path { T : Real } ( p0 : :Point { 2 , T } = Point ( 0 .0 , 0 .0 );   \u03b1 0 : :Real = 0 .0 ,   style0 : :Style = Trace ( 1 .0 ))   Convenience constructor for  Path{T}  object.  #  Devices.Paths.pathlength     Method .  pathlength(p::Path)  Physical length of a path. Note that  length  will return the number of segments in a path, not the physical length.", 
            "title": "Paths"
        }, 
        {
            "location": "/paths/#segments", 
            "text": "#  Devices.Paths.Segment     Type .  abstract Segment{T :Real}  Path segment in the plane. All Segment objects should have the implement the following methods:   length  p0  \u03b10  setp0!  set\u03b10!  \u03b11   #  Devices.Paths.Straight     Type .  type Straight{T :Real}  : Segment{T}\n    l::T\n    p0::Point{2,T}\n    \u03b10::Real\n    f::Function\n    Straight(l, p0, \u03b10) = begin\n        s = new(l, p0, \u03b10)\n        s.f = t- (s.p0+Point(t*s.l*cos(s.\u03b10),t*s.l*sin(s.\u03b10)))\n        s\n    end\nend  A straight line segment is parameterized by its length. It begins at a point  p0  with initial angle  \u03b10 .  The parametric function over  t \u2208 [0,1]  describing the line segment is given by:  t -  p0 + Point(t*l*cos(\u03b1),t*l*sin(\u03b1))  #  Devices.Paths.Turn     Type .  type Turn{T :Real}  : Segment{T}\n    \u03b1::Real\n    r::T\n    p0::Point{2,T}\n    \u03b10::Real\n    f::Function\n    Turn(\u03b1, r, p0, \u03b10) = begin\n        s = new(\u03b1, r, p0, \u03b10)\n        s.f = t- begin\n            cen = s.p0 + Point(s.r*cos(s.\u03b10+sign(s.\u03b1)*\u03c0/2), s.r*sin(s.\u03b10+sign(s.\u03b1)*\u03c0/2))\n            cen + Point(s.r*cos(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t), s.r*sin(s.\u03b10-sign(\u03b1)*\u03c0/2+s.\u03b1*t))\n        end\n        s\n    end\nend  A circular turn is parameterized by the turn angle  \u03b1  and turning radius  r . It begins at a point  p0  with initial angle  \u03b10 .  The center of the circle is given by:  cen = p0 + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))  The parametric function over  t \u2208 [0,1]  describing the turn is given by:  t -  cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))  #  Devices.Paths.CompoundSegment     Type .  type CompoundSegment{T :Real}  : Segment{T}\n    segments::Array{Segment{T},1}\n    f::Function\n\n    CompoundSegment(segments) = begin\n        s = new(Array(segments))\n        s.f = param(s)\n        s\n    end\nend  Consider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes. The array of segments given to the constructor is deep-copied and retained by the compound segment.", 
            "title": "Segments"
        }, 
        {
            "location": "/paths/#styles", 
            "text": "#  Devices.Paths.Style     Type .  abstract Style  How to render a given path segment. All styles should implement the following methods:   distance  extent  paths  width  divs   #  Devices.Paths.Trace     Type .  type Trace  : Style\n    width::Function\n    divs::Int\nend  Simple, single trace.   width::Function : trace width.  divs::Int : number of segments to render. Increase if you see artifacts.   #  Devices.Paths.CPW     Type .  type CPW  : Style\n    trace::Function\n    gap::Function\n    divs::Int\nend  Two adjacent traces can form a coplanar waveguide.   trace::Function : center conductor width.  gap::Function : distance between center conductor edges and ground plane  divs::Int : number of segments to render. Increase if you see artifacts.   May need to be inverted with respect to a ground plane, depending on how the pattern is written.  #  Devices.Paths.CompoundStyle     Type .  type CompoundStyle  : Style\n    styles::Array{Style,1}\n    divs::Array{Float64,1}\n    f::Function\nend  Combines styles together, typically for use with a  CompoundSegment .   styles : Array of styles making up the object. This is shallow-copied by the outer constructor.  divs : An array of  t  values needed for rendering the parameteric path.  f : returns tuple of style index and the  t  to use for that style's parametric function.   #  Devices.Paths.DecoratedStyle     Type .  type DecoratedStyle  : Style\n    s::Style\n    ts::AbstractArray{Float64,1}\n    dirs::Array{Int,1}\n    cellrefs::Array{CellReference,1}\n    DecoratedStyle(s) = begin\n        a = new(s)\n        a.ts = Float64[]\n        a.dirs = Int[]\n        a.cells = CellReference[]\n    end\n    DecoratedStyle(s,t,r,c) = new(s,t,r,c)\nend  Style with decorations, like periodic structures along the path, etc.  #  Devices.Paths.undecorated     Function .  undecorated(s::DecoratedStyle)  Returns the underlying, undecorated style.  undecorated(s::Style)  Returns  s .", 
            "title": "Styles"
        }, 
        {
            "location": "/paths/#path-interrogation", 
            "text": "#  Devices.Paths.direction     Function .  direction(p::Function, t)  For some parameteric function  p(t)\u21a6Point(x(t),y(t)) , returns the angle at which the path is pointing for a given  t .  #  Devices.Paths.pathlength     Function .  pathlength(p::Path)  Physical length of a path. Note that  length  will return the number of segments in a path, not the physical length.  pathlength(p::AbstractArray{Segment})  Total physical length of segments.  #  Devices.Paths.p0     Function .  p0{T}(s::Segment{T})  Return the first point in a segment (calculated).  p0(p::Path)  First point of a path.  #  Devices.Paths.setp0!     Function .  setp0!(s::Straight, p::Point)  Set the p0 of a straight segment.  setp0!(s::Turn, p::Point)  Set the p0 of a turn.  #  Devices.Paths.\u03b10     Function .  \u03b10(s::Segment)  Return the first angle in a segment (calculated).  \u03b10(p::Path)  First angle of a path.  #  Devices.Paths.set\u03b10!     Function .  set\u03b10!(s::Straight, \u03b10\u2032)  Set the angle of a straight segment.  set\u03b10!(s::Turn, \u03b10\u2032)  Set the starting angle of a turn.  #  Devices.Paths.p1     Function .  p1{T}(s::Segment{T})  Return the last point in a segment (calculated).  p1(p::Path)  Last point of a path.  #  Devices.Paths.\u03b11     Function .  \u03b11(s::Segment)  Return the last angle in a segment (calculated).  \u03b11(p::Path)  Last angle of a path.  #  Devices.Paths.style0     Function .  style0(p::Path)  Style of the first segment of a path.  #  Devices.Paths.style1     Function .  style1(p::Path)  Style of the last segment of a path.", 
            "title": "Path interrogation"
        }, 
        {
            "location": "/paths/#path-building", 
            "text": "#  Base.append!     Method .  append!(p::Path, p\u2032::Path)  Given paths  p  and  p\u2032 , path  p\u2032  is appended to path  p . The p0 and initial angle of the first segment from path  p\u2032  is modified to match the last point and last angle of path  p .  #  Devices.Paths.adjust!     Function .  adjust!(p::Path, n::Integer=1)  Adjust a path's parametric functions starting from index  n . Used internally whenever segments are inserted into the path.  #  Devices.Paths.attach!     Function .  attach !( p : :Path ,   c : :CellReference ,   t : :Real ;   i : :Integer = length ( p ),   where : :Integer = 0 )   Attach a shallow copy of  c  along a path (the referenced cell is not copied). The copied  CellReference  is returned so that it can be used with the  Cells.transform(::Cell, ::Cells.CellRef)  function.  By default, the attachment occurs at  t \u2208 [0,1]  along the most recent path segment, but a different path segment index can be specified using  i . The reference is oriented with zero rotation if the path is pointing at 0\u00b0, otherwise it is rotated with the path.  The origin of the cell reference tells the method where to place the cell  with respect to a coordinate system that rotates with the path . Suppose the path is a straight line with angle 0\u00b0. Then an origin of  Point(0.,10.)  will put the cell at 10 above the path, or 10 to the left of the path if it turns left by 90\u00b0.  The  where  option is for convenience. If  where == 0 , nothing special happens. If  where == -1 , then the point of attachment for the reference is on the leftmost edge of the waveguide (the rendered polygons; the path itself has no width). Likewise if  where == 1 , the point of attachment is on the rightmost edge. This option does not automatically rotate the cell reference, apart from what is already done as described in the first paragraph. You can think of this option as setting a special origin for the coordinate system that rotates with the path. For instance, an origin for the cell reference of  Point(0.,10.)  together with  where == -1  will put the cell at 10 above the edge of a rendered (finite width) path with angle 0\u00b0.  #  Devices.Paths.attachments     Function .  attachments(p::Path)  Returns the array of attachments for a given path. These are the cell references tied to the path by  attach! .  #  Devices.Paths.meander!     Function .  meander!{T :Real}(p::Path{T}, len, r, straightlen, \u03b1::Real)  Alternate between going straight with length  straightlen  and turning with radius  r  and angle  \u03b1 . Each turn goes the opposite direction of the previous. The total length is  len . Useful for making resonators.  The straight and turn segments are combined into a  CompoundSegment  and appended to the path  p .  #  Devices.Paths.param     Function .  param{T :Real}(seg::AbstractArray{Segment{T},1})  Returns the function needed for a  CompoundStyle . The segments array is shallow-copied for use in the function.  param{T :Real}(c::CompoundSegment{T})  Return a parametric function over the domain [0,1] that represents the compound segment.  #  Devices.Paths.simplify     Function .  simplify(p::Path)  All segments and styles of a path are turned into a  CompoundSegment  and  CompoundStyle .  simplify(p::Path, inds::UnitRange)  At  inds , segments of a path are turned into a  CompoundSegment  and styles of a path are turned into a  CompoundStyle . The method returns a tuple,  (segment, style) .   Indexing the path becomes more sane when you can combine several path segments into one logical element. A launcher would have several indices in a path unless you could simplify it.  You don't need to think hard about boundaries between straights and turns when you want a continuous styling of a very long path.   #  Devices.Paths.simplify!     Function .  simplify!(p::Path)  In-place version of  simplify .  simplify!(p::Path, inds::UnitRange)  In-place version of  simplify .  #  Devices.Paths.straight!     Function .  straight!(p::Path, l::Real)  Extend a path  p  straight by length  l  in the current direction.  #  Devices.Paths.turn!     Function .  turn!(p::Path, \u03b1::Real, r::Real, sty::Style=style1(p))  Turn a path  p  by angle  \u03b1  with a turning radius  r  in the current direction. Positive angle turns left.  turn!(p::Path, s::ASCIIString, r::Real, sty::Style=style1(p))  Turn a path  p  with direction coded by string  s :   \"l\": turn by \u03c0/2 (left)  \"r\": turn by -\u03c0/2 (right)  \"lrlrllrrll\": do those turns in that order", 
            "title": "Path building"
        }, 
        {
            "location": "/paths/#interfacing-with-gdspy", 
            "text": "The Python package  gdspy  is used for rendering paths into polygons. Ultimately we intend to remove this dependency.  #  Devices.Paths.distance     Function .  For a style  s  and parameteric argument  t , returns the distance between the centers of parallel paths rendered by gdspy.  #  Devices.Paths.extent     Function .  For a style  s  and parameteric argument  t , returns a distance tangential to the path specifying the lateral extent of the polygons rendered by gdspy.  #  Devices.Paths.paths     Function .  For a style  s  and parameteric argument  t , returns the number of parallel paths rendered by gdspy.  #  Devices.Paths.width     Function .  For a style  s  and parameteric argument  t , returns the width of paths rendered by gdspy.", 
            "title": "Interfacing with gdspy"
        }, 
        {
            "location": "/polygons/", 
            "text": "In this package, any polygon regardless of its concrete representation in memory should be a subtype of \nDevices.AbstractPolygon\n.\n\n\n#\n\n\nDevices.AbstractPolygon\n \n \nType\n.\n\n\nabstract AbstractPolygon{T}\n\n\n\n\n\nAnything you could call a polygon regardless of the underlying representation. Currently only \nRectangle\n or \nPolygon\n are concrete subtypes.\n\n\n\n\nRectangles\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nType\n.\n\n\ntype Rectangle{T\n:Real} \n: AbstractPolygon{T}\n    ll::Point{2,T}\n    ur::Point{2,T}\n    properties::Dict{Symbol, Any}\n    Rectangle(ll,ur) = new(ll,ur,Dict{Symbol,Any}())\n    Rectangle(ll,ur,props) = new(ll,ur,props)\nend\n\n\n\n\n\nA rectangle, defined by opposing lower-left and upper-right corner coordinates.\n\n\nRectangle\n{\nT\n:\nReal\n}\n(\nll\n:\n:Point\n{\n2\n,\nT\n}\n,\n \nur\n:\n:Point\n{\n2\n,\nT\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for \nRectangle{T}\n objects.\n\n\nRectangle{T\n:Real}(ll::Point{2,T}, ur::Point{2,T}, dict)\n\n\n\n\n\nConvenience constructor for \nRectangle{T}\n objects.\n\n\nRectangle\n{\nT\n:\nReal\n}\n(\nwidth\n:\n:T\n,\n \nheight\n:\n:T\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConstructs \nRectangle{T}\n objects by specifying the width and height rather than the lower-left and upper-right corners.\n\n\nThe rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of \nRectangle{Int}\n type, this would not be possible if either \nwidth\n or \nheight\n were odd numbers. This definition ensures type stability in the constructor.\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\nRectangle\n{\nT\n:\nReal\n}\n(\nll\n:\n:Point\n{\n2\n,\nT\n}\n,\n \nur\n:\n:Point\n{\n2\n,\nT\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for \nRectangle{T}\n objects.\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\nRectangle{T\n:Real}(ll::Point{2,T}, ur::Point{2,T}, dict)\n\n\n\n\n\nConvenience constructor for \nRectangle{T}\n objects.\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nMethod\n.\n\n\nRectangle\n{\nT\n:\nReal\n}\n(\nwidth\n:\n:T\n,\n \nheight\n:\n:T\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConstructs \nRectangle{T}\n objects by specifying the width and height rather than the lower-left and upper-right corners.\n\n\nThe rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of \nRectangle{Int}\n type, this would not be possible if either \nwidth\n or \nheight\n were odd numbers. This definition ensures type stability in the constructor.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(r::Rectangle)\n\n\n\n\n\nNo-op (just returns \nr\n).\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\n objects.\n\n\n#\n\n\nDevices.center\n \n \nMethod\n.\n\n\ncenter(r::Rectangle)\n\n\n\n\n\nReturns a Point corresponding to the center of the rectangle.\n\n\n#\n\n\nDevices.Rectangles.height\n \n \nMethod\n.\n\n\nheight(r::Rectangle)\n\n\n\n\n\nReturn the height of a rectangle.\n\n\n#\n\n\nDevices.Rectangles.isproper\n \n \nMethod\n.\n\n\nisproper(r::Rectangle)\n\n\n\n\n\nReturns \ntrue\n if the rectangle has a non-zero size and if the upper-right and lower-left corner coordinates \nur\n and \nll\n really are at the upper-right and lower-left. Otherwise, returns \nfalse\n.\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\nminimum(itr)\n\n\n\n\n\nReturns the smallest element in a collection.\n\n\nminimum(r::Rectangle)\n\n\n\n\n\nReturns the lower-left corner of a rectangle (Point object).\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\nmaximum(itr)\n\n\n\n\n\nReturns the largest element in a collection.\n\n\nmaximum(r::Rectangle)\n\n\n\n\n\nReturns the upper-right corner of a rectangle (Point object).\n\n\n#\n\n\nDevices.Polygons.points\n \n \nMethod\n.\n\n\npoints{T\n:Real}(x::Rectangle{T})\n\n\n\n\n\nReturns the array of \nPoint\n objects defining the rectangle.\n\n\n#\n\n\nDevices.Rectangles.width\n \n \nMethod\n.\n\n\nwidth(r::Rectangle)\n\n\n\n\n\nReturn the width of a rectangle.\n\n\n#\n\n\nBase.+\n \n \nMethod\n.\n\n\n+(r::Rectangle, p::Point)\n\n\n\n\n\nTranslate a rectangle by \np\n.\n\n\n\n\nPolygons\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nType\n.\n\n\ntype Polygon{T\n:Real} \n: AbstractPolygon{T}\n    p::Array{Point{2,T},1}\n    properties::Dict{Symbol, Any}\n    Polygon(x,y) = new(x,y)\n    Polygon(x) = new(x, Dict{Symbol, Any}())\nend\n\n\n\n\n\nPolygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).\n\n\nPolygon\n{\nT\n:\nReal\n}\n(\nparr\n:\n:AbstractArray\n{\nPoint\n{\n2\n,\nT\n}\n,\n1\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\nPolygon{T\n:Real}(parr::AbstractArray{Point{2,T},1}, dict)\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\nPolygon\n{\nT\n:\nReal\n}\n(\np0\n:\n:Point\n{\n2\n,\nT\n}\n,\n \np1\n:\n:Point\n{\n2\n,\nT\n}\n,\n \np2\n:\n:Point\n{\n2\n,\nT\n}\n,\n\n    \np3\n:\n:Point\n{\n2\n,\nT\n}\n...;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\nPolygon\n{\nT\n:\nReal\n}\n(\nparr\n:\n:AbstractArray\n{\nPoint\n{\n2\n,\nT\n}\n,\n1\n}\n;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\nPolygon{T\n:Real}(parr::AbstractArray{Point{2,T},1}, dict)\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nMethod\n.\n\n\nPolygon\n{\nT\n:\nReal\n}\n(\np0\n:\n:Point\n{\n2\n,\nT\n}\n,\n \np1\n:\n:Point\n{\n2\n,\nT\n}\n,\n \np2\n:\n:Point\n{\n2\n,\nT\n}\n,\n\n    \np3\n:\n:Point\n{\n2\n,\nT\n}\n...;\n \nkwargs\n...)\n\n\n\n\n\n\nConvenience constructor for a \nPolygon{T}\n object.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(p::Polygon)\n\n\n\n\n\nReturn a bounding Rectangle with no properties for polygon \np\n.\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\n objects.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds{T\n:AbstractPolygon}(parr::AbstractArray{T})\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for an array \nparr\n of \nAbstractPolygon\n objects.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\n\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\n objects.\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\nminimum(itr)\n\n\n\n\n\nReturns the smallest element in a collection.\n\n\nminimum(x::Polygon)\n\n\n\n\n\nReturn the lower-left-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\nmaximum(itr)\n\n\n\n\n\nReturns the largest element in a collection.\n\n\nmaximum(x::Polygon)\n\n\n\n\n\nReturn the upper-right-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\n#\n\n\nDevices.Polygons.points\n \n \nMethod\n.\n\n\npoints(x::Polygon)\n\n\n\n\n\nReturns the array of \nPoint\n objects defining the polygon.\n\n\n\n\nClipping and offsetting\n\n\n#\n\n\nDevices.Polygons.clip\n \n \nFunction\n.\n\n\n#\n\n\nDevices.Polygons.offset\n \n \nFunction\n.", 
            "title": "Abstract polygons"
        }, 
        {
            "location": "/polygons/#rectangles", 
            "text": "#  Devices.Rectangles.Rectangle     Type .  type Rectangle{T :Real}  : AbstractPolygon{T}\n    ll::Point{2,T}\n    ur::Point{2,T}\n    properties::Dict{Symbol, Any}\n    Rectangle(ll,ur) = new(ll,ur,Dict{Symbol,Any}())\n    Rectangle(ll,ur,props) = new(ll,ur,props)\nend  A rectangle, defined by opposing lower-left and upper-right corner coordinates.  Rectangle { T : Real } ( ll : :Point { 2 , T } ,   ur : :Point { 2 , T } ;   kwargs ...)   Convenience constructor for  Rectangle{T}  objects.  Rectangle{T :Real}(ll::Point{2,T}, ur::Point{2,T}, dict)  Convenience constructor for  Rectangle{T}  objects.  Rectangle { T : Real } ( width : :T ,   height : :T ;   kwargs ...)   Constructs  Rectangle{T}  objects by specifying the width and height rather than the lower-left and upper-right corners.  The rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of  Rectangle{Int}  type, this would not be possible if either  width  or  height  were odd numbers. This definition ensures type stability in the constructor.  #  Devices.Rectangles.Rectangle     Method .  Rectangle { T : Real } ( ll : :Point { 2 , T } ,   ur : :Point { 2 , T } ;   kwargs ...)   Convenience constructor for  Rectangle{T}  objects.  #  Devices.Rectangles.Rectangle     Method .  Rectangle{T :Real}(ll::Point{2,T}, ur::Point{2,T}, dict)  Convenience constructor for  Rectangle{T}  objects.  #  Devices.Rectangles.Rectangle     Method .  Rectangle { T : Real } ( width : :T ,   height : :T ;   kwargs ...)   Constructs  Rectangle{T}  objects by specifying the width and height rather than the lower-left and upper-right corners.  The rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of  Rectangle{Int}  type, this would not be possible if either  width  or  height  were odd numbers. This definition ensures type stability in the constructor.  #  Devices.bounds     Method .  bounds(r::Rectangle)  No-op (just returns  r ).  bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon  objects.  #  Devices.center     Method .  center(r::Rectangle)  Returns a Point corresponding to the center of the rectangle.  #  Devices.Rectangles.height     Method .  height(r::Rectangle)  Return the height of a rectangle.  #  Devices.Rectangles.isproper     Method .  isproper(r::Rectangle)  Returns  true  if the rectangle has a non-zero size and if the upper-right and lower-left corner coordinates  ur  and  ll  really are at the upper-right and lower-left. Otherwise, returns  false .  #  Base.minimum     Method .  minimum(itr)  Returns the smallest element in a collection.  minimum(r::Rectangle)  Returns the lower-left corner of a rectangle (Point object).  #  Base.maximum     Method .  maximum(itr)  Returns the largest element in a collection.  maximum(r::Rectangle)  Returns the upper-right corner of a rectangle (Point object).  #  Devices.Polygons.points     Method .  points{T :Real}(x::Rectangle{T})  Returns the array of  Point  objects defining the rectangle.  #  Devices.Rectangles.width     Method .  width(r::Rectangle)  Return the width of a rectangle.  #  Base.+     Method .  +(r::Rectangle, p::Point)  Translate a rectangle by  p .", 
            "title": "Rectangles"
        }, 
        {
            "location": "/polygons/#polygons", 
            "text": "#  Devices.Polygons.Polygon     Type .  type Polygon{T :Real}  : AbstractPolygon{T}\n    p::Array{Point{2,T},1}\n    properties::Dict{Symbol, Any}\n    Polygon(x,y) = new(x,y)\n    Polygon(x) = new(x, Dict{Symbol, Any}())\nend  Polygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).  Polygon { T : Real } ( parr : :AbstractArray { Point { 2 , T } , 1 } ;   kwargs ...)   Convenience constructor for a  Polygon{T}  object.  Polygon{T :Real}(parr::AbstractArray{Point{2,T},1}, dict)  Convenience constructor for a  Polygon{T}  object.  Polygon { T : Real } ( p0 : :Point { 2 , T } ,   p1 : :Point { 2 , T } ,   p2 : :Point { 2 , T } , \n     p3 : :Point { 2 , T } ...;   kwargs ...)   Convenience constructor for a  Polygon{T}  object.  #  Devices.Polygons.Polygon     Method .  Polygon { T : Real } ( parr : :AbstractArray { Point { 2 , T } , 1 } ;   kwargs ...)   Convenience constructor for a  Polygon{T}  object.  #  Devices.Polygons.Polygon     Method .  Polygon{T :Real}(parr::AbstractArray{Point{2,T},1}, dict)  Convenience constructor for a  Polygon{T}  object.  #  Devices.Polygons.Polygon     Method .  Polygon { T : Real } ( p0 : :Point { 2 , T } ,   p1 : :Point { 2 , T } ,   p2 : :Point { 2 , T } , \n     p3 : :Point { 2 , T } ...;   kwargs ...)   Convenience constructor for a  Polygon{T}  object.  #  Devices.bounds     Method .  bounds(p::Polygon)  Return a bounding Rectangle with no properties for polygon  p .  bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon  objects.  #  Devices.bounds     Method .  bounds{T :AbstractPolygon}(parr::AbstractArray{T})  Return a bounding  Rectangle  with no properties for an array  parr  of  AbstractPolygon  objects.  #  Devices.bounds     Method .  bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon  objects.  #  Base.minimum     Method .  minimum(itr)  Returns the smallest element in a collection.  minimum(x::Polygon)  Return the lower-left-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  #  Base.maximum     Method .  maximum(itr)  Returns the largest element in a collection.  maximum(x::Polygon)  Return the upper-right-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  #  Devices.Polygons.points     Method .  points(x::Polygon)  Returns the array of  Point  objects defining the polygon.", 
            "title": "Polygons"
        }, 
        {
            "location": "/polygons/#clipping-and-offsetting", 
            "text": "#  Devices.Polygons.clip     Function .  #  Devices.Polygons.offset     Function .", 
            "title": "Clipping and offsetting"
        }, 
        {
            "location": "/cells/", 
            "text": "Cells are used to logically group polygons or references to other cells into a single entity.\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nType\n.\n\n\ntype Cell{T\n:Real}\n    name::ASCIIString\n    elements::Array{AbstractPolygon{T},1}\n    refs::Array{CellRef,1}\n    create::DateTime\n    function even(str)\n        if mod(length(str),2) == 1\n            str*\n\u0000\n\n        else\n            str\n        end\n    end\n    Cell(x,y,z) = new(even(x), y, z, now())\n    Cell(x,y) = new(even(x), y, CellReference[], now())\n    Cell(x) = new(even(x), AbstractPolygon{T}[], CellReference[], now())\nend\n\n\n\n\n\nA cell has a name and contains polygons and references to \nCellArray\n or \nCellReference\n objects. It also records the time of its own creation. As currently implemented it mirrors the notion of cells in GDS-II files.\n\n\nIn the future, it may make sense to generalize the idea and permit \nPath\n objects within a Cell.\n\n\nTo add elements, push them to \nelements\n field (or use \nrender!\n); to add references, push them to \nrefs\n field.\n\n\nCell(name::AbstractString)\n\n\n\n\n\nConvenience constructor for \nCell{Float64}\n.\n\n\nCell{T\n:Real}(name::AbstractString, elements::AbstractArray{AbstractPolygon{T},1})\n\n\n\n\n\nConvenience constructor for \nCell{T}\n.\n\n\nCell{T\n:Real}(name::AbstractString, elements::AbstractArray{AbstractPolygon{T},1},\n    refs::AbstractArray{CellReference,1})\n\n\n\n\n\nConvenience constructor for \nCell{T}\n.\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nMethod\n.\n\n\nCell(name::AbstractString)\n\n\n\n\n\nConvenience constructor for \nCell{Float64}\n.\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nMethod\n.\n\n\nCell{T\n:Real}(name::AbstractString, elements::AbstractArray{AbstractPolygon{T},1})\n\n\n\n\n\nConvenience constructor for \nCell{T}\n.\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nMethod\n.\n\n\nCell{T\n:Real}(name::AbstractString, elements::AbstractArray{AbstractPolygon{T},1},\n    refs::AbstractArray{CellReference,1})\n\n\n\n\n\nConvenience constructor for \nCell{T}\n.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds\n(\ncell\n:\n:Cell\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with no properties around all objects in \ncell\n.\n\n\n#\n\n\nDevices.center\n \n \nMethod\n.\n\n\ncenter(cell::Cell)\n\n\n\n\n\nConvenience method, equivalent to \ncenter(bounds(cell))\n. Returns the center of the bounding box of the cell.\n\n\n\n\nReferenced and arrayed cells\n\n\nCells can be arrayed or referenced within other cells for efficiency or to reduce display complexity.\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nType\n.\n\n\ntype CellArray{S,T} \n: CellRef{S,T}\n    cell::S\n    origin::Point{2,T}\n    deltacol::Point{2,T}\n    deltarow::Point{2,T}\n    col::Int\n    row::Int\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend\n\n\n\n\n\nArray of \ncell\n starting at \norigin\n with \nrow\n rows and \ncol\n columns, spanned by vectors \ndeltacol\n and \ndeltarow\n. Optional x-reflection \nxrefl\n, magnification factor \nmag\n, and rotation angle \nrot\n in degrees are for the array as a whole.\n\n\nThe type variable \nS\n is to avoid circular definitions with \nCell\n.\n\n\nCellArray\n{\nT\n:\nReal\n}\n(\nx\n:\n:Cell\n,\n \norigin\n:\n:Point\n{\n2\n,\nT\n}\n,\n \ndc\n:\n:Point\n{\n2\n,\nT\n}\n,\n \ndr\n:\n:Point\n{\n2\n,\nT\n}\n,\n\n    \nc\n:\n:Integer\n,\n \nr\n:\n:Integer\n;\n \nxrefl\n=\nfalse\n,\n \nmag\n=\n1\n.0\n,\n \nrot\n=\n0\n.0\n)\n\n\n\n\n\n\nConstruct a \nCellArray{typeof(x),T}\n object, with \nxrefl\n, \nmag\n, and \nrot\n as keyword arguments (x-reflection, magnification factor, rotation in degrees).\n\n\nCellArray\n{\nT\n:\nReal\n}\n(\nx\n:\n:Cell\n,\n \nc\n:\n:Range\n{\nT\n}\n,\n \nr\n:\n:Range\n{\nT\n}\n;\n\n    \nxrefl\n=\nfalse\n,\n \nmag\n=\n1\n.0\n,\n \nrot\n=\n0\n.0\n)\n\n\n\n\n\n\nConstruct a \nCellArray{typeof(x), T}\n based on ranges (probably \nLinSpace\n or \nFloatRange\n). \nc\n specifies column coordinates and \nr\n for the rows. Pairs from \nc\n and \nr\n specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting \nCellArray\n's bounding box; some care is required.\n\n\nxrefl\n, \nmag\n, and \nrot\n are keyword arguments (x-reflection, magnification factor, rotation in degrees).\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nMethod\n.\n\n\nCellArray\n{\nT\n:\nReal\n}\n(\nx\n:\n:Cell\n,\n \norigin\n:\n:Point\n{\n2\n,\nT\n}\n,\n \ndc\n:\n:Point\n{\n2\n,\nT\n}\n,\n \ndr\n:\n:Point\n{\n2\n,\nT\n}\n,\n\n    \nc\n:\n:Integer\n,\n \nr\n:\n:Integer\n;\n \nxrefl\n=\nfalse\n,\n \nmag\n=\n1\n.0\n,\n \nrot\n=\n0\n.0\n)\n\n\n\n\n\n\nConstruct a \nCellArray{typeof(x),T}\n object, with \nxrefl\n, \nmag\n, and \nrot\n as keyword arguments (x-reflection, magnification factor, rotation in degrees).\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nMethod\n.\n\n\nCellArray\n{\nT\n:\nReal\n}\n(\nx\n:\n:Cell\n,\n \nc\n:\n:Range\n{\nT\n}\n,\n \nr\n:\n:Range\n{\nT\n}\n;\n\n    \nxrefl\n=\nfalse\n,\n \nmag\n=\n1\n.0\n,\n \nrot\n=\n0\n.0\n)\n\n\n\n\n\n\nConstruct a \nCellArray{typeof(x), T}\n based on ranges (probably \nLinSpace\n or \nFloatRange\n). \nc\n specifies column coordinates and \nr\n for the rows. Pairs from \nc\n and \nr\n specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting \nCellArray\n's bounding box; some care is required.\n\n\nxrefl\n, \nmag\n, and \nrot\n are keyword arguments (x-reflection, magnification factor, rotation in degrees).\n\n\n#\n\n\nDevices.Cells.CellReference\n \n \nType\n.\n\n\ntype CellReference{S,T} \n: CellRef{S,T}\n    cell::S\n    origin::Point{2,T}\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend\n\n\n\n\n\nReference to a \ncell\n positioned at \norigin\n, with optional x-reflection \nxrefl\n, magnification factor \nmag\n, and rotation angle \nrot\n in degrees.\n\n\nThe type variable \nS\n is to avoid circular definitions with \nCell\n.\n\n\nCellReference\n{\nT\n:\nReal\n}\n(\nx\n:\n:Cell\n,\n \ny\n:\n:Point\n{\n2\n,\nT\n}\n=\nPoint\n(\n0\n.,\n0\n.);\n\n    \nxrefl\n=\nfalse\n,\n \nmag\n=\n1\n.0\n,\n \nrot\n=\n0\n.0\n)\n\n\n\n\n\n\nConvenience constructor for \nCellReference{typeof(x), T}\n.\n\n\n#\n\n\nDevices.Cells.CellReference\n \n \nMethod\n.\n\n\nCellReference\n{\nT\n:\nReal\n}\n(\nx\n:\n:Cell\n,\n \ny\n:\n:Point\n{\n2\n,\nT\n}\n=\nPoint\n(\n0\n.,\n0\n.);\n\n    \nxrefl\n=\nfalse\n,\n \nmag\n=\n1\n.0\n,\n \nrot\n=\n0\n.0\n)\n\n\n\n\n\n\nConvenience constructor for \nCellReference{typeof(x), T}\n.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds\n(\nref\n:\n:CellArray\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with properties specified by \nkwargs...\n around all objects in \nref\n. The bounding box respects reflection, rotation, and magnification specified by \nref\n.\n\n\nPlease do rewrite this method when feeling motivated... it is very inefficient.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\nbounds\n(\nref\n:\n:CellReference\n;\n \nkwargs\n...)\n\n\n\n\n\n\nReturns a \nRectangle\n bounding box with properties specified by \nkwargs...\n around all objects in \nref\n. The bounding box respects reflection, rotation, and magnification specified by \nref\n.\n\n\n#\n\n\nBase.copy\n \n \nMethod\n.\n\n\ncopy(x::CellReference)\n\n\n\n\n\nCreates a shallow copy of \nx\n (does not copy the referenced cell).\n\n\n#\n\n\nBase.copy\n \n \nMethod\n.\n\n\ncopy(x::CellArray)\n\n\n\n\n\nCreates a shallow copy of \nx\n (does not copy the arrayed cell).\n\n\n\n\nResolving references\n\n\nSometimes it can be helpful to go between coordinate systems of cells and the cells they reference. This package provides methods to generate affine transforms to do this as easily as possible.\n\n\n#\n\n\nAffineTransforms.transform\n \n \nMethod\n.\n\n\ntransform(c::Cell, d::CellRef)\n\n\n\n\n\nGiven a cell \nc\n containing cell reference or array \nd\n in its tree of references, this function returns an \nAffineTransform\n object that lets you translate from the coordinate system of \nd\n to the coordinate system of \nc\n.\n\n\nIf the \nsame exact\n cell reference or array (as in, same address in memory) is included multiple times in the tree of references, then the resulting transform will be based on the first time it is encountered. The tree is traversed one level at a time to find the reference (optimized for shallow references).\n\n\nExample: You want to translate (2.0,3.0) in the coordinate system of the referenced cell to the coordinate system of \nc\n. Simply call: \ntransform(c,d)*Point(2.0,3.0)\n.\n\n\nIn some cases it may be desirable to resolve cell references or arrays into their corresponding polygons. This operation is called \"flattening.\"\n\n\n#\n\n\nDevices.Cells.flatten!\n \n \nFunction\n.\n\n\nflatten!(c::Cell)\n\n\nAll cell references and arrays are turned into polygons and added to cell \nc\n. The references and arrays are then removed. This \"flattening\" of the cell is recursive: references in referenced cells are flattened too. The modified cell is returned.\n\n\n#\n\n\nDevices.Cells.flatten\n \n \nFunction\n.\n\n\nflatten{T\n:Real}(c::Cell{T})\n\n\nAll cell references and arrays are resolved into polygons, recursively. Together with the polygons already in cell \nc\n, an array of polygons (type \nAbstractPolygon{T}\n) is returned. The cell \nc\n remains unmodified.\n\n\nflatten(c::CellReference)\n\n\nCell reference \nc\n is resolved into polygons, recursively. An array of polygons (type \nAbstractPolygon\n) is returned. The cell reference \nc\n remains unmodified.\n\n\nflatten(c::CellArray)\n\n\nCell array \nc\n is resolved into polygons, recursively. An array of polygons (type \nAbstractPolygon\n) is returned. The cell array \nc\n remains unmodified.\n\n\n\n\nMiscellaneous\n\n\nWhen saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.\n\n\n#\n\n\nDevices.Cells.traverse!\n \n \nFunction\n.\n\n\ntraverse!(a::AbstractArray, c::Cell, level=1)\n\n\n\n\n\nGiven a cell, recursively traverse its references for other cells and add to array \na\n some tuples: \n(level, c)\n. \nlevel\n corresponds to how deep the cell was found, and \nc\n is the found cell.\n\n\n#\n\n\nDevices.Cells.order!\n \n \nFunction\n.\n\n\norder!(a::AbstractArray)\n\n\n\n\n\nGiven an array of tuples like that coming out of \ntraverse!\n, we sort by the \nlevel\n, strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).\n\n\nFor performance reasons, this function modifies \na\n but what you want is the returned result array.", 
            "title": "Cells"
        }, 
        {
            "location": "/cells/#referenced-and-arrayed-cells", 
            "text": "Cells can be arrayed or referenced within other cells for efficiency or to reduce display complexity.  #  Devices.Cells.CellArray     Type .  type CellArray{S,T}  : CellRef{S,T}\n    cell::S\n    origin::Point{2,T}\n    deltacol::Point{2,T}\n    deltarow::Point{2,T}\n    col::Int\n    row::Int\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend  Array of  cell  starting at  origin  with  row  rows and  col  columns, spanned by vectors  deltacol  and  deltarow . Optional x-reflection  xrefl , magnification factor  mag , and rotation angle  rot  in degrees are for the array as a whole.  The type variable  S  is to avoid circular definitions with  Cell .  CellArray { T : Real } ( x : :Cell ,   origin : :Point { 2 , T } ,   dc : :Point { 2 , T } ,   dr : :Point { 2 , T } , \n     c : :Integer ,   r : :Integer ;   xrefl = false ,   mag = 1 .0 ,   rot = 0 .0 )   Construct a  CellArray{typeof(x),T}  object, with  xrefl ,  mag , and  rot  as keyword arguments (x-reflection, magnification factor, rotation in degrees).  CellArray { T : Real } ( x : :Cell ,   c : :Range { T } ,   r : :Range { T } ; \n     xrefl = false ,   mag = 1 .0 ,   rot = 0 .0 )   Construct a  CellArray{typeof(x), T}  based on ranges (probably  LinSpace  or  FloatRange ).  c  specifies column coordinates and  r  for the rows. Pairs from  c  and  r  specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting  CellArray 's bounding box; some care is required.  xrefl ,  mag , and  rot  are keyword arguments (x-reflection, magnification factor, rotation in degrees).  #  Devices.Cells.CellArray     Method .  CellArray { T : Real } ( x : :Cell ,   origin : :Point { 2 , T } ,   dc : :Point { 2 , T } ,   dr : :Point { 2 , T } , \n     c : :Integer ,   r : :Integer ;   xrefl = false ,   mag = 1 .0 ,   rot = 0 .0 )   Construct a  CellArray{typeof(x),T}  object, with  xrefl ,  mag , and  rot  as keyword arguments (x-reflection, magnification factor, rotation in degrees).  #  Devices.Cells.CellArray     Method .  CellArray { T : Real } ( x : :Cell ,   c : :Range { T } ,   r : :Range { T } ; \n     xrefl = false ,   mag = 1 .0 ,   rot = 0 .0 )   Construct a  CellArray{typeof(x), T}  based on ranges (probably  LinSpace  or  FloatRange ).  c  specifies column coordinates and  r  for the rows. Pairs from  c  and  r  specify the origins of the repeated cells. The extrema of the ranges therefore do not specify the extrema of the resulting  CellArray 's bounding box; some care is required.  xrefl ,  mag , and  rot  are keyword arguments (x-reflection, magnification factor, rotation in degrees).  #  Devices.Cells.CellReference     Type .  type CellReference{S,T}  : CellRef{S,T}\n    cell::S\n    origin::Point{2,T}\n    xrefl::Bool\n    mag::Float64\n    rot::Float64\nend  Reference to a  cell  positioned at  origin , with optional x-reflection  xrefl , magnification factor  mag , and rotation angle  rot  in degrees.  The type variable  S  is to avoid circular definitions with  Cell .  CellReference { T : Real } ( x : :Cell ,   y : :Point { 2 , T } = Point ( 0 ., 0 .); \n     xrefl = false ,   mag = 1 .0 ,   rot = 0 .0 )   Convenience constructor for  CellReference{typeof(x), T} .  #  Devices.Cells.CellReference     Method .  CellReference { T : Real } ( x : :Cell ,   y : :Point { 2 , T } = Point ( 0 ., 0 .); \n     xrefl = false ,   mag = 1 .0 ,   rot = 0 .0 )   Convenience constructor for  CellReference{typeof(x), T} .  #  Devices.bounds     Method .  bounds ( ref : :CellArray ;   kwargs ...)   Returns a  Rectangle  bounding box with properties specified by  kwargs...  around all objects in  ref . The bounding box respects reflection, rotation, and magnification specified by  ref .  Please do rewrite this method when feeling motivated... it is very inefficient.  #  Devices.bounds     Method .  bounds ( ref : :CellReference ;   kwargs ...)   Returns a  Rectangle  bounding box with properties specified by  kwargs...  around all objects in  ref . The bounding box respects reflection, rotation, and magnification specified by  ref .  #  Base.copy     Method .  copy(x::CellReference)  Creates a shallow copy of  x  (does not copy the referenced cell).  #  Base.copy     Method .  copy(x::CellArray)  Creates a shallow copy of  x  (does not copy the arrayed cell).", 
            "title": "Referenced and arrayed cells"
        }, 
        {
            "location": "/cells/#resolving-references", 
            "text": "Sometimes it can be helpful to go between coordinate systems of cells and the cells they reference. This package provides methods to generate affine transforms to do this as easily as possible.  #  AffineTransforms.transform     Method .  transform(c::Cell, d::CellRef)  Given a cell  c  containing cell reference or array  d  in its tree of references, this function returns an  AffineTransform  object that lets you translate from the coordinate system of  d  to the coordinate system of  c .  If the  same exact  cell reference or array (as in, same address in memory) is included multiple times in the tree of references, then the resulting transform will be based on the first time it is encountered. The tree is traversed one level at a time to find the reference (optimized for shallow references).  Example: You want to translate (2.0,3.0) in the coordinate system of the referenced cell to the coordinate system of  c . Simply call:  transform(c,d)*Point(2.0,3.0) .  In some cases it may be desirable to resolve cell references or arrays into their corresponding polygons. This operation is called \"flattening.\"  #  Devices.Cells.flatten!     Function .  flatten!(c::Cell)  All cell references and arrays are turned into polygons and added to cell  c . The references and arrays are then removed. This \"flattening\" of the cell is recursive: references in referenced cells are flattened too. The modified cell is returned.  #  Devices.Cells.flatten     Function .  flatten{T :Real}(c::Cell{T})  All cell references and arrays are resolved into polygons, recursively. Together with the polygons already in cell  c , an array of polygons (type  AbstractPolygon{T} ) is returned. The cell  c  remains unmodified.  flatten(c::CellReference)  Cell reference  c  is resolved into polygons, recursively. An array of polygons (type  AbstractPolygon ) is returned. The cell reference  c  remains unmodified.  flatten(c::CellArray)  Cell array  c  is resolved into polygons, recursively. An array of polygons (type  AbstractPolygon ) is returned. The cell array  c  remains unmodified.", 
            "title": "Resolving references"
        }, 
        {
            "location": "/cells/#miscellaneous", 
            "text": "When saving cells to disk, there will be a tree of interdependencies and logically one would prefer to write the leaf nodes of the tree before any dependent cells. These functions are used to traverse the tree and then find the optimal ordering.  #  Devices.Cells.traverse!     Function .  traverse!(a::AbstractArray, c::Cell, level=1)  Given a cell, recursively traverse its references for other cells and add to array  a  some tuples:  (level, c) .  level  corresponds to how deep the cell was found, and  c  is the found cell.  #  Devices.Cells.order!     Function .  order!(a::AbstractArray)  Given an array of tuples like that coming out of  traverse! , we sort by the  level , strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).  For performance reasons, this function modifies  a  but what you want is the returned result array.", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/tags/", 
            "text": "For convenience\n\n\n    qrcode\n    radialcut\n    radialstub\n    cpwlauncher\n    launch!\n    checkerboard\n    pecbasedose", 
            "title": "For convenience"
        }, 
        {
            "location": "/tags/#for-convenience", 
            "text": "qrcode\n    radialcut\n    radialstub\n    cpwlauncher\n    launch!\n    checkerboard\n    pecbasedose", 
            "title": "For convenience"
        }, 
        {
            "location": "/render/", 
            "text": "Rendering\n\n\n#\n\n\nDevices.render!\n \n \nFunction\n.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \n:\n:Rectangles\n.Plain\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rectangle \nr\n to cell \nc\n with plain styling.\n\n\nReturns an array with the rectangle in it.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \ns\n:\n:Rectangles\n.Rounded\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rounded rectangle \nr\n to cell \nc\n. This is accomplished by rendering a path around the outside of a (smaller than requested) solid rectangle. The bounding box of \nr\n is preserved.\n\n\nReturns an array of the AbstractPolygons added to the cell.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \ns\n:\n:Rectangles\n.Undercut\n;\n\n    \nlayer\n=\n0\n,\n \nuclayer\n=\n0\n,\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rectangle \nr\n to cell \nc\n. Additionally, put a hollow border around the rectangle with layer \nuclayer\n. Useful for undercut structures.\n\n\nReturns an array of the AbstractPolygons added to the cell.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Rectangle\n,\n \ns\n:\n:Rectangles\n.Style\n=\nRectangles\n.Plain\n();\n \nkwargs\n...)\n\n\n\n\n\n\nRender a rectangle \nr\n to cell \nc\n, defaulting to plain styling.\n\n\nReturns an array of the AbstractPolygons added to the cell.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nr\n:\n:Polygon\n,\n \ns\n:\n:Polygons\n.Style\n=\nPolygons\n.Plain\n();\n \nkwargs\n...)\n\n\n\n\n\n\nRender a polygon \nr\n to cell \nc\n, defaulting to plain styling.\n\n\nReturns an array of the polygons added to the cell.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \np\n:\n:Path\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a path \np\n to a cell \nc\n.\n\n\nReturns an array of the polygons added to the cell.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nsegment\n:\n:Paths\n.Segment\n,\n \ns\n:\n:Paths\n.DecoratedStyle\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a \nsegment\n with decorated style \ns\n to cell \nc\n. Cell references held by the decorated style will have their fields modified by this method, which is why they are shallow copied in the \nPaths.attach!\n function.\n\n\nThis method draws the decorations before the path itself is drawn.\n\n\nrender\n!(\nc\n:\n:Cell\n,\n \nsegment\n:\n:Paths\n.Segment\n,\n \ns\n:\n:Paths\n.Style\n;\n \nkwargs\n...)\n\n\n\n\n\n\nRender a \nsegment\n with style \ns\n to cell \nc\n.", 
            "title": "Rendering"
        }, 
        {
            "location": "/render/#rendering", 
            "text": "#  Devices.render!     Function .  render !( c : :Cell ,   r : :Rectangle ,   : :Rectangles .Plain ;   kwargs ...)   Render a rectangle  r  to cell  c  with plain styling.  Returns an array with the rectangle in it.  render !( c : :Cell ,   r : :Rectangle ,   s : :Rectangles .Rounded ;   kwargs ...)   Render a rounded rectangle  r  to cell  c . This is accomplished by rendering a path around the outside of a (smaller than requested) solid rectangle. The bounding box of  r  is preserved.  Returns an array of the AbstractPolygons added to the cell.  render !( c : :Cell ,   r : :Rectangle ,   s : :Rectangles .Undercut ; \n     layer = 0 ,   uclayer = 0 ,   kwargs ...)   Render a rectangle  r  to cell  c . Additionally, put a hollow border around the rectangle with layer  uclayer . Useful for undercut structures.  Returns an array of the AbstractPolygons added to the cell.  render !( c : :Cell ,   r : :Rectangle ,   s : :Rectangles .Style = Rectangles .Plain ();   kwargs ...)   Render a rectangle  r  to cell  c , defaulting to plain styling.  Returns an array of the AbstractPolygons added to the cell.  render !( c : :Cell ,   r : :Polygon ,   s : :Polygons .Style = Polygons .Plain ();   kwargs ...)   Render a polygon  r  to cell  c , defaulting to plain styling.  Returns an array of the polygons added to the cell.  render !( c : :Cell ,   p : :Path ;   kwargs ...)   Render a path  p  to a cell  c .  Returns an array of the polygons added to the cell.  render !( c : :Cell ,   segment : :Paths .Segment ,   s : :Paths .DecoratedStyle ;   kwargs ...)   Render a  segment  with decorated style  s  to cell  c . Cell references held by the decorated style will have their fields modified by this method, which is why they are shallow copied in the  Paths.attach!  function.  This method draws the decorations before the path itself is drawn.  render !( c : :Cell ,   segment : :Paths .Segment ,   s : :Paths .Style ;   kwargs ...)   Render a  segment  with style  s  to cell  c .", 
            "title": "Rendering"
        }, 
        {
            "location": "/fileio/", 
            "text": "This package can load/save patterns in the GDS-II format only. In the future it may be useful to implement machine-specific pattern formats to force fracturing or dosing in an explicit manner.\n\n\n\n\nLoading patterns\n\n\nTo load a pattern, make sure you are \nusing FileIO\n.\n\n\n#\n\n\nFileIO.load\n \n \nMethod\n.\n\n\nload(f::File{format\nGDS\n})\n\n\n\n\n\nAn array of top-level cells (\nCell\n objects) found in the GDS-II file is returned. The other cells in the GDS-II file are retained by \nCellReference\n or \nCellArray\n objects held by the top-level cells.\n\n\nThe FileIO package treats the HEADER record as \"magic bytes,\" and therefore only GDS-II version 6.0.0 can be read. Warnings are thrown if the GDS-II file does not begin with a BGNLIB record following the HEADER record, but loading will proceed.\n\n\nEncountering an ENDLIB record will discard the remainder of the GDS-II file without warning. If no ENDLIB record is present, a warning will be thrown.\n\n\nThe content of some records are currently discarded (mainly the more obscure GDS-II record types, but also BGNLIB and LIBNAME).\n\n\n\n\nSaving patterns\n\n\nTo save a pattern, make sure you are \nusing FileIO\n.\n\n\n#\n\n\nFileIO.save\n \n \nMethod\n.\n\n\nsave\n(:\n:Union\n{\nAbstractString\n,\nIO\n}\n,\n \ncell0\n:\n:Cell\n,\n \ncell\n:\n:Cell\n...)\n\n\n\nsave\n(\nf\n:\n:File\n{\nformat\nGDS\n}\n,\n \ncell0\n:\n:Cell\n,\n \ncell\n:\n:Cell\n...;\n\n\nname\n=\nGDSIILIB\n,\n \nprecision\n=\n1e-9\n,\n \nunit\n=\n1e-6\n,\n \nmodify\n=\nnow\n(),\n \nacc\n=\nnow\n(),\n\n\nverbose\n=\nfalse\n)\n`\n\n\n\n\n\n\nThis bottom method is implicitly called when you use the convenient syntax of the top method: \nsave(\"/path/to/my.gds\", cells_i_want_to_save...)\n\n\nThe \nname\n keyword argument is used for the internal library name of the GDS-II file and is probably inconsequential for modern workflows.\n\n\nThe \nverbose\n keyword argument allows you to monitor the output of \ntraverse!\n and \norder!\n if something funny is happening while saving.\n\n\n\n\nInternals\n\n\n#\n\n\nDevices.GDS.GDSFloat\n \n \nType\n.\n\n\nabstract GDSFloat \n: Real\n\n\nFloating-point formats found in GDS-II files.\n\n\n#\n\n\nDevices.GDS.GDS64\n \n \nType\n.\n\n\nbitstype 64 GDS64 \n: GDSFloat\n\n\n\"8-byte (64-bit) real\" format found in GDS-II files.\n\n\n#\n\n\nBase.bits\n \n \nMethod\n.\n\n\nbits(x::GDS64)\n\n\nA string giving the literal bit representation of a GDS64 number.\n\n\n#\n\n\nBase.bswap\n \n \nMethod\n.\n\n\nbswap(x::GDS64)\n\n\nByte-swap a GDS64 number. Used implicitly by \nhton\n, \nntoh\n for endian conversion.\n\n\n#\n\n\nDevices.GDS.gdswrite\n \n \nFunction\n.\n\n\ngdswrite(io::IO, cell::Cell)\n\n\n\n\n\nWrite a \nCell\n to an IO buffer. The creation and modification date of the cell are written first, followed by the cell name, the polygons in the cell, and finally any references or arrays.\n\n\ngdswrite\n{\nT\n}\n(\nio\n:\n:IO\n,\n \nel\n:\n:AbstractPolygon\n{\nT\n}\n;\n \nunit\n=\n1e-6\n,\n \nprecision\n=\n1e-9\n)\n\n\n\n\n\n\nWrite a polygon to an IO buffer. The layer and datatype are written first, then the \nAbstractPolygon{T}\n object is converted to a \nPolygon{T}\n, and the boundary of the polygon is written in a 32-bit integer format with specified database unit and precision.\n\n\ngdswrite\n(\nio\n:\n:IO\n,\n \nel\n:\n:CellReference\n;\n \nunit\n=\n1e-6\n,\n \nprecision\n=\n1e-9\n)\n\n\n\n\n\n\nWrite a cell reference to an IO buffer. The name of the referenced cell is written first. Reflection, magnification, and rotation info are written next. Finally, the origin of the cell reference is written.\n\n\ngdswrite\n(\nio\n:\n:IO\n,\n \nel\n:\n:CellArray\n;\n \nunit\n=\n1e-6\n,\n \nprecision\n=\n1e-9\n)\n\n\n\n\n\n\nWrite a cell array to an IO buffer. The name of the referenced cell is written first. Reflection, magnification, and rotation info are written next. After that the number of columns and rows are written. Finally, the origin, column vector, and row vector are written.\n\n\n#\n\n\nDevices.GDS.strans\n \n \nFunction\n.\n\n\nstrans(io::IO, ref)\n\n\n\n\n\nWrites bytes to the IO stream (if needed) to encode x-reflection, magnification, and rotation settings of a reference or array. Returns the number of bytes written.\n\n\n#\n\n\nBase.write\n \n \nMethod\n.\n\n\nwrite(s::IO, x::GDS64)\n\n\nWrite a GDS64 number to an IO stream.", 
            "title": "File formats"
        }, 
        {
            "location": "/fileio/#loading-patterns", 
            "text": "To load a pattern, make sure you are  using FileIO .  #  FileIO.load     Method .  load(f::File{format GDS })  An array of top-level cells ( Cell  objects) found in the GDS-II file is returned. The other cells in the GDS-II file are retained by  CellReference  or  CellArray  objects held by the top-level cells.  The FileIO package treats the HEADER record as \"magic bytes,\" and therefore only GDS-II version 6.0.0 can be read. Warnings are thrown if the GDS-II file does not begin with a BGNLIB record following the HEADER record, but loading will proceed.  Encountering an ENDLIB record will discard the remainder of the GDS-II file without warning. If no ENDLIB record is present, a warning will be thrown.  The content of some records are currently discarded (mainly the more obscure GDS-II record types, but also BGNLIB and LIBNAME).", 
            "title": "Loading patterns"
        }, 
        {
            "location": "/fileio/#saving-patterns", 
            "text": "To save a pattern, make sure you are  using FileIO .  #  FileIO.save     Method .  save (: :Union { AbstractString , IO } ,   cell0 : :Cell ,   cell : :Cell ...)  save ( f : :File { format GDS } ,   cell0 : :Cell ,   cell : :Cell ...;  name = GDSIILIB ,   precision = 1e-9 ,   unit = 1e-6 ,   modify = now (),   acc = now (),  verbose = false ) `   This bottom method is implicitly called when you use the convenient syntax of the top method:  save(\"/path/to/my.gds\", cells_i_want_to_save...)  The  name  keyword argument is used for the internal library name of the GDS-II file and is probably inconsequential for modern workflows.  The  verbose  keyword argument allows you to monitor the output of  traverse!  and  order!  if something funny is happening while saving.", 
            "title": "Saving patterns"
        }, 
        {
            "location": "/fileio/#internals", 
            "text": "#  Devices.GDS.GDSFloat     Type .  abstract GDSFloat  : Real  Floating-point formats found in GDS-II files.  #  Devices.GDS.GDS64     Type .  bitstype 64 GDS64  : GDSFloat  \"8-byte (64-bit) real\" format found in GDS-II files.  #  Base.bits     Method .  bits(x::GDS64)  A string giving the literal bit representation of a GDS64 number.  #  Base.bswap     Method .  bswap(x::GDS64)  Byte-swap a GDS64 number. Used implicitly by  hton ,  ntoh  for endian conversion.  #  Devices.GDS.gdswrite     Function .  gdswrite(io::IO, cell::Cell)  Write a  Cell  to an IO buffer. The creation and modification date of the cell are written first, followed by the cell name, the polygons in the cell, and finally any references or arrays.  gdswrite { T } ( io : :IO ,   el : :AbstractPolygon { T } ;   unit = 1e-6 ,   precision = 1e-9 )   Write a polygon to an IO buffer. The layer and datatype are written first, then the  AbstractPolygon{T}  object is converted to a  Polygon{T} , and the boundary of the polygon is written in a 32-bit integer format with specified database unit and precision.  gdswrite ( io : :IO ,   el : :CellReference ;   unit = 1e-6 ,   precision = 1e-9 )   Write a cell reference to an IO buffer. The name of the referenced cell is written first. Reflection, magnification, and rotation info are written next. Finally, the origin of the cell reference is written.  gdswrite ( io : :IO ,   el : :CellArray ;   unit = 1e-6 ,   precision = 1e-9 )   Write a cell array to an IO buffer. The name of the referenced cell is written first. Reflection, magnification, and rotation info are written next. After that the number of columns and rows are written. Finally, the origin, column vector, and row vector are written.  #  Devices.GDS.strans     Function .  strans(io::IO, ref)  Writes bytes to the IO stream (if needed) to encode x-reflection, magnification, and rotation settings of a reference or array. Returns the number of bytes written.  #  Base.write     Method .  write(s::IO, x::GDS64)  Write a GDS64 number to an IO stream.", 
            "title": "Internals"
        }, 
        {
            "location": "/idx/", 
            "text": "Index\n\n\n\n\nDevices.AbstractPolygon\n\n\nDevices.Cells.Cell\n\n\nDevices.Cells.CellArray\n\n\nDevices.Cells.CellReference\n\n\nDevices.GDS.GDS64\n\n\nDevices.GDS.GDSFloat\n\n\nDevices.Paths.CPW\n\n\nDevices.Paths.CompoundSegment\n\n\nDevices.Paths.CompoundStyle\n\n\nDevices.Paths.DecoratedStyle\n\n\nDevices.Paths.Path\n\n\nDevices.Paths.Segment\n\n\nDevices.Paths.Straight\n\n\nDevices.Paths.Style\n\n\nDevices.Paths.Trace\n\n\nDevices.Paths.Turn\n\n\nDevices.Polygons.Polygon\n\n\nDevices.Rectangles.Rectangle\n\n\nDevices.Cells.flatten\n\n\nDevices.Cells.flatten!\n\n\nDevices.Cells.order!\n\n\nDevices.Cells.traverse!\n\n\nDevices.GDS.gdswrite\n\n\nDevices.GDS.strans\n\n\nDevices.Paths.adjust!\n\n\nDevices.Paths.attach!\n\n\nDevices.Paths.attachments\n\n\nDevices.Paths.direction\n\n\nDevices.Paths.distance\n\n\nDevices.Paths.extent\n\n\nDevices.Paths.launch!\n\n\nDevices.Paths.meander!\n\n\nDevices.Paths.p0\n\n\nDevices.Paths.p1\n\n\nDevices.Paths.param\n\n\nDevices.Paths.pathlength\n\n\nDevices.Paths.paths\n\n\nDevices.Paths.setp0!\n\n\nDevices.Paths.set\u03b10!\n\n\nDevices.Paths.simplify\n\n\nDevices.Paths.simplify!\n\n\nDevices.Paths.straight!\n\n\nDevices.Paths.style0\n\n\nDevices.Paths.style1\n\n\nDevices.Paths.turn!\n\n\nDevices.Paths.undecorated\n\n\nDevices.Paths.width\n\n\nDevices.Paths.\u03b10\n\n\nDevices.Paths.\u03b11\n\n\nDevices.Points.getx\n\n\nDevices.Points.gety\n\n\nDevices.Polygons.clip\n\n\nDevices.Polygons.offset\n\n\nDevices.Tags.checkerboard\n\n\nDevices.Tags.pecbasedose\n\n\nDevices.Tags.qrcode\n\n\nDevices.Tags.radialcut\n\n\nDevices.Tags.radialstub\n\n\nDevices.render!", 
            "title": "Index"
        }, 
        {
            "location": "/idx/#index", 
            "text": "Devices.AbstractPolygon  Devices.Cells.Cell  Devices.Cells.CellArray  Devices.Cells.CellReference  Devices.GDS.GDS64  Devices.GDS.GDSFloat  Devices.Paths.CPW  Devices.Paths.CompoundSegment  Devices.Paths.CompoundStyle  Devices.Paths.DecoratedStyle  Devices.Paths.Path  Devices.Paths.Segment  Devices.Paths.Straight  Devices.Paths.Style  Devices.Paths.Trace  Devices.Paths.Turn  Devices.Polygons.Polygon  Devices.Rectangles.Rectangle  Devices.Cells.flatten  Devices.Cells.flatten!  Devices.Cells.order!  Devices.Cells.traverse!  Devices.GDS.gdswrite  Devices.GDS.strans  Devices.Paths.adjust!  Devices.Paths.attach!  Devices.Paths.attachments  Devices.Paths.direction  Devices.Paths.distance  Devices.Paths.extent  Devices.Paths.launch!  Devices.Paths.meander!  Devices.Paths.p0  Devices.Paths.p1  Devices.Paths.param  Devices.Paths.pathlength  Devices.Paths.paths  Devices.Paths.setp0!  Devices.Paths.set\u03b10!  Devices.Paths.simplify  Devices.Paths.simplify!  Devices.Paths.straight!  Devices.Paths.style0  Devices.Paths.style1  Devices.Paths.turn!  Devices.Paths.undecorated  Devices.Paths.width  Devices.Paths.\u03b10  Devices.Paths.\u03b11  Devices.Points.getx  Devices.Points.gety  Devices.Polygons.clip  Devices.Polygons.offset  Devices.Tags.checkerboard  Devices.Tags.pecbasedose  Devices.Tags.qrcode  Devices.Tags.radialcut  Devices.Tags.radialstub  Devices.render!", 
            "title": "Index"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The Devices.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}