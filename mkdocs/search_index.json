{
    "docs": [
        {
            "location": "/", 
            "text": "Devices.jl\n\n\nA \nJulia\n package for designing CAD files for superconducting devices.\n\n\n\n\nInstallation\n\n\n\n\n\n\nInstall \ngdspy\n, which is currently used only for rendering paths into polygons: \npip install gdspy\n. Ensure that it is accessible from the Python installation that PyCall.jl is using.\n\n\n\n\n\n\nInstall \npyclipper\n, which is used for polygon offsetting: \npip install pyclipper\n.\n\n\n\n\n\n\nInstall \npyqrcode\n, which is used for generating QR codes: \npip install pyqrcode\n.\n\n\n\n\n\n\nUsing features implemented with \nGPC\n require building shared libraries from the C code.\n\n\n\n\n\n\nPkg.clone(\"https://github.com/ajkeller34/Devices.jl.git\")\n\n\n\n\n\n\n\n\nQuick start\n\n\nusing Devices, FileIO\n\np = Path()\nstyle = launch!(p)\nstraight!(p,500,style)\nturn!(p,\u03c0/2,150)\nstraight!(p,500)\nlaunch!(p)\nc = Cell(\nmain\n)\nrender!(c, p)\nsave(\ntest.gds\n, c)", 
            "title": "Home"
        }, 
        {
            "location": "/#devicesjl", 
            "text": "A  Julia  package for designing CAD files for superconducting devices.", 
            "title": "Devices.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "Install  gdspy , which is currently used only for rendering paths into polygons:  pip install gdspy . Ensure that it is accessible from the Python installation that PyCall.jl is using.    Install  pyclipper , which is used for polygon offsetting:  pip install pyclipper .    Install  pyqrcode , which is used for generating QR codes:  pip install pyqrcode .    Using features implemented with  GPC  require building shared libraries from the C code.    Pkg.clone(\"https://github.com/ajkeller34/Devices.jl.git\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "using Devices, FileIO\n\np = Path()\nstyle = launch!(p)\nstraight!(p,500,style)\nturn!(p,\u03c0/2,150)\nstraight!(p,500)\nlaunch!(p)\nc = Cell( main )\nrender!(c, p)\nsave( test.gds , c)", 
            "title": "Quick start"
        }, 
        {
            "location": "/api/", 
            "text": "Points\n\n\nPoints are implemented using the abstract type \nFixedVectorNoTuple\n from \nFixedSizeArrays.jl\n. This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike \nTuple\n objects, we can add points together, simplifying many function definitions.\n\n\nTo interface with gdspy, we simply convert the \nPoint\n object to a \nTuple\n and let \nPyCall.jl\n figure out what to do.\n\n\n#\n\n\nDevices.Points.getx\n \n \nFunction\n.\n\n\n\n\ngetx(p::Point)\n\n\nGet the x-coordinate of a point.\n\n\n#\n\n\nDevices.Points.gety\n \n \nFunction\n.\n\n\n\n\ngety(p::Point)\n\n\nGet the y-coordinate of a point.\n\n\n\n\nPaths\n\n\n\n\nSegments\n\n\n#\n\n\nDevices.Paths.Segment\n \n \nType\n.\n\n\n\n\nabstract Segment{T\n:Real}\n\n\nPath segment in the plane. All Segment objects should have the implement the following methods:\n\n\n\n\nlength\n\n\norigin\n\n\n\u03b10\n\n\nsetorigin!\n\n\nset\u03b10!\n\n\nlastangle\n\n\n\n\n#\n\n\nDevices.Paths.Straight\n \n \nType\n.\n\n\n\n\ntype Straight{T\n:Real} \n: Segment{T}\n\n\nA straight line segment is parameterized by its length. It begins at a point \norigin\n with initial angle \n\u03b10\n.\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the line segment is given by:\n\n\nt -\n origin + Point(t*l*cos(\u03b1),t*l*sin(\u03b1))\n\n\n#\n\n\nDevices.Paths.Turn\n \n \nType\n.\n\n\n\n\ntype Turn{T\n:Real} \n: Segment{T}\n\n\nA circular turn is parameterized by the turn angle \n\u03b1\n and turning radius \nr\n. It begins at a point \norigin\n with initial angle \n\u03b10\n.\n\n\nThe center of the circle is given by:\n\n\ncen = origin + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))\n\n\nThe parametric function over \nt \u2208 [0,1]\n describing the turn is given by:\n\n\nt -\n cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))\n\n\n#\n\n\nDevices.Paths.CompoundSegment\n \n \nType\n.\n\n\n\n\ntype CompoundSegment{T\n:Real} \n: Segment{T}\n\n\nConsider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes.\n\n\n\n\nStyles\n\n\n#\n\n\nDevices.Paths.Style\n \n \nType\n.\n\n\n\n\nabstract Style\n\n\nHow to render a given path segment. All styles should implement the following methods:\n\n\n\n\ndistance\n\n\nextent\n\n\npaths\n\n\nwidth\n\n\ndivs\n\n\n\n\n#\n\n\nDevices.Paths.Trace\n \n \nType\n.\n\n\n\n\ntype Trace \n: Style\n\n\nSimple, single trace.\n\n\n\n\nwidth::Function\n: trace width.\n\n\ndivs::Int\n: number of segments to render. Increase if you see artifacts.\n\n\n\n\n#\n\n\nDevices.Paths.CPW\n \n \nType\n.\n\n\n\n\ntype CPW \n: Style\n\n\nTwo adjacent traces can form a coplanar waveguide.\n\n\n\n\ntrace::Function\n: center conductor width.\n\n\ngap::Function\n: distance between center conductor edges and ground plane\n\n\ndivs::Int\n: number of segments to render. Increase if you see artifacts.\n\n\n\n\nMay need to be inverted with respect to a ground plane, depending on how the pattern is written.\n\n\n#\n\n\nDevices.Paths.CompoundStyle\n \n \nType\n.\n\n\n\n\ntype CompoundStyle{T\n:Real} \n: Style\n\n\nCombines styles together for use with a \nCompoundSegment\n.\n\n\n\n\nsegments\n: Needed for divs function.\n\n\nstyles\n: Array of styles making up the object.\n\n\nf\n: returns tuple of style index and the \nt\n to use for that style's parametric function.\n\n\n\n\n\n\nPath interrogation\n\n\n#\n\n\nDevices.Paths.direction\n \n \nFunction\n.\n\n\n\n\ndirection(p::Function, t)\n\n\nFor some parameteric function \np(t)\u21a6Point(x(t),y(t))\n, returns the angle at which the path is pointing for a given \nt\n.\n\n\n#\n\n\nDevices.Paths.pathlength\n \n \nFunction\n.\n\n\n\n\npathlength(p::AbstractArray{Segment})\n\n\nTotal physical length of segments.\n\n\npathlength(p::Path)\n\n\nPhysical length of a path. Note that \nlength\n will return the number of segments in a path, not the physical length.\n\n\n#\n\n\nDevices.Paths.origin\n \n \nFunction\n.\n\n\n\n\norigin(p::Path)\n\n\nFirst point of a path.\n\n\norigin{T}(s::Segment{T})\n\n\nReturn the first point in a segment (calculated).\n\n\n#\n\n\nDevices.Paths.setorigin!\n \n \nFunction\n.\n\n\n\n\nsetorigin!(s::CompoundSegment, p::Point)\n\n\nSet the origin of a compound segment.\n\n\nsetorigin!(s::Turn, p::Point)\n\n\nSet the origin of a turn.\n\n\nsetorigin!(s::Straight, p::Point)\n\n\nSet the origin of a straight segment.\n\n\n#\n\n\nDevices.Paths.\u03b10\n \n \nFunction\n.\n\n\n\n\n\u03b10(p::Path)\n\n\nFirst angle of a path.\n\n\n\u03b10(s::Segment)\n\n\nReturn the first angle in a segment (calculated).\n\n\n#\n\n\nDevices.Paths.set\u03b10!\n \n \nFunction\n.\n\n\n\n\nset\u03b10!(s::CompoundSegment, \u03b10\u2032)\n\n\nSet the starting angle of a compound segment.\n\n\nset\u03b10!(s::Turn, \u03b10\u2032)\n\n\nSet the starting angle of a turn.\n\n\nset\u03b10!(s::Straight, \u03b10\u2032)\n\n\nSet the angle of a straight segment.\n\n\n#\n\n\nDevices.Paths.lastpoint\n \n \nFunction\n.\n\n\n\n\nlastpoint(p::Path)\n\n\nLast point of a path.\n\n\nlastpoint{T}(s::Segment{T})\n\n\nReturn the last point in a segment (calculated).\n\n\n#\n\n\nDevices.Paths.lastangle\n \n \nFunction\n.\n\n\n\n\nlastangle(p::Path)\n\n\nLast angle of a path.\n\n\nlastangle(s::Segment)\n\n\nReturn the last angle in a segment (calculated).\n\n\n#\n\n\nDevices.Paths.firststyle\n \n \nFunction\n.\n\n\n\n\nfirststyle(p::Path)\n\n\nStyle of the first segment of a path.\n\n\n#\n\n\nDevices.Paths.laststyle\n \n \nFunction\n.\n\n\n\n\nlaststyle(p::Path)\n\n\nStyle of the last segment of a path.\n\n\n\n\nPath building\n\n\n#\n\n\nDevices.Paths.adjust!\n \n \nFunction\n.\n\n\n\n\nadjust!(p::Path, n::Integer=1)\n\n\nAdjust a path's parametric functions starting from index \nn\n. Used internally whenever segments are inserted into the path.\n\n\n#\n\n\nDevices.Paths.launch!\n \n \nFunction\n.\n\n\n\n\nlaunch!(p::Path; extround=5, trace0=300, trace1=5,         gap0=150, gap1=2.5, flatlen=250, taperlen=250)\n\n\nAdd a launcher to the path. Somewhat intelligent in that the launcher will reverse its orientation depending on if it is at the start or the end of a path.\n\n\nThere are numerous keyword arguments to control the behavior:\n\n\n\n\nextround\n: Rounding radius of the outermost corners; should be less than \ngap0\n.\n\n\ntrace0\n: Bond pad width.\n\n\ntrace1\n: Center trace width of next CPW segment.\n\n\ngap0\n: Gap width adjacent to bond pad.\n\n\ngap1\n: Gap width of next CPW segment.\n\n\nflatlen\n: Bond pad length.\n\n\ntaperlen\n: Length of taper region between bond pad and next CPW segment.\n\n\n\n\nReturns a \nStyle\n object suitable for continuity with the next segment. Ignore the returned style if you are terminating a path.\n\n\n#\n\n\nDevices.Paths.meander!\n \n \nFunction\n.\n\n\n\n\nmeander!{T\n:Real}(p::Path{T}, len, r, straightlen, \u03b1::Real)\n\n\nAlternate between going straight with length \nstraightlen\n and turning with radius \nr\n and angle \n\u03b1\n. Each turn goes the opposite direction of the previous. The total length is \nlen\n. Useful for making resonators.\n\n\nThe straight and turn segments are combined into a \nCompoundSegment\n and appended to the path \np\n.\n\n\n#\n\n\nDevices.Paths.param\n \n \nFunction\n.\n\n\n\n\nparam{T\n:Real}(c::CompoundSegment{T})\n\n\nReturn a parametric function over the domain [0,1] that represents the compound segment.\n\n\n#\n\n\nDevices.Paths.simplify!\n \n \nFunction\n.\n\n\n\n\nsimplify!(p::Path)\n\n\nAll segments of a path are turned into a \nCompoundSegment\n and all styles of a path are turned into a \nCompoundStyle\n. The idea here is:\n\n\n\n\nIndexing the path becomes more sane when you can combine several path segments into one logical element. A launcher would have several indices in a path unless you could simplify it.\n\n\nYou don't need to think hard about boundaries between straights and turns when you want a continuous styling of a very long path.\n\n\n\n\n#\n\n\nDevices.Paths.straight!\n \n \nFunction\n.\n\n\n\n\nstraight!(p::Path, l::Real)\n\n\nExtend a path \np\n straight by length \nl\n in the current direction.\n\n\n#\n\n\nDevices.Paths.turn!\n \n \nFunction\n.\n\n\n\n\nturn!(p::Path, s::ASCIIString, r::Real, sty::Style=laststyle(p))\n\n\nTurn a path \np\n with direction coded by string \ns\n:\n\n\n\n\n\"l\": turn by \u03c0/2 (left)\n\n\n\"r\": turn by -\u03c0/2 (right)\n\n\n\"lrlrllrrll\": do those turns in that order\n\n\n\n\nturn!(p::Path, \u03b1::Real, r::Real, sty::Style=laststyle(p))\n\n\nTurn a path \np\n by angle \n\u03b1\n with a turning radius \nr\n in the current direction. Positive angle turns left.\n\n\n\n\nInterfacing with gdspy\n\n\n#\n\n\nDevices.Paths.distance\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the distance between the centers of parallel paths rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.extent\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns a distance tangential to the path specifying the lateral extent of the polygons rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.paths\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the number of parallel paths rendered by gdspy.\n\n\n#\n\n\nDevices.Paths.width\n \n \nFunction\n.\n\n\n\n\nFor a style \ns\n and parameteric argument \nt\n, returns the width of paths rendered by gdspy.\n\n\n\n\nPolygons\n\n\n\n\nRectangles\n\n\n#\n\n\nDevices.Rectangles.Rectangle\n \n \nType\n.\n\n\n\n\ntype Rectangle{T\n:Real} \n: AbstractPolygon{T}\n\n\nA rectangle, defined by opposing corner coordinates.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds(r::Rectangle)\n\n\nNo-op (just returns \nr\n).\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\ns.\n\n\n#\n\n\nDevices.Rectangles.center\n \n \nMethod\n.\n\n\n\n\ncenter(r::Rectangle)\n\n\nReturns a Point corresponding to the center of the rectangle.\n\n\n#\n\n\nDevices.Rectangles.height\n \n \nMethod\n.\n\n\n\n\nheight(r::Rectangle)\n\n\nReturn the height of a rectangle.\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\n\n\nminimum(r::Rectangle)\n\n\nReturns the lower-left corner of a rectangle (Point object).\n\n\nminimum(itr)\n\n\n\n\n\nReturns the smallest element in a collection.\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\n\n\nmaximum(r::Rectangle)\n\n\nReturns the upper-right corner of a rectangle (Point object).\n\n\nmaximum(itr)\n\n\n\n\n\nReturns the largest element in a collection.\n\n\n#\n\n\nDevices.Rectangles.width\n \n \nMethod\n.\n\n\n\n\nwidth(r::Rectangle)\n\n\nReturn the width of a rectangle.\n\n\n\n\nPolygons\n\n\n#\n\n\nDevices.Polygons.Polygon\n \n \nType\n.\n\n\n\n\ntype Polygon{T\n:Real}\n\n\nPolygon defined by list of coordinates (not repeating start).\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds(p::Polygon)\n\n\nReturn a bounding Rectangle with no properties for polygon \np\n.\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\ns.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds{T\n:AbstractPolygon}(parr::AbstractArray{T,1})\n\n\nReturn a bounding \nRectangle\n with no properties for an array \nparr\n of \nAbstractPolygon\ns.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds(p0::AbstractPolygon, p::AbstractPolygon...)\n\n\nReturn a bounding \nRectangle\n with no properties for several \nAbstractPolygon\ns.\n\n\n#\n\n\nBase.minimum\n \n \nMethod\n.\n\n\n\n\nminimum(x::Polygon)\n\n\nReturn the lower-left-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nminimum(itr)\n\n\n\n\n\nReturns the smallest element in a collection.\n\n\n#\n\n\nBase.maximum\n \n \nMethod\n.\n\n\n\n\nmaximum(x::Polygon)\n\n\nReturn the upper-right-most corner of a rectangle bounding polygon \nx\n. Note that this point doesn't have to be in the polygon.\n\n\nmaximum(itr)\n\n\n\n\n\nReturns the largest element in a collection.\n\n\n\n\nClipping and offsetting\n\n\nAs of now this package's notion of polygons is that there are no \"inner holes.\" Probably it would be helpful if we expanded our definition.\n\n\nFor clipping polygons we use \nGPC\n to get triangle strips which never have holes in them. These are then rendered as polygons individually. An obvious downside is that subsequent offsetting will not work as desired.\n\n\nFor offsetting polygons we use \nClipper\n. Clipper does not seem to support triangle strips so although the clipping is probably superior we cannot use it easily for now.\n\n\n#\n\n\nDevices.Polygons.clip\n \n \nFunction\n.\n\n\n\n\nclip{S\n:Real, T\n:Real}(op::ClipperOp, subject::Polygon{S}, clip::Polygon{T})\n\n\nClip polygon \nsubject\n by polygon \nclip\n using operation \nop\n from the \nClipper library\n. The \nPython wrapper\n over the C++ library is used.\n\n\nValid \nClipperOp\n include \nCT_INTERSECTION\n, \nCT_UNION\n, \nCT_DIFFERENCE\n, \nCT_XOR\n.\n\n\nclip(op::GPCOp, subject::Polygon{Cdouble}, clip::Polygon{Cdouble})\n\n\nUse the GPC clipping library to do polygon manipulations. Valid GPCOp include \nGPC_DIFF\n, \nGPC_INT\n, \nGPC_XOR\n, \nGPC_UNION\n.\n\n\n#\n\n\nDevices.Polygons.offset\n \n \nFunction\n.\n\n\n\n\noffset{S\n:Real}(subject::Polygon{S}, delta::Real,         j::ClipperJoin=JT_MITER, e::ClipperEnd=ET_CLOSEDPOLYGON)\n\n\nOffset a polygon \nsubject\n by some amount \ndelta\n using the \nClipper library\n. The \nPython wrapper\n over the C++ library is used.\n\n\nClipperJoin\n parameters are discussed \nhere\n. Valid syntax in this package is: \nJT_SQUARE\n, \nJT_ROUND\n, \nJT_MITER\n.\n\n\nClipperEnd\n parameters are discussed \nhere\n. Valid syntax in this package is: \nET_CLOSEDPOLYGON\n, \nET_CLOSEDLINE\n, \nET_OPENSQUARE\n, \nET_OPENROUND\n, \nET_OPENBUTT\n.\n\n\nTo do: Handle the type parameter of Polygon, which is ignored now.\n\n\n\n\nCells\n\n\n#\n\n\nDevices.Cells.Cell\n \n \nType\n.\n\n\n\n\nCell\n\n\nA cell has a name and contains polygons and references to \nCellArray\n or \nCellReference\n objects. It also records the time of its own creation.\n\n\nTo add elements, push them to \nelements\n field; to add references, push them to \nrefs\n field.\n\n\n#\n\n\nDevices.Cells.CellArray\n \n \nType\n.\n\n\n\n\nCellArray{S,T\n:Real}\n\n\nArray of \ncell\n starting at \norigin\n with \nrow\n rows and \ncol\n columns, spanned by vectors \ndeltacol\n and \ndeltarow\n. Optional x-reflection \nxrefl::Bool\n, magnification factor \nmag\n, and rotation angle \nrot\n in degrees are for the array as a whole.\n\n\nThe type variable \nS\n is to avoid circular definitions with \nCell\n.\n\n\n#\n\n\nDevices.Cells.CellReference\n \n \nType\n.\n\n\n\n\nCellReference{S,T\n:Real}\n\n\nReference to a \ncell\n positioned at \norigin\n, with optional x-reflection \nxrefl::Bool\n, magnification factor \nmag\n, and rotation angle \nrot\n in degrees.\n\n\nThe type variable \nS\n is to avoid circular definitions with \nCell\n.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds(cell::Cell; kwargs...)\n\n\nReturns a \nRectangle\n bounding box with no properties around all objects in \ncell\n. \nPoint(NaN, NaN)\n is used for the corners if there is nothing inside the cell.\n\n\n#\n\n\nDevices.bounds\n \n \nMethod\n.\n\n\n\n\nbounds(ref::CellReference; kwargs...)\n\n\nReturns a \nRectangle\n bounding box with no properties around all objects in \nref\n. \nPoint(NaN, NaN)\n is used for the corners if there is nothing inside the cell referenced by \nref\n. The bounding box respects reflection, rotation, and magnification specified by \nref\n.\n\n\n#\n\n\nDevices.Cells.traverse!\n \n \nFunction\n.\n\n\n\n\ntraverse!(a::AbstractArray, c::Cell, level=1)\n\n\nGiven a cell, recursively traverse its references for other cells and add to array \na\n some tuples: \n(level, c)\n. \nlevel\n corresponds to how deep the cell was found, and \nc\n is the found cell.\n\n\n#\n\n\nDevices.Cells.order!\n \n \nFunction\n.\n\n\n\n\norder!(a::AbstractArray)\n\n\nGiven an array of tuples like that coming out of \ntraverse!\n, we sort by the \nlevel\n, strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).\n\n\nFor performance reasons, this function modifies \na\n but what you want is the returned result array.\n\n\n\n\nRendering\n\n\n#\n\n\nDevices.render!\n \n \nFunction\n.\n\n\n\n\nrender!(c::Cell, segment::Paths.Segment, s::Paths.Style; kwargs...)\n\n\nRender a \nsegment\n with style \ns\n to cell \nc\n.\n\n\nrender!(c::Cell, segment::Paths.Segment, s::Paths.DecoratedStyle; kwargs...)\n\n\nRender a \nsegment\n with decorated style \ns\n to cell \nc\n. This method draws the decorations before the path itself is drawn.\n\n\nrender!(c::Cell, p::Path; kwargs...)\n\n\nRender a path \np\n to a cell \nc\n.\n\n\nrender!(c::Cell, r::Polygon, s::Polygons.Style=Polygons.Plain(); kwargs...)\n\n\nRender a polygon \nr\n to cell \nc\n, defaulting to plain styling.\n\n\nrender!(c::Cell, r::Rectangle, s::Rectangles.Style=Rectangles.Plain(); kwargs...)\n\n\nRender a rectangle \nr\n to cell \nc\n, defaulting to plain styling.\n\n\nrender!(c::Cell, r::Rectangle, s::Rectangles.Rounded; kwargs...)\n\n\nRender a rounded rectangle \nr\n to cell \nc\n. This is accomplished by rendering a path around the outside of a (smaller than requested) solid rectangle. The bounding box of \nr\n is preserved.\n\n\nrender!(c::Cell, r::Rectangle, ::Rectangles.Plain; kwargs...)\n\n\nRender a rectangle \nr\n to cell \nc\n with plain styling.\n\n\n\n\nSaving patterns\n\n\nTo save a pattern, make sure you are \nusing FileIO\n.\n\n\n#\n\n\nFileIO.save\n \n \nMethod\n.\n\n\n\n\nsave\n(\nf\n:\n:File\n{\nformat\nGDS\n}\n,\n \ncell0\n:\n:Cell\n,\n \ncell\n:\n:Cell\n...;\n\n\nname\n=\nGDSIILIB\n,\n \nprecision\n=\n1e-9\n,\n \nunit\n=\n1e-6\n,\n \nmodify\n=\nnow\n(),\n \nacc\n=\nnow\n(),\n\n\nverbose\n=\nfalse\n)\n`\n\n\n\n\n\n\nThis method is implicitly called when you use the convenient syntax: \nsave(\"/path/to/my.gds\", cells_i_want_to_save...)\n\n\nThe \nname\n keyword argument is used for the internal library name of the GDS-II file and is probably inconsequential for modern workflows.\n\n\nThe \nverbose\n keyword argument allows you to monitor the output of \ntraverse!\n and \norder!\n if something funny is happening while saving.\n\n\n\n\nIndex\n\n\n\n\nBase.maximum\n\n\nBase.maximum\n\n\nBase.minimum\n\n\nBase.minimum\n\n\nDevices.Cells.Cell\n\n\nDevices.Cells.CellArray\n\n\nDevices.Cells.CellReference\n\n\nDevices.Cells.order!\n\n\nDevices.Cells.traverse!\n\n\nDevices.Paths.CPW\n\n\nDevices.Paths.CompoundSegment\n\n\nDevices.Paths.CompoundStyle\n\n\nDevices.Paths.Segment\n\n\nDevices.Paths.Straight\n\n\nDevices.Paths.Style\n\n\nDevices.Paths.Trace\n\n\nDevices.Paths.Turn\n\n\nDevices.Paths.adjust!\n\n\nDevices.Paths.direction\n\n\nDevices.Paths.distance\n\n\nDevices.Paths.extent\n\n\nDevices.Paths.firststyle\n\n\nDevices.Paths.lastangle\n\n\nDevices.Paths.lastpoint\n\n\nDevices.Paths.laststyle\n\n\nDevices.Paths.launch!\n\n\nDevices.Paths.meander!\n\n\nDevices.Paths.origin\n\n\nDevices.Paths.param\n\n\nDevices.Paths.pathlength\n\n\nDevices.Paths.paths\n\n\nDevices.Paths.setorigin!\n\n\nDevices.Paths.set\u03b10!\n\n\nDevices.Paths.simplify!\n\n\nDevices.Paths.straight!\n\n\nDevices.Paths.turn!\n\n\nDevices.Paths.width\n\n\nDevices.Paths.\u03b10\n\n\nDevices.Points.getx\n\n\nDevices.Points.gety\n\n\nDevices.Polygons.Polygon\n\n\nDevices.Polygons.clip\n\n\nDevices.Polygons.offset\n\n\nDevices.Rectangles.Rectangle\n\n\nDevices.Rectangles.center\n\n\nDevices.Rectangles.height\n\n\nDevices.Rectangles.width\n\n\nDevices.bounds\n\n\nDevices.bounds\n\n\nDevices.bounds\n\n\nDevices.bounds\n\n\nDevices.bounds\n\n\nDevices.bounds\n\n\nDevices.render!\n\n\nFileIO.save", 
            "title": "API"
        }, 
        {
            "location": "/api/#points", 
            "text": "Points are implemented using the abstract type  FixedVectorNoTuple  from  FixedSizeArrays.jl . This permits a fast, efficient representation of coordinates in the plane. Additionally, unlike  Tuple  objects, we can add points together, simplifying many function definitions.  To interface with gdspy, we simply convert the  Point  object to a  Tuple  and let  PyCall.jl  figure out what to do.  #  Devices.Points.getx     Function .   getx(p::Point)  Get the x-coordinate of a point.  #  Devices.Points.gety     Function .   gety(p::Point)  Get the y-coordinate of a point.", 
            "title": "Points"
        }, 
        {
            "location": "/api/#paths", 
            "text": "", 
            "title": "Paths"
        }, 
        {
            "location": "/api/#segments", 
            "text": "#  Devices.Paths.Segment     Type .   abstract Segment{T :Real}  Path segment in the plane. All Segment objects should have the implement the following methods:   length  origin  \u03b10  setorigin!  set\u03b10!  lastangle   #  Devices.Paths.Straight     Type .   type Straight{T :Real}  : Segment{T}  A straight line segment is parameterized by its length. It begins at a point  origin  with initial angle  \u03b10 .  The parametric function over  t \u2208 [0,1]  describing the line segment is given by:  t -  origin + Point(t*l*cos(\u03b1),t*l*sin(\u03b1))  #  Devices.Paths.Turn     Type .   type Turn{T :Real}  : Segment{T}  A circular turn is parameterized by the turn angle  \u03b1  and turning radius  r . It begins at a point  origin  with initial angle  \u03b10 .  The center of the circle is given by:  cen = origin + Point(r*cos(\u03b10+sign(\u03b1)*\u03c0/2), r*sin(\u03b10+sign(\u03b1)*\u03c0/2))  The parametric function over  t \u2208 [0,1]  describing the turn is given by:  t -  cen + Point(r*cos(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t), r*sin(\u03b10-sign(\u03b1)*\u03c0/2+\u03b1*t))  #  Devices.Paths.CompoundSegment     Type .   type CompoundSegment{T :Real}  : Segment{T}  Consider an array of segments as one contiguous segment. Useful e.g. for applying styles, uninterrupted over segment changes.", 
            "title": "Segments"
        }, 
        {
            "location": "/api/#styles", 
            "text": "#  Devices.Paths.Style     Type .   abstract Style  How to render a given path segment. All styles should implement the following methods:   distance  extent  paths  width  divs   #  Devices.Paths.Trace     Type .   type Trace  : Style  Simple, single trace.   width::Function : trace width.  divs::Int : number of segments to render. Increase if you see artifacts.   #  Devices.Paths.CPW     Type .   type CPW  : Style  Two adjacent traces can form a coplanar waveguide.   trace::Function : center conductor width.  gap::Function : distance between center conductor edges and ground plane  divs::Int : number of segments to render. Increase if you see artifacts.   May need to be inverted with respect to a ground plane, depending on how the pattern is written.  #  Devices.Paths.CompoundStyle     Type .   type CompoundStyle{T :Real}  : Style  Combines styles together for use with a  CompoundSegment .   segments : Needed for divs function.  styles : Array of styles making up the object.  f : returns tuple of style index and the  t  to use for that style's parametric function.", 
            "title": "Styles"
        }, 
        {
            "location": "/api/#path-interrogation", 
            "text": "#  Devices.Paths.direction     Function .   direction(p::Function, t)  For some parameteric function  p(t)\u21a6Point(x(t),y(t)) , returns the angle at which the path is pointing for a given  t .  #  Devices.Paths.pathlength     Function .   pathlength(p::AbstractArray{Segment})  Total physical length of segments.  pathlength(p::Path)  Physical length of a path. Note that  length  will return the number of segments in a path, not the physical length.  #  Devices.Paths.origin     Function .   origin(p::Path)  First point of a path.  origin{T}(s::Segment{T})  Return the first point in a segment (calculated).  #  Devices.Paths.setorigin!     Function .   setorigin!(s::CompoundSegment, p::Point)  Set the origin of a compound segment.  setorigin!(s::Turn, p::Point)  Set the origin of a turn.  setorigin!(s::Straight, p::Point)  Set the origin of a straight segment.  #  Devices.Paths.\u03b10     Function .   \u03b10(p::Path)  First angle of a path.  \u03b10(s::Segment)  Return the first angle in a segment (calculated).  #  Devices.Paths.set\u03b10!     Function .   set\u03b10!(s::CompoundSegment, \u03b10\u2032)  Set the starting angle of a compound segment.  set\u03b10!(s::Turn, \u03b10\u2032)  Set the starting angle of a turn.  set\u03b10!(s::Straight, \u03b10\u2032)  Set the angle of a straight segment.  #  Devices.Paths.lastpoint     Function .   lastpoint(p::Path)  Last point of a path.  lastpoint{T}(s::Segment{T})  Return the last point in a segment (calculated).  #  Devices.Paths.lastangle     Function .   lastangle(p::Path)  Last angle of a path.  lastangle(s::Segment)  Return the last angle in a segment (calculated).  #  Devices.Paths.firststyle     Function .   firststyle(p::Path)  Style of the first segment of a path.  #  Devices.Paths.laststyle     Function .   laststyle(p::Path)  Style of the last segment of a path.", 
            "title": "Path interrogation"
        }, 
        {
            "location": "/api/#path-building", 
            "text": "#  Devices.Paths.adjust!     Function .   adjust!(p::Path, n::Integer=1)  Adjust a path's parametric functions starting from index  n . Used internally whenever segments are inserted into the path.  #  Devices.Paths.launch!     Function .   launch!(p::Path; extround=5, trace0=300, trace1=5,         gap0=150, gap1=2.5, flatlen=250, taperlen=250)  Add a launcher to the path. Somewhat intelligent in that the launcher will reverse its orientation depending on if it is at the start or the end of a path.  There are numerous keyword arguments to control the behavior:   extround : Rounding radius of the outermost corners; should be less than  gap0 .  trace0 : Bond pad width.  trace1 : Center trace width of next CPW segment.  gap0 : Gap width adjacent to bond pad.  gap1 : Gap width of next CPW segment.  flatlen : Bond pad length.  taperlen : Length of taper region between bond pad and next CPW segment.   Returns a  Style  object suitable for continuity with the next segment. Ignore the returned style if you are terminating a path.  #  Devices.Paths.meander!     Function .   meander!{T :Real}(p::Path{T}, len, r, straightlen, \u03b1::Real)  Alternate between going straight with length  straightlen  and turning with radius  r  and angle  \u03b1 . Each turn goes the opposite direction of the previous. The total length is  len . Useful for making resonators.  The straight and turn segments are combined into a  CompoundSegment  and appended to the path  p .  #  Devices.Paths.param     Function .   param{T :Real}(c::CompoundSegment{T})  Return a parametric function over the domain [0,1] that represents the compound segment.  #  Devices.Paths.simplify!     Function .   simplify!(p::Path)  All segments of a path are turned into a  CompoundSegment  and all styles of a path are turned into a  CompoundStyle . The idea here is:   Indexing the path becomes more sane when you can combine several path segments into one logical element. A launcher would have several indices in a path unless you could simplify it.  You don't need to think hard about boundaries between straights and turns when you want a continuous styling of a very long path.   #  Devices.Paths.straight!     Function .   straight!(p::Path, l::Real)  Extend a path  p  straight by length  l  in the current direction.  #  Devices.Paths.turn!     Function .   turn!(p::Path, s::ASCIIString, r::Real, sty::Style=laststyle(p))  Turn a path  p  with direction coded by string  s :   \"l\": turn by \u03c0/2 (left)  \"r\": turn by -\u03c0/2 (right)  \"lrlrllrrll\": do those turns in that order   turn!(p::Path, \u03b1::Real, r::Real, sty::Style=laststyle(p))  Turn a path  p  by angle  \u03b1  with a turning radius  r  in the current direction. Positive angle turns left.", 
            "title": "Path building"
        }, 
        {
            "location": "/api/#interfacing-with-gdspy", 
            "text": "#  Devices.Paths.distance     Function .   For a style  s  and parameteric argument  t , returns the distance between the centers of parallel paths rendered by gdspy.  #  Devices.Paths.extent     Function .   For a style  s  and parameteric argument  t , returns a distance tangential to the path specifying the lateral extent of the polygons rendered by gdspy.  #  Devices.Paths.paths     Function .   For a style  s  and parameteric argument  t , returns the number of parallel paths rendered by gdspy.  #  Devices.Paths.width     Function .   For a style  s  and parameteric argument  t , returns the width of paths rendered by gdspy.", 
            "title": "Interfacing with gdspy"
        }, 
        {
            "location": "/api/#polygons", 
            "text": "", 
            "title": "Polygons"
        }, 
        {
            "location": "/api/#rectangles", 
            "text": "#  Devices.Rectangles.Rectangle     Type .   type Rectangle{T :Real}  : AbstractPolygon{T}  A rectangle, defined by opposing corner coordinates.  #  Devices.bounds     Method .   bounds(r::Rectangle)  No-op (just returns  r ).  bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon s.  #  Devices.Rectangles.center     Method .   center(r::Rectangle)  Returns a Point corresponding to the center of the rectangle.  #  Devices.Rectangles.height     Method .   height(r::Rectangle)  Return the height of a rectangle.  #  Base.minimum     Method .   minimum(r::Rectangle)  Returns the lower-left corner of a rectangle (Point object).  minimum(itr)  Returns the smallest element in a collection.  #  Base.maximum     Method .   maximum(r::Rectangle)  Returns the upper-right corner of a rectangle (Point object).  maximum(itr)  Returns the largest element in a collection.  #  Devices.Rectangles.width     Method .   width(r::Rectangle)  Return the width of a rectangle.", 
            "title": "Rectangles"
        }, 
        {
            "location": "/api/#polygons_1", 
            "text": "#  Devices.Polygons.Polygon     Type .   type Polygon{T :Real}  Polygon defined by list of coordinates (not repeating start).  #  Devices.bounds     Method .   bounds(p::Polygon)  Return a bounding Rectangle with no properties for polygon  p .  bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon s.  #  Devices.bounds     Method .   bounds{T :AbstractPolygon}(parr::AbstractArray{T,1})  Return a bounding  Rectangle  with no properties for an array  parr  of  AbstractPolygon s.  #  Devices.bounds     Method .   bounds(p0::AbstractPolygon, p::AbstractPolygon...)  Return a bounding  Rectangle  with no properties for several  AbstractPolygon s.  #  Base.minimum     Method .   minimum(x::Polygon)  Return the lower-left-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  minimum(itr)  Returns the smallest element in a collection.  #  Base.maximum     Method .   maximum(x::Polygon)  Return the upper-right-most corner of a rectangle bounding polygon  x . Note that this point doesn't have to be in the polygon.  maximum(itr)  Returns the largest element in a collection.", 
            "title": "Polygons"
        }, 
        {
            "location": "/api/#clipping-and-offsetting", 
            "text": "As of now this package's notion of polygons is that there are no \"inner holes.\" Probably it would be helpful if we expanded our definition.  For clipping polygons we use  GPC  to get triangle strips which never have holes in them. These are then rendered as polygons individually. An obvious downside is that subsequent offsetting will not work as desired.  For offsetting polygons we use  Clipper . Clipper does not seem to support triangle strips so although the clipping is probably superior we cannot use it easily for now.  #  Devices.Polygons.clip     Function .   clip{S :Real, T :Real}(op::ClipperOp, subject::Polygon{S}, clip::Polygon{T})  Clip polygon  subject  by polygon  clip  using operation  op  from the  Clipper library . The  Python wrapper  over the C++ library is used.  Valid  ClipperOp  include  CT_INTERSECTION ,  CT_UNION ,  CT_DIFFERENCE ,  CT_XOR .  clip(op::GPCOp, subject::Polygon{Cdouble}, clip::Polygon{Cdouble})  Use the GPC clipping library to do polygon manipulations. Valid GPCOp include  GPC_DIFF ,  GPC_INT ,  GPC_XOR ,  GPC_UNION .  #  Devices.Polygons.offset     Function .   offset{S :Real}(subject::Polygon{S}, delta::Real,         j::ClipperJoin=JT_MITER, e::ClipperEnd=ET_CLOSEDPOLYGON)  Offset a polygon  subject  by some amount  delta  using the  Clipper library . The  Python wrapper  over the C++ library is used.  ClipperJoin  parameters are discussed  here . Valid syntax in this package is:  JT_SQUARE ,  JT_ROUND ,  JT_MITER .  ClipperEnd  parameters are discussed  here . Valid syntax in this package is:  ET_CLOSEDPOLYGON ,  ET_CLOSEDLINE ,  ET_OPENSQUARE ,  ET_OPENROUND ,  ET_OPENBUTT .  To do: Handle the type parameter of Polygon, which is ignored now.", 
            "title": "Clipping and offsetting"
        }, 
        {
            "location": "/api/#cells", 
            "text": "#  Devices.Cells.Cell     Type .   Cell  A cell has a name and contains polygons and references to  CellArray  or  CellReference  objects. It also records the time of its own creation.  To add elements, push them to  elements  field; to add references, push them to  refs  field.  #  Devices.Cells.CellArray     Type .   CellArray{S,T :Real}  Array of  cell  starting at  origin  with  row  rows and  col  columns, spanned by vectors  deltacol  and  deltarow . Optional x-reflection  xrefl::Bool , magnification factor  mag , and rotation angle  rot  in degrees are for the array as a whole.  The type variable  S  is to avoid circular definitions with  Cell .  #  Devices.Cells.CellReference     Type .   CellReference{S,T :Real}  Reference to a  cell  positioned at  origin , with optional x-reflection  xrefl::Bool , magnification factor  mag , and rotation angle  rot  in degrees.  The type variable  S  is to avoid circular definitions with  Cell .  #  Devices.bounds     Method .   bounds(cell::Cell; kwargs...)  Returns a  Rectangle  bounding box with no properties around all objects in  cell .  Point(NaN, NaN)  is used for the corners if there is nothing inside the cell.  #  Devices.bounds     Method .   bounds(ref::CellReference; kwargs...)  Returns a  Rectangle  bounding box with no properties around all objects in  ref .  Point(NaN, NaN)  is used for the corners if there is nothing inside the cell referenced by  ref . The bounding box respects reflection, rotation, and magnification specified by  ref .  #  Devices.Cells.traverse!     Function .   traverse!(a::AbstractArray, c::Cell, level=1)  Given a cell, recursively traverse its references for other cells and add to array  a  some tuples:  (level, c) .  level  corresponds to how deep the cell was found, and  c  is the found cell.  #  Devices.Cells.order!     Function .   order!(a::AbstractArray)  Given an array of tuples like that coming out of  traverse! , we sort by the  level , strip the level out, and then retain unique entries. The aim of this function is to determine an optimal writing order when saving pattern data (although the GDS-II spec does not require cells to be in a particular order, there may be performance ramifications).  For performance reasons, this function modifies  a  but what you want is the returned result array.", 
            "title": "Cells"
        }, 
        {
            "location": "/api/#rendering", 
            "text": "#  Devices.render!     Function .   render!(c::Cell, segment::Paths.Segment, s::Paths.Style; kwargs...)  Render a  segment  with style  s  to cell  c .  render!(c::Cell, segment::Paths.Segment, s::Paths.DecoratedStyle; kwargs...)  Render a  segment  with decorated style  s  to cell  c . This method draws the decorations before the path itself is drawn.  render!(c::Cell, p::Path; kwargs...)  Render a path  p  to a cell  c .  render!(c::Cell, r::Polygon, s::Polygons.Style=Polygons.Plain(); kwargs...)  Render a polygon  r  to cell  c , defaulting to plain styling.  render!(c::Cell, r::Rectangle, s::Rectangles.Style=Rectangles.Plain(); kwargs...)  Render a rectangle  r  to cell  c , defaulting to plain styling.  render!(c::Cell, r::Rectangle, s::Rectangles.Rounded; kwargs...)  Render a rounded rectangle  r  to cell  c . This is accomplished by rendering a path around the outside of a (smaller than requested) solid rectangle. The bounding box of  r  is preserved.  render!(c::Cell, r::Rectangle, ::Rectangles.Plain; kwargs...)  Render a rectangle  r  to cell  c  with plain styling.", 
            "title": "Rendering"
        }, 
        {
            "location": "/api/#saving-patterns", 
            "text": "To save a pattern, make sure you are  using FileIO .  #  FileIO.save     Method .   save ( f : :File { format GDS } ,   cell0 : :Cell ,   cell : :Cell ...;  name = GDSIILIB ,   precision = 1e-9 ,   unit = 1e-6 ,   modify = now (),   acc = now (),  verbose = false ) `   This method is implicitly called when you use the convenient syntax:  save(\"/path/to/my.gds\", cells_i_want_to_save...)  The  name  keyword argument is used for the internal library name of the GDS-II file and is probably inconsequential for modern workflows.  The  verbose  keyword argument allows you to monitor the output of  traverse!  and  order!  if something funny is happening while saving.", 
            "title": "Saving patterns"
        }, 
        {
            "location": "/api/#index", 
            "text": "Base.maximum  Base.maximum  Base.minimum  Base.minimum  Devices.Cells.Cell  Devices.Cells.CellArray  Devices.Cells.CellReference  Devices.Cells.order!  Devices.Cells.traverse!  Devices.Paths.CPW  Devices.Paths.CompoundSegment  Devices.Paths.CompoundStyle  Devices.Paths.Segment  Devices.Paths.Straight  Devices.Paths.Style  Devices.Paths.Trace  Devices.Paths.Turn  Devices.Paths.adjust!  Devices.Paths.direction  Devices.Paths.distance  Devices.Paths.extent  Devices.Paths.firststyle  Devices.Paths.lastangle  Devices.Paths.lastpoint  Devices.Paths.laststyle  Devices.Paths.launch!  Devices.Paths.meander!  Devices.Paths.origin  Devices.Paths.param  Devices.Paths.pathlength  Devices.Paths.paths  Devices.Paths.setorigin!  Devices.Paths.set\u03b10!  Devices.Paths.simplify!  Devices.Paths.straight!  Devices.Paths.turn!  Devices.Paths.width  Devices.Paths.\u03b10  Devices.Points.getx  Devices.Points.gety  Devices.Polygons.Polygon  Devices.Polygons.clip  Devices.Polygons.offset  Devices.Rectangles.Rectangle  Devices.Rectangles.center  Devices.Rectangles.height  Devices.Rectangles.width  Devices.bounds  Devices.bounds  Devices.bounds  Devices.bounds  Devices.bounds  Devices.bounds  Devices.render!  FileIO.save", 
            "title": "Index"
        }, 
        {
            "location": "/LICENSE/", 
            "text": "The Devices.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Andrew Keller.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }
    ]
}